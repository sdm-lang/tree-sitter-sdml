Module
    ::= "module" Identifier ModuleBase? ModuleBody

ModuleBase
    ::= "base" IriReference

ModuleBody
    ::= "is"
        ImportStatement* Annotation* Definition*
        "end"

ImportStatement
    ::= "import" ( Import | "[" Import+ "]" )

Import
    ::= MemberImport | ModuleImport

ModuleImport
    ::= Identifer

MemberImport
    ::= QualifiedIdentifier

Annotation
    ::= AnnotationProperty | Constraint

AnnotationProperty
    ::= "@" IdentiferReference "=" Value

Definition
    ::= DataTypeDef
        | EntityDef
        | EnumDef
        | EvqentDef
        | StructureDef
        | UnionDef
        | PropertyDef

DataTypeDef
    ::= "datatype" Identifier "<-" DataTypeBase AnnotationOnlyBody?

DataTypeBase
    ::= IdentifierReference | BuiltinSimpleType

AnnotationOnlyBody
    ::= "is" Annotation+ "end"

EntityDef
    ::= "entity" Identifier EntityBody?

EntityBody
    ::= "is"
        Annotation* IdentityMember ( EntityMember | EntityGroup )*
        "end"

EntityGroup
    ::= "group" Annotation* EntityMember+ "end"

EntityMember
    ::= MemberByValue | MemberByReference

EnumDef
    ::= "enum" Identifier EnumBody?

EnumBody
    ::= "of" Annotation* ValueVariant+ "end"

ValueVariant
    ::= Identifier "=" Unsigned AnnotationOnlyBody?

EventDef
    ::= "event" Identifier
        "source" IdentifierReference
        StructureBody?

StructureDef
    ::= "structure" Identifier StructureBody?

StructureBody
    ::= "is" Annotation* ( MemberByValue | StructureGroup )* "end"

StructureGroup
    ::= "group" Annotation* MemberByValue+ "end"

UnionDef
    ::= "union" Identifier UnionBody?

UnionBody
    ::= "of"
        Annotation* TypeVariant+
        "end"

TypeVariant
    ::= IdentifierReference TypeVariantRename? AnnotationOnlyBody?

TypeVariantRename
    ::= "as" Identifier

PropertyDef
    ::= "property" Identifier PropertyBody?

PropertyBody
    ::= "is" Annotation* PropertyRole+ "end"

PropertyRole
    ::= IdentityRole | RoleByValue | RoleByReference

IdentityRole
    ::= "identity" Identifier TypeExpression AnnotationOnlyBody?

RoleByValue
    ::= Identifier TypeExpressionTo AnnotationOnlyBody?

RoleByReference
    ::= "ref" Identifier InverseName? TypeExpressionTo AnnotationOnlyBody?

PropertyMember
    ::= "in" IdentifierReference

IdentityMember
    ::= "identity" Identifier
        ( PropertyMember | ( TypeExpression AnnotationOnlyBody? ) )

MemberByValue
    ::= Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )

MemberByReference
    ::= "ref" Identifier
        ( PropertyMember | ( InverseName? TypeExpressionTo AnnotationOnlyBody? ) )

TypeExpression
    ::= "->" TypeReference

TypeExpressionTo
    ::= "->" Cardinality? TypeReference

TypeReference
    ::=  UnknownType | IdentifierReference | BuiltinSimpleType | MappingType

UnknownType
    ::= "unknown"

MappingType
    ::= "(" TypeReference "->" TypeReference ")"

Cardinality
    ::= "{" SequenceOrdering? SequenceUniqueness? CardinalityInner "}"

CardinalityInner
    ::= Unsigned CardinalityRange?

CardinalityRange
    ::= ".." Unsigned?

SequenceOrdering
    ::= ( "ordered" | "unordered" )

SequenceUniqueness
    ::= ( "unique" | "nonunique" )

InverseName
    ::= "(" Identifier ")"

Value
    ::=  SimpleValue
        | ValueConstructor
        | IdentifierReference
        | MappingValue
        | SequenceOfValues

SimpleValue
    ::= String | Double | Decimal | Integer | Boolean | IriReference

BuiltinSimpleType
    ::= "string" | "double" | "decimal" | "integer" | "boolean" | "iri"

Boolean
    ::= Tautology | Contradiction

Tautology
    ::= ( "true" | "⊤" )

Contradiction
    ::= ( "false" | "⊥" )

NumericSign
    ::= [+-]

Zero
    ::= [0]

NonZero
    ::= [1-9]

Unsigned
    ::= Zero | NonZero ASCII_DIGIT*

Integer
    ::= NumericSign? Unsigned

Decimal
    ::= Integer "." ASCII_DIGIT+

ExponentChar
    ::= [eE]

Double
    ::= Decimal ExponentChar NumericSign? Integer

String
    ::= QuotedString LanguageTag?

QuotedString
    ::= '"' ( Escape | NotAllowed )* '"'

NotAllowed
    ::= [^\"\#x00-#x08#x0B-#x1F#x7F]

Escape
    ::= "\\" ( CharacterEscape | UnicodeEscape )

CharacterEscape
    ::= [\"\\/abefnrtv]

UnicodeEscape
    ::= "u{" HexPair ( HexPair ( HexPair )? )? "}"

HexPair
    ::= ASCII_HEX_DIGIT ASCII_HEX_DIGIT

LanguageTag
    ::= "@"
        LanguageTagPrimary
        LanguageTagExtended?
        LanguageTagScript?
        LanguageTagRegion?

LanguageTagPrimary
    ::= ASCII_LETTER_LOWER ASCII_LETTER_LOWER ASCII_LETTER_LOWER?

LanguageTagExtended
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_UPPER ASCII_LETTER_UPPER

LanguageTagScript
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_LOWER
        ASCII_LETTER_LOWER ASCII_LETTER_LOWER

LanguageTagRegion
    ::= "-"
        ( ( ASCII_LETTER_UPPER ASCII_LETTER_UPPER )
          | ( ASCII_DIGIT ASCII_DIGIT ASCII_DIGIT ) )

IriReference
    ::=
    "<"
    ( [^<>\"{}|^`\#x00-#x20] | UnicodeEscape )*
    ">"

ValueConstructor
    ::= IdentifierReference "(" SimpleValue ")"

MappingValue
    ::= SimpleValue  "->" Value

SequenceOfValues
    ::= SequenceValueConstraint? "["
        ( SimpleValue | ValueConstructor | IdentifierReference )+
        "]"

SequenceValueConstraint
    ::= "{"
        ( SequenceOrdering? SequenceUniqueness? )
        "}"

IdentifierInitial
    ::= UC_LETTER_UPPER | UC_LETTER_LOWER

IdentifierChar
    ::= IdentifierInitial | UC_NUMBER_DECIMAL

Identifier
    ::= IdentifierInitial
        IdentifierChar* ( "_" IdentifierChar+ )*

QualifiedIdentifier
    ::= Identifier ":" Identifier

IdentifierReference
    ::= QualifiedIdentifier | Identifier

LineComment
    ::= ";" [^\r\n]*

Whitespace
    ::= [^\f\n\r\t\v#x20#xa0#x1680#x2000#x200a#x2028#x2029#x202f#x205f#x3000#xfeff]

/* --------------------------------------------------------------------------- */

Constraint
    ::= "assert" Identifier ( InformalConstraint | FormalConstraint )

InformalConstraint
    ::= "=" QuotedString ControlledLanguageTag?

ControlledLanguageTag
    ::= "@" LanguageTagPrimary ControlledLanguageScheme?

ControlledLanguageScheme
         "-"
        ETTER ASCII_LETTER ASCII_LETTER
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?

FormalConstraint
    ::= "is"
        ConstraintEnvironment? ConstraintSentence
        "end"

ConstraintSentence
    ::= SimpleSentence
        | BooleanSentence
        | QuantifiedSentence
        | "(" ConstraintSentence ")"

SimpleSentence
    ::= Atomic | Equation

Atomic
    ::= Term "(" Term* ")"

Equation
    ::= Term "=" Term

BooleanSentence
    ::= Negation
        | ConstraintSentence
          (
            Conjunction | Disjunction | ExclusiveDisjunction |
            Implication | Biconditional
          )

Negation
    ::= ( "not" | "¬" ) ConstraintSentence

Conjunction
    ::= ( "and" | "∧" ) ConstraintSentence

Disjunction
    ::= ( "or" | "∨" ) ConstraintSentence

ExclusiveDisjunction
    ::= ( "xor" | "⊻" ) ConstraintSentence

Implication
    ::= ( "implies" | "⇒" ) ConstraintSentence

Biconditional
    ::= ( "iff" | "⇔" ) ConstraintSentence

QuantifiedSentence
    ::= Universal | Existential

Universal
    ::= ( "forall" | "∀" ) QuantifierBinding+ QuantifiedBody

Existential
    ::= ( "exists" | "∃" ) QuantifierBinding+ QuantifiedBody

QuantifierBinding
    ::= "self" | ( Identifer IteratorTarget )

IteratorTarget
    ::= TypeIterator | SequenceIterator | "(" IteratorTarget ")"

TypeIterator
    ::= "->" ( "Self" | IdentifierReference )

SequenceIterator
    ::= ( "in" | "∈" ) ( NamePath | Identifier | SequenceBuilder )

QuantifiedBody
    ::= "(" ConstraintSentence ")"

Term
    ::= NamePath
        | Identifier
        | QualifiedIdentifier
        | PredicateValue
        | FunctionalTerm
        | SequenceBuilder

NamePath
    ::= PathSubject ( "." Identifier )+

PathSubject
    ::= ( "self" | Identifier )

PredicateValue
    ::= SimpleValue | SequenceOfPredicateValues

SequenceOfPredicateValues
    ::= "∅"
        | SequenceValueConstraint?
          "[" ( SimpleValue | IdentifierReference )* "]"

FunctionalTerm
    ::= Term "(" Term* ")"

/* --------------------------------------------------------------------------- */

ConstraintEnvironment
    ::= EnvironmentDef+ "in"

EnvironmentDef
    ::= "def" Identifier ( FunctionDef | ConstantDef )

FunctionDef
    ::= FunctionSignature ( ":=" | "≔" ) ConstraintSentence

FunctionSignature
    ::= "(" FunctionParameter+ ")" "->" FunctionType

FunctionParameter
    ::= Identifier "->" FunctionType

FunctionType
    ::=  FunctionCardinality? FunctionTypeRef

FunctionCardinality
    ::= "{"
        SequenceOrdering? SequenceUniqueness? ( Wildcard | CardinalityInner )
        "}"

FunctionTypeRef
    ::= Wildcard | IdentiferReference | BuiltinSimpleType | MappingType

Wildcard
    ::= "_"

ConstantDef
    ::= ( ":=" | "≔" ) ( PredicateValue | ConstraintSentence )

/* --------------------------------------------------------------------------- */

SequenceBuilder
    ::= "{" Variables "|" Expression "}"

Variables
    ::= TupleVariable
        | SequenceVariable
        | MappingVariable

TupleVariable
    ::= Identifier+

SequenceVariable
    ::= "[" Identifier+ "]"

MappingVariable
    ::= "(" Identifier "->" Identifier ")"

Expression
    ::= ConjunctiveExpression
        | LocalBinding
        | ConstraintSentence
        | "(" Expression ")"

ConjunctiveExpression
    ::= Expression ( "and" | "∧" ) Expression

LocalBinding
    ::= Identifier ( TypeIterator | SequenceIterator )
