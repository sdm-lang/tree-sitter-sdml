#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* <<sec:surface-syntax>>The Surface Syntax

This section describes the SDML surface syntax, a syntax intended to look and feel like a programming language but with
extensibility provided by it's underlying RDF and OWL foundation. The goal of the following syntax is to allow for rapid
capture of domain information but allowing elaboration of details over time. To this end we have made language features
optional wherever possible such that the minimum information neccessary is required to build a valid model. This
document will use the terms /valid/ to denote a model that has no syntactic errors and /complete/ to denote a valid model
that has no short-form, or /incomplete/, model elements.

The grammar, where possible, supports Unicode representations of keywords and operators that allow for formatting a
source module with more compact expressions. This is to obviate the need for separate type-setting tools that typically
perform a one-way transformation from source to some other format. See table [[tbl:unicode-characters]] in appendix
[[app:unicode]] for details.

For the complete grammar, and notes on BNF notation, see section [[sec:complete-grammar]].

** Whitespace and Comments

This grammar chooses to use the JavaScript regular expression character class =\s= which includes the following values,
including all Unicode whitespace.

#+NAME: lst:grammar-whitespace
#+BEGIN_SRC ebnf
Whitespace
    ::= [^\f\n\r\t\v#x20#xa0#x1680#x2000#x200a#x2028#x2029#x202f#x205f#x3000#xfeff]
#+END_SRC

Comments follow Lisp-like forms, starting with a semi-colon character and continuing to the end of line. Comments are
intended to capture only information regarding the file contents and not model contents. Because of this, parsers are
*not* required to capture comments, and tools are *not* required to emit comments back into changed files. For persistent
comments within the model, relevant annotation properties may be attached to the model elements.

#+NAME: lst:grammar-line-comment
#+BEGIN_SRC ebnf
LineComment
    ::= ";" [^\r\n]*
#+END_SRC

[[./ebnf-diagram/LineComment.svg]]

#+NAME: lst:grammar-comment
#+CAPTION: Comments
#+BEGIN_SRC sdml :exports code :noeval
; <- comments start here and end here ->
#+END_SRC

In the following example a tool reading the following file is not required to preserve the comment, which in this case
is OK as the ~editorialNote~ will be preserved and correctly used for the same purpose.

#+NAME: lst:grammar-annotation-comment
#+CAPTION: Annotation Comments
#+BEGIN_SRC sdml :exports code :noeval
module foo is
  import [dc skos]

  ; Should come up with a better name.
  @skos:prefLabel = "Foo"@en
  @dc:description = "Here's a descriptive comment"
  @skos:editorialNode = "Someone should fix the name"
end
#+END_SRC

** Identifiers

An identifier is a string of characters corresponding to the Unicode General Category[fn:ucgc] *Lu* (an uppercase letter),
*Ll* (a lowercase letter), *Nd* (decimal digit), or the Unicode Low Line (underscore, "_", =U+005F=) character. Specifically
an identifer *must* start with and *must* begin and end with a letter such that the low line character may only appear
/within/ the identifier.

The following is the BNF description of the identifier syntax.

#+NAME: lst:grammar-identifier
#+BEGIN_SRC ebnf
Identifier
    ::= IdentifierInitial
        IdentifierChar* ( "_" IdentifierChar+ )*
#+END_SRC

[[./ebnf-diagram/Identifier.svg]]

#+BEGIN_SRC ebnf
IdentifierInitial
    ::= UC_LETTER_UPPER | UC_LETTER_LOWER
#+END_SRC

[[./ebnf-diagram/IdentifierInitial.svg]]

#+BEGIN_SRC ebnf
IdentifierChar
    ::= IdentifierInitial | UC_NUMBER_DECIMAL
#+END_SRC

[[./ebnf-diagram/IdentifierChar.svg]]

Naming Conventions:

- *Module Name* :: lower Camel Case; i.e. =xsd=, =skos=, =bank=, or =customer=. In general this should be a broad noun.
- *Structure/Entity/Event/Enum Name* :: Upper Camel Case; i.e. =Customer=, =Account=, =Address=, or =Name=. In general
  these are nouns related to, and often narrower than, the module name.
- *Data Type Name* :: Upper Camel Case; i.e. =ShortString=, =AccountNumber=, or =SocialSecurityNumber=. In general these are
  broad nouns, with either a property noun suffix as in =AccountNumber= or a qualifier noun prefix as in =ShortString=. Do
  not create capitalized acronym (SSN) or abbreviation (ID) forms unless these are universally understood within the
  domain.
- *Type Member Name* :: lower Camel Case; i.e. =street=, =accountName=, or =currentValue=. As in data type definitions these are
  broad nouns, with either a property noun suffix as in =accountNumber= or a qualifier noun prefix as in =shortName=. These
  are commonly simply the lower Camel Case version of the corresponding type name.
- *Enum and Union Variant Name* :: Upper Camel Case is the preferred, although SHOUTY CASE is acceptable.

*** Qualified Identifier

A qualified identifier comprises a module identifier followed by the Colon (":", =U+003A=) character and the identifier of
a member within that module.

#+NAME: lst:grammar-qualified-identifier
#+BEGIN_SRC ebnf
QualifiedIdentifier
    ::= Identifier ":" Identifier
#+END_SRC

[[./ebnf-diagram/QualifiedIdentifier.svg]]

A type reference may be to a locally defined type by an identifier, or an imported type by a qualified identifier.

#+NAME: lst:grammar-identifier-reference
#+BEGIN_SRC ebnf
IdentifierReference
    ::= QualifiedIdentifier | Identifier
#+END_SRC

[[./ebnf-diagram/IdentifierReference.svg]]

** <<sec:modules-and-imports>> Module Definition and Imports

A module is the container for a set of type definitions and typically models a /Domain/ or /Sub-domain/. A single resource
(in the web sense of some /thing/ identified by an IRI) may contain only a single module; therefore, the smallest valid
resource is one with an empty module.

#+NAME: lst:grammar-module
#+BEGIN_SRC ebnf
Module
    ::= "module" Identifier ModuleBase? ModuleBody
#+END_SRC

[[./ebnf-diagram/Module.svg]]

An empty module (listing [[lst:sdml-ex-empty-module]]) is any module with an empty /body/, delimited by the keywords *~is~* and
*~end~*.

#+NAME: lst:sdml-ex-empty-module
#+CAPTION: Empty Module
#+BEGIN_SRC sdml :exports code :noeval
module example is end
#+END_SRC

*** The base Specifier

#+BEGIN_SRC ebnf
ModuleBase
    ::= "base" IriReference
#+END_SRC

[[./ebnf-diagram/ModuleBase.svg]]

The keyword *~base~* provides the base IRI for the module and corresponding RDF schema or OWL ontology. This corresponds to
the use of the ~xml:base~ attribute in RDF/XML and the ~@base~ directive in Turtle and SPARQL[fn:sparql]. This IRI is used
as a prefix for defined type names so that each type has a unique IRI. The example in listing
[[lst:sdml-ex-empty-module-base]] demonstrates the assigned IRI identifier for the structure type named ~Thing~.

#+NAME: lst:sdml-ex-empty-module-base
#+CAPTION: Empty Module with Base
#+BEGIN_SRC sdml :exports code :noeval
module example base <https://example.org/rdf/example#> is

  structure Thing
  ;; IRI: https://example.org/rdf/example#Thing

end
#+END_SRC

*Module URI Resolution*

Each module has an identifer/name defined within the module source as well as a base URI used to assign URIs to every
model element within the resource. This URI identifier for each model element necessary as the identifier for the
corresponding RDF resource(s). Our first problem is to determine the base URI for the module,as follows:

1. If the module has a base specifier it MUST be used as the module URI.
2. If the reader has access to an SDML catalog file (For details of the catalog file format see appendix [[sec:resolver-catalog]]), a matching catalog entry MUST be used as the module URI.
3. A URI is calculated for the module using the =file:= scheme and the file path relative to a /project root/.

Considering the following simple module in the file =vehicle.sdm=.

#+BEGIN_SRC sdml :exports code :noeval
module vehicle is end
#+END_SRC

If the following file is in the same directory as the vehicle module it is possible to   

#+BEGIN_SRC json :noeval
{
  "base": "https://example.org/rentals/",
  "entries": {
    "rentals": {
      "item": {
        "relative_name": "vehicle#",
        "relative_path": "vehicle-v1.sdm"
      }
    }
  }
}
#+END_SRC

*** Importing Modules and Members

#+BEGIN_SRC ebnf
ModuleBody
    ::= "is"
        ImportStatement* Annotation* Definition*
        "end"
#+END_SRC

[[./ebnf-diagram/ModuleBody.svg]]

To import types from other modules you add one or more import statements to the module body. Each statement may
reference one or more module names or the qualified name of a type within a module.

#+NAME: lst:grammar-import-statement
#+BEGIN_SRC ebnf
ImportStatement
    ::= "import" ( Import | "[" Import+ "]" )
Import
    ::= MemberImport | ModuleImport
#+END_SRC

[[./ebnf-diagram/ImportStatement.svg]]

[[./ebnf-diagram/Import.svg]]

Importing a module allows access to all members of that module using qualified identifiers. For example, importing
module ~sdml~ allows the reference of core types as ~sdml:string~ or ~sdml:decimal~.

#+BEGIN_SRC ebnf
ModuleImport
    ::= Identifer
#+END_SRC

[[./ebnf-diagram/ModuleImport.svg]]

Importing a module member directly still results in a qualified identifier, but makes the dependency clearer. For
example, in the case above if we are only using the ~string~ member from the ~sdml~ module importing ~sdml:string~ is cleaner.

#+BEGIN_SRC ebnf
MemberImport
    ::= QualifiedIdentifier
#+END_SRC

[[./ebnf-diagram/MemberImport.svg]]

The module in listing [[lst:sdml-ex-import-module]] contains a single import statement /referencing/ the module named =xsd=
making it's members /visible/ in the qualified form =xsd:*=.

#+NAME: lst:sdml-ex-import-module
#+CAPTION: Importing Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import xsd

end
#+END_SRC

The module in listing [[lst:sdml-ex-import-member]] contains a single import statement /referencing/ the member named =integer= from
the module =xsd= making it visible.

#+NAME: lst:sdml-ex-import-member
#+CAPTION: Importing Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import xsd:integer

end
#+END_SRC

To reduce the number of import statements a list of identifiers, both module and member, may be /referenced/ as a list.
Listing [[lst:sdml-ex-import-list]] makes the members =author= and =title= from the module =dc= visible. Lists in SDML start
with the Left Square Bracket ("[", =U+005B=) character and end with the Right Square Bracket ("]", =U+005D=) character with
no separator character between members of the list.

#+NAME: lst:sdml-ex-import-list
#+CAPTION: Importing a List
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ dc:title dc:author ]

end
#+END_SRC

*** Definitions

The members of a module are a set of definitions that may be combined to develop a domain model.

#+BEGIN_SRC ebnf
Definition
    ::= DataTypeDef
        | EntityDef
        | EnumDef
        | EventDef
        | StructureDef
        | UnionDef
        | PropertyDef
        | FeatureSetDef
#+END_SRC

[[./ebnf-diagram/Definition.svg]]

Data types are further described in section [[sec:datatypes]]; entities, enumerations, events, structures, and disjoint
unions are described in section [[sec:structured-types]]; and properties are described in section [[sec:properties]].

*** Type Model

A subset of the definition types in the EBNF above are types, and the complete type model for SDML is shown in figure
[[fig:sdml-type-model]]. In this figure the following types exist that are not directly reified in the surface syntax.

- Any :: The root of our type system, or the type of /all individuals/. This is sometimes termed /top/ or a tautology ~⊤~.
- Scalar :: A scalar type refers to a data type whose individuals represent a single discrete value. In SDML all
  datatypes and enumerations are scalar types.
- Sum :: A type whose members are discrete but not necessarily scalar, i.e. it's individuals are either one member /or/
  another, but not both. In the case of SDML only disjoint unions are sum types.
- Product :: A type whose members are all present, i.e. it's individuals have one member /and/ another and so on. In SDML
  entities, events, and structures are product types.
- Unknown :: A pseudo-type that is applied when the author does not yet know what the type should be but wishes to
  create a valid model. In SDML member types may be defined as ~unknown~ during module development but such a type, and
  therefore it's containing module, is incomplete.
- None :: A type which represents the type of /zero individuals/ and is therefore invalid as a member type. This is
  sometimes termed /bottom/ or /absurdity/ ~⊥~.

#+NAME: lst:sdml-type-model
#+BEGIN_SRC dot :file sdml-type-model.svg :exports results
strict digraph {
   bgcolor="transparent";
   rankdir=BT;
   fontname="Helvetica,Arial,sans-serif";
   node [shape="rect"; fontname="Helvetica,Arial,sans-serif"; fontsize=10; width=1.0; height=0.4];
   edge [arrowhead=onormal; fontname="Helvetica,Arial,sans-serif"; fontsize=9; fontcolor="darkgrey"];
   
   Type [color="grey"; fontcolor="grey"; label="Any\n(⊤)"];
   Scalar -> Type;
   Scalar [color="grey"; fontcolor="grey"];
   Datatype -> Scalar;
   Sum [color="grey"; fontcolor="grey"];
   Sum -> Type;
   Enumeration -> Scalar;
   Union -> Sum;
   Product [color="grey"; fontcolor="grey"];
   Product -> Type;
   Entity -> Product;
   Event -> Product;
   Structure -> Product;
   Unknown [label="Unknown\n(⊥)"];
   Unknown -> Type;
        
   None [color="grey"; fontcolor="grey"; label="None\n(⊥)"];
   None -> Datatype;
   None -> Enumeration;
   None -> Union;
   None -> Entity;
   None -> Event;
   None -> Structure;
}
#+END_SRC

#+NAME: fig:sdml-type-model
#+CAPTION: SDML Type Model
#+RESULTS: lst:sdml-type-model
[[file:sdml-type-model.svg]]

*Sum vs. Product*

Given a type $T$ with members $m_1, \cdots m_n$, and a relation $\tau_{m_i}$ that returns the type of a value or definition, we can show
this mathematically as follows.

1. Because a sum type may only be one member *or* another at any time the number of potential values (shown below as the
   cardinality of the type) is the number of values in each member added together $m_1 + m_2 + \cdots m_n$.

   $$ \sum_{m \in T} |\tau_m| $$

1. Because a product type has it's first member *and* second *and* so on, the number of potential values is the number of
   values in each member multiplied together $m_1 \times m_2 \times \cdots m_n$. This is also known as the /Cartesian
   Product/ of the set $\{m_1, \cdots m_n\}$.

   $$ \prod_{m \in T} |\tau_m| $$

** <<sec:datatypes>>Data Types and Values

A data type /individual/, or simply a /value/, is either a simple value, a value constructor, an identifier reference, a
mapping value, or a list of values.

#+NAME: lst:grammar-value
#+BEGIN_SRC ebnf
Value
    ::=  SimpleValue
        | ValueConstructor
        | IdentifierReference
        | MappingValue
        | SequenceOfValues
#+END_SRC

[[./ebnf-diagram/Value.svg]]

The inclusion of an identifier reference as a value allows for annotations whose value is another model element. It is
invalid to use the identifier of an individual that is not itself a value.

*** Simple Values

The core data types supported by SDML are ~boolean~, ~integer~, ~decimal~, ~double~, ~string~, (Language-Tagged String), and ~iri~
for IRI References. Values corresponding to these types are termed /simple values/.

#+NAME: lst:grammar-simple-value
#+BEGIN_SRC ebnf
SimpleValue
    ::= Boolean
        | Unsigned | Integer | Decimal| Double
        | String | Iri | Binary
#+END_SRC

[[./ebnf-diagram/SimpleValue.svg]]

*Booleans*

A /boolean/ value in SDML is either the keyword ~true~ or ~false~.

#+NAME: lst:grammar-boolean
#+BEGIN_SRC ebnf
Boolean
    ::= Tautology | Contradiction
#+END_SRC

[[./ebnf-diagram/Boolean.svg]]

#+BEGIN_SRC ebnf
Tautology
    ::= ( "true" | "⊤" )
#+END_SRC

[[./ebnf-diagram/Tautology.svg]]

#+BEGIN_SRC ebnf
Contradiction
    ::= ( "false" | "⊥" )
#+END_SRC

[[./ebnf-diagram/Contradiction.svg]]

*Unsigned Integers*

An /unsigned/ value in SDML is a string of ASCII decimal digits, without leading zeros; zero, =0=, is a valid value however
=00= and =01= are not. The unsigned type corresponds to a 64-bit unsigned integer number (values $[0, 2^{64}-1]$).

#+NAME: lst:grammar-unsigned
#+BEGIN_SRC ebnf
Unsigned
    ::= Zero | NonZero ASCII_DIGIT*
Zero
    ::= [0]
NonZero
    ::= [1-9]
#+END_SRC

[[./ebnf-diagram/Unsigned.svg]]

[[./ebnf-diagram/Zero.svg]]

[[./ebnf-diagram/NonZero.svg]]

*Signed Integers*

A /signed integer/ value in SDML is a string of ASCII decimal digits, without leading zeros; zero, =0=, is a valid value however
=00= and =01= are not. The integer type corresponds to a 64-bit signed integer number (values $[−2^{63}, 2^{63} − 1]$).

#+NAME: lst:grammar-integer
#+BEGIN_SRC ebnf
Integer
    ::= NumericSign? Unsigned
NumericSign
    ::= [+-]
#+END_SRC

[[./ebnf-diagram/Integer.svg]]

[[./ebnf-diagram/NumericSign.svg]]

*Decimal Numbers*

A /decimal/ (fixed point) value in SDML is an integer-like value, followed by the Full Stop (".", =U+002E=) character and another
integer-like value. The decimal type corresponds to a 128-bit representation of a fixed-precision decimal number.

#+NAME: lst:grammar-decimal
#+BEGIN_SRC ebnf
Decimal
    ::= Integer "." ASCII_DIGIT+
#+END_SRC

*Floating-Point Numbers*

A /double/ value in SDML is a decimal-like value followed by a lower or upper case letter E (Latin Small Letter E, "e",
=U+0065= or Latin Capital Letter E, "E", =U+0045=), a sign character (Hyphen Minus, "-", =U+002D= or Plus Sign, "+", =U+002B=)
and an integer-like value. The double type is a 64-bit floating point number (specifically, the "binary64" type defined
in IEEE 754-2008).

#+NAME: lst:grammar-double
#+BEGIN_SRC ebnf
Double
    ::= Decimal ExponentChar NumericSign? Integer
ExponentChar
    ::= [eE]
#+END_SRC

[[./ebnf-diagram/Double.svg]]

[[./ebnf-diagram/ExponentChar.svg]]

*Character Strings*

A /string/ value in SDML is a sequence of Unicode characters starting and ending with a Quotation Mark ('"', =U+0022=)
character. While standard escape sequences allow for embedding non-printing characters. The form =\u{XXXX}=, where =X= is a
single hex digit, allows for the inclusion of any Unicode characters by their code point. Note that this form requires a
minimum of 2 and a maximum of 6 such digits. In addition,the following single-character escape characters are supported.

#+NAME: lst:grammar-string
#+BEGIN_SRC ebnf
String
    ::= QuotedString LanguageTag?
QuotedString
    ::= '"' ( Escape | NotAllowed )* '"'
NotAllowed
    ::= [^\"\#x00-#x08#x0B-#x1F#x7F]
#+END_SRC

[[./ebnf-diagram/String.svg]]

[[./ebnf-diagram/QuotedString.svg]]

[[./ebnf-diagram/NotAllowed.svg]]

#+NAME: lst:grammar-string-escape
#+BEGIN_SRC ebnf
Escape              ::= "\\" ( CharacterEscape | UnicodeEscape )
CharacterEscape     ::= [\"\\/abefnrtv]
UnicodeEscape       ::= "u{" HexPair ( HexPair ( HexPair )? )? "}"
HexPair             ::= HexDigit HexDigit
#+END_SRC

[[./ebnf-diagram/Escape.svg]]

[[./ebnf-diagram/CharacterEscape.svg]]

[[./ebnf-diagram/UnicodeEscape.svg]]

[[./ebnf-diagram/HexPair.svg]]

Note also that strings allow literal newlines and do not /require/ they be present in escaped form. This means that a
string literal supports multiline forms.

#+NAME: tbl:string-escape-characters
#+CAPTION: String Escape Characters
| Escape Character | Character Name (Common Name)          | Unicode Equivalent |
|------------------+---------------------------------------+--------------------|
| =\"=               | Quotation Mark                        | =\u{0022}=           |
| =\/=               | Solidus (Forward Slash)               | =\u{002F}=           |
| =\\=               | Reverse Solidus (Backslash)           | =\u{005C}=           |
| =\a=               | Bell                                  | =\u{0007}=           |
| =\b=               | Backspace                             | =\u{0008}=           |
| =\e=               | Escape                                | =\u{001B}=           |
| =\f=               | Form Feed (Page Break)                | =\u{000C}=           |
| =\n=               | Line Feed (New Line)                  | =\u{000A}=           |
| =\r=               | Carriage Return                       | =\u{000D}=           |
| =\t=               | Character Tabulation (Horizontal Tab) | =\u{0009}=           |
| =\v=               | Line Tabulation (Vertical Tab)        | =\u{000B}=           |

A /language-tagged string/ value in SDML is a string as above but immediately followed by a Commercial At ("@", =U+0040=)
character and an unquoted string of characters that conform to a language identifier. Note that both components of such
a string contribute to equality tests, so that ="abc"@en= is not equal to ="abc"@fr=.

#+NAME: lst:grammar-language-tag
#+BEGIN_SRC ebnf
LanguageTag
    ::= "@"
        LanguageTagPrimary
        LanguageTagExtended?
        LanguageTagScript?
        LanguageTagRegion?
#+END_SRC

[[./ebnf-diagram/LanguageTag.svg]]

The primary language is one of:

- a two letter language code from ISO 639-1,
- a three letter code from ISO 639-2.

#+BEGIN_SRC ebnf
LanguageTagPrimary
    ::= ASCII_LETTER_LOWER ASCII_LETTER_LOWER ASCII_LETTER_LOWER?
#+END_SRC

[[./ebnf-diagram/LanguageTagPrimary.svg]]

The extended language is zero to three selected three letter ISO 639-2 codes.

#+BEGIN_SRC ebnf
LanguageTagExtended
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_UPPER ASCII_LETTER_UPPER
#+END_SRC

[[./ebnf-diagram/LanguageTagExtended.svg]]

The language script is an ISO 15924 four letter code in title case.

#+BEGIN_SRC ebnf
LanguageTagScript
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_LOWER
        ASCII_LETTER_LOWER ASCII_LETTER_LOWER
#+END_SRC

[[./ebnf-diagram/LanguageTagScript.svg]]

The language region is either a two letter ISO 3166-1 code or a three digit UN M.49 code.

#+BEGIN_SRC ebnf
LanguageTagRegion
    ::= "-"
        ( ( ASCII_LETTER_UPPER ASCII_LETTER_UPPER )
          | ( ASCII_DIGIT ASCII_DIGIT ASCII_DIGIT ) )
#+END_SRC

[[./ebnf-diagram/LanguageTagRegion.svg]]

*IRI References*

An /IRI reference/ value in SDML is a value IRI value, either absolute or relative, between a Less-Than Sign ("<", =U+003C=)
character and a Greater-Than Sign (">", =U+003E=) character. IRI references are more permissive in the SDML grammar than
the Turtle[fn:iri] language.

#+NAME: lst:grammar-iri-reference
#+BEGIN_SRC ebnf
Iri
    ::= "<"
        ( [^<>\"{}|^`\#x00-#x20] | UnicodeEscape )*
        ">"
#+END_SRC

[[./ebnf-diagram/IriReference.svg]]

See section [[sec:mapping-values]] for a more detailed description of values, literals, and data types.

*Binary Strings*

A /binary/ value in SDML is a compact list of bytes that allows for the encoding of values that may not be possible with
the other built-in types. 

#+NAME: lst:grammar-binary
#+BEGIN_SRC ebnf
Binary
    ::= "#[" HexPair* "]"
#+END_SRC

#+CAPTION: Binary Value Example
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = #[
    52  32  39  76  5a  43  42  43    65  57  55  67  51  33  4a  31
    5a  57  77  67  56  32  39  79    62  47  51  4b
  ]

end
#+END_SRC

*** Value Constructors

While the value =101= is defined to be an Integer literal, in the presence of sub-types how do you specify the type of a
literal? To accomplish this a /value constructor/ allows for specifying the precise type, or casting a value to a specific
type.

The syntax appears as a function call with a type reference followed by a valid /simple value/ surrounded by the Left
Parenthesis ("(", =U+0028=) and Right Parenthesis (")", =U+0029=) characters. The literal value MUST be valid for the
referenced type, or one of it's super-types.

#+NAME: lst:grammar-value-constructor
#+BEGIN_SRC ebnf
ValueConstructor
    ::= IdentifierReference "(" SimpleValue ")"
#+END_SRC

[[./ebnf-diagram/ValueConstructor.svg]]

Here we assert that the value =1= is an unsigned rather than the default signed integer.

#+NAME: lst:sdml-ex-type-constructor
#+CAPTION: Value Constructor Example
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = xsd:unsigned(1)

end
#+END_SRC

You can ignore the syntax of ~@ex:thing~ which is an annotation, see section [[sec:annotations]], used to ensure the syntax is
complete for all examples.

*** <<sec:mapping-values>>Mapping Values

A mapping value denotes a /functional relationship/ between the /domain/ (left-hand value) and /range/ (right-hand value).  

#+NAME: lst:grammar-mapping-value
#+BEGIN_SRC ebnf
MappingValue
    ::= SimpleValue HasType Value
#+END_SRC

[[./ebnf-diagram/MappingValue.svg]]

Mapping values are most often used within lists to create dictionary-like structures.

#+NAME: lst:sdml-ex-mapping-list
#+CAPTION: Mapping List Example
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:dictionary = [
    "yes" -> 1
    "no" -> 2
    "maybe" -> 3
  ]

end
#+END_SRC
 
*** Sequence Values

As stated in section [[sec:modules-and-imports]], sequences in SDML start with the Left Square Bracket ("[", =U+005B=)
character and end with the Right Square Bracket ("]", =U+005D=) character with no separator character between members of
the list. Sequence values are, as one might expect, sequences of values and specifically of simple values. Sequence
value may also by heterogeneous and therefore contain elements of different types.

#+BEGIN_SRC js :noeval
SequenceOfValues
    ::= SequenceValueConstraint? "["
        ( SimpleValue | ValueConstructor | IdentifierReference )+
        "]"
SequenceValueConstraint
    ::= "{"
        ( SequenceOrdering? SequenceUniqueness? )
        "}"
#+END_SRC

[[./ebnf-diagram/SequenceOfValues.svg]]

[[./ebnf-diagram/SequenceValueConstraint.svg]]

*Example*

#+CAPTION: Sequence Value Example
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = [ "yes" "no" "maybe" ]

end
#+END_SRC

*Example*

#+CAPTION: Sequence Value Example
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = {unique}[ "yes" "no" "maybe" ]

end
#+END_SRC

*** Defining Data Types

A datatype definition introduces a new simple data type by /restriction/ of some existing base type.

#+NAME: lst:grammar-data-type-def
#+BEGIN_SRC ebnf
DataTypeDef
    ::= "datatype" Identifier "<-" DataTypeBase AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/DataTypeDef.svg]]

#+BEGIN_SRC ebnf
DataTypeBase
    ::= IdentifierReference | BuiltinSimpleType
#+END_SRC

[[./ebnf-diagram/DataTypeBase.svg]]

Listing [[lst:sdml-ex-datatype]] shows the /type restriction/ operator, =<-=, defining a new type named ~name~ as a restriction on
the existing XML Schema data type ~xsd:string~.

#+NAME: lst:sdml-ex-datatype
#+CAPTION: New Datatype
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  datatype Name <- string

end
#+END_SRC

While such a type is useful for conveying semantic meaning with types it doesn't provide any actual restriction on the
value space of the type. This is accomplished by using a subset of the /facets/ described in XML Schema part 2 to specify
constraints on the new type. For example, in listing [[lst:sdml-ex-restricted-datatype]] we now see that the Name type
is a string whose length is between 5 and 25 characters only.

#+NAME: lst:sdml-ex-restricted-datatype
#+CAPTION: New Datatype with Restrictions
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  datatype Name <- string is
    @xsd:minLength = 5
    @xsd:maxLength = 25
  end

end
#+END_SRC

From OWL 2 Web Ontology Language Quick Reference Guide[fn:owlqr]:

#+NAME: tbl:owl-facets
#+CAPTION: OWL Built-in Datatype Facets
| Facet                                                                  | Value                                      | Applicable Datatypes       | Explanation                                                                                |
|------------------------------------------------------------------------+--------------------------------------------+----------------------------+--------------------------------------------------------------------------------------------|
| =xsd:minInclusive=, =xsd:maxInclusive=, =xsd:minExclusive=, =xsd:maxExclusive= | literal in the corresponding datatype      | Numbers, Time Instants     | Restricts the value-space to greater than (equal to) or lesser than (equal to) a value     |
| =xsd:minLength=, =xsd:maxLength=, =xsd:length=                               | Non-negative integer                       | Strings, Binary Data, IRIs | Restricts the value-space based on the lengths of the literals                             |
| =xsd:pattern=                                                            | =xsd:string= literal as a regular expression | Strings, IRIs              | Restricts the value space to literals that match the regular expression                    |
| =rdf:langRange=                                                          | =xsd:string= literal as a regular expression | =rdf:PlainLiteral=           | Restricts the value space to literals with language tags that match the regular expression |

*** The Built-in Simple Types

In the preceding sections we introduced the set of built-in simple types: string, double, decimal, integer, boolean, and
iri. These are keywords in SDML and have specific rules applied when parsing. Each keyword is translated into a
qualified identifier where the module name is the reserved name =sdml=. This set of standard library types have an
underlying RDF/OWL equivalence relationship to a subset of the XML Schema datatypes, all shown in table
[[tbl:builtin-simple-types]].

#+NAME: lst:builtin-simple-types
#+BEGIN_SRC ebnf
BuiltinSimpleType
    ::= "string" | "double" | "decimal" | "integer" | "boolean" | "iri"
#+END_SRC

[[./ebnf-diagram/BuiltinSimpleType.svg]]

#+NAME: tbl:builtin-simple-types
#+CAPTION: Built-in Simple Type Mapping
| Type Keyword | Qualified Identifier | Equivalent XML Schema Datatype |
|--------------+----------------------+--------------------------------|
| ~boolean~      | ~sdml:boolean~         | ~xsd:boolean~                    |
| ~unsigned~     | ~sdml:unsigned~        | ~xsd:unsignedLong~               |
| ~integer~      | ~sdml:integer~         | ~xsd:long~                       |
| ~decimal~      | ~sdml:decimal~         | ~xsd:decimal~                    |
| ~double~       | ~sdml:double~          | ~xsd:double~                     |
| ~iri~          | ~sdml:iri~             | ~xsd:anyURI~                     |
| ~string~       | ~sdml:string~          | ~xsd:string~ or ~rdf:langString~   |
| ~binary~       | ~sdml:binary~          | ~xsd:hexBinary~                  |

Additionally, some types are defined in the ~sdml~ module, although they are not considered built-in types as they must be
referenced explicitly.

#+NAME: tbl:additional-simple-types
#+CAPTION: Additional Simple Types in SDML
| Qualified Identifier | Equivalent XML Schema Datatype |
|----------------------+--------------------------------|
| ~sdml:u8~              | ~xsd:unsignedByte~               |
| ~sdml:i8~              | ~xsd:byte~                       |
| ~sdml:u16~             | ~xsd:unsignedShort~              |
| ~sdml:i16~             | ~xsd:short~                      |
| ~sdml:u32~             | ~xsd:unsignedInt~                |
| ~sdml:i32~             | ~xsd:int~                        |
| ~sdml:u64~             | ~xsd:unsignedLong~               |
| ~sdml:i64~             | ~xsd:long~                       |

** <<sec:sequence-types>>Sequence Types

When a structure member has a cardinality other than ~1..1~ it has to be represented by a /sequence type/. SDML bases it's
sequence types on /cardinality constraints/ rather than the direct specification of a collection type. This allows you to
specify the semantic intent of a member rather than picking a type and then worrying about the mapping of that to a
programming language types.

The current SDML cardinality constraints are:

- Ordering :: determines whether the sequence maintains the order of it's elements; one of ~ordered~ or ~unordered~ (default).
- Uniqueness :: determines whether the sequence allows duplicate elements or not; one of ~ordered~ or ~nonunique~ (default).

Table [[tbl:builtin-sequence-types]] shows how these constraints are combined to determine the corresponding SDML sequence
type. See also section [[seq:library-sequence-types]] which describes the standard library operations on sequence types.

#+NAME: tbl:builtin-sequence-types
#+CAPTION: Logical Sequence Types
| Ordering  | Uniqueness | /Logical Type/  | Example Specification |
|-----------+------------+---------------+-----------------------|
| ~unordered~ | ~nonunique~  | ~Bag~ (default) | ~{0..}~                 |
| ~ordered~   | ~nonunique~  | ~List~          | ~{ordered 0..}~         |
| n/a       | n/a        | ~Maybe~         | ~{0..1}~                |
| ~ordered~   | ~unique~     | ~OrderedSet~    | ~{ordered unique 0..}~  |
| ~unordered~ | ~unique~     | ~Set~           | ~{unique 0..}~          |

Note, any ordering or uniqueness constraint on the cardinality ~0..1~ is effectively ignored.

A /dictionary/ or /map/ structure can be described in SDML as a sequence of mapping values (see section [[sec:mapping-values]]).
Specifically the sequence type ~{unique 0..} (string -> string)~ is mapping from string values to other strings where each mapping
is unique, and for mapping types only the keys are considered in comparisons. The type ~{0..} (string -> string)~ does not
enforce uniqueness and thus is a /multi-map/.

** <<sec:annotations>>Annotations

Annotations allow for the assertion of facts attached to model elements that go beyond what is possible to describe in
the core syntax. Annotations are available in two forms, annotation properties, and constraints.

#+NAME: lst:grammar-annotation
#+BEGIN_SRC ebnf
Annotation
    ::= AnnotationProperty | Constraint
#+END_SRC

[[./ebnf-diagram/Annotation.svg]]

A number of model elements described in the following sections have a body that may only contain annotations and so the
following common production is used.

#+NAME: lst:grammar-annotation-only-body
#+BEGIN_SRC ebnf
AnnotationOnlyBody
    ::= "is" Annotation+ "end"
#+END_SRC

[[./ebnf-diagram/AnnotationOnlyBody.svg]]

*** Annotation Properties

Annotation Properties are an extension mechanism that interacts directly with the underlying RDF representation of the subject
model element. While these may look like Java /annotations/, Python /decorators/, or Rust /attributes/ it is more powerful in
that it can express arbitrary statements about the model element. An SDML annotation starts with the symbol "@" and then
has an identifier that resolves to an OWL annotation property (see section [[sec:define-rdf]] for the detailed rules), and a
value for the corresponding property range.

#+NAME: lst:grammar-annotation-property
#+BEGIN_SRC ebnf
AnnotationProperty
    ::= "@" IdentiferReference "=" Value
#+END_SRC

[[./ebnf-diagram/AnnotationProperty.svg]]

*Example:*

The following example demonstrates a common annotation property attached to a module.

#+NAME: lst:sdml-ex-annotation-property
#+CAPTION: Annotation Property
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import skos

  @skos:note = "This is an example annotation"

end
#+END_SRC

For descriptive annotation properties it is valuable to use the language specific string format so allow for
localization of labels and descriptions. The following example shows a simple label specified in multiple languages.

*Example:*

#+NAME: lst:sdml-ex-annotation-property-list
#+CAPTION: Annotation Property List
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import skos

  @skos:prefLabel = [
    "example"@en
    "exemple"@fr
    "例子"@zh-CH
  ]

end
#+END_SRC

A model element may have any number of annotation properties, especially the module itself which often includes
annotations for the domain itself.

*Example:*

#+NAME: lst:sdml-ex-annotated-module
#+CAPTION: Annotated Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ dc skos xml ]

  @skos:prefLabel = "Example Module"@en
  @dc:description = "This is an example module, with two annotations."@en
  @dc:created = @xsd:date("2023-08-17 Thu")
  @dc:creator = <http://github.com/johnstonskj>
  @dc:license = <https://opensource.org/license/mit/>

end
#+END_SRC

From [[https://www.w3.org/TR/owl-ref/#AnnotationProperty-def][OWL Web Ontology Language Reference]], Appendix E: Rules of Thumb for OWL DL ontologies:

#+BEGIN_QUOTE
If a property =a= is used where an annotation property is expected then it should either be one of the built in
annotation properties (=owl:versionInfo=, =rdfs:label=, =rdfs:comment=, =rdfs:seeAlso=, and =rdfs:isDefinedBy=) or there
should be a triple:

=a rdf:type owl:AnnotationProperty=
#+END_QUOTE

*** Constraints

This section will only briefly introduce constraints as section [[sec:model-constraints]] provides a detailed description.
The first example, in listing [[lst:sdml-ex-constrained-module]], provides an informal constraint in that it is simply a
string which is useful to readers but cannot be verified.

#+NAME: lst:sdml-ex-constrained-module
#+CAPTION: Informal Constraint on Module
#+BEGIN_SRC sdml :exports code :noeval
module rental is

  assert name_form = "All definition names MUST start with 'Rental'"

end
#+END_SRC

While informal constraints are not validated in any way, given the ambiguities of human language a controlled language
is a useful alternative.

A formal constraint on the other hand may be verified, but takes more work to structure correctly. The example in
listing [[lst:sdml-ex-formal-constrained-module]] example above by methodically checking every definition and any members
therein.

#+NAME: lst:sdml-ex-formal-constrained-module
#+CAPTION: Formal Constraint on Module
#+BEGIN_SRC sdml :exports code :noeval
module rental is

  assert name_form is
    forall d in definitions(self) ( suffix(name(d) "Rental") )
  end

end
#+END_SRC

*** <<sec:define-rdf>> Defining RDF Classes and Properties

In general only properties that have an RDF type of =owl:AnnotationProperty=, or are sub-properties of such a property,
may appear as annotations. This maintains the assertion that they are annotations of their subject and allows the use of
a range of pre-defined annotation properties from RDF, RDF Schema, OWL, and the Dublin Core Metadata Initiative
(DCMI)[fn:dcmi].

For example the annotation property =rdfs:comment= is defined in the following manner allowing it's use on any resource
and with a value that may be any literal.

#+NAME: lst:rdfs-comment
#+CAPTION: The definition of rdfs:comment
#+BEGIN_SRC ttl
rdfs:comment rdf:type rdf:Property, owl:AnnotationProperty ;
	rdfs:isDefinedBy <http://www.w3.org/2000/01/rdf-schema#> ;
	rdfs:label "comment" ;
	rdfs:comment "A description of the subject resource." ;
	rdfs:domain rdfs:Resource ;
	rdfs:range rdfs:Literal .
#+END_SRC

To allow the standard library to define SDML equivalents of such properties it is necessary to provide a mechanism to
use non-annotation properties such as =rdf:type=, =rdfs:domain=, and =rdfs:range= as demonstrated in the example above. To
allow this, if a model element has the property =rdf:type= then the transformation from that element to RDF *does not* use
any of the transformations described here but an explicit mapping from *only* the provided properties.

Rewriting the RDF from listing [[lst:rdfs-comment]] into SDML results in the definition in listing [[lst:rdfs-comment-in-sdml]].

#+NAME: lst:rdfs-comment-in-sdml
#+CAPTION: The SDML definition of rdfs:comment
#+BEGIN_SRC sdml :exports code :noeval
module rdfs is

  ;; a lot of things elided.

  structure comment is
    @rdf:type = [ rdf:Property owl:AnnotationProperty ]
    @isDefinedBy = <http://www.w3.org/2000/01/rdf-schema#>
    @label = "comment"
    @comment = "A description of the subject resource."
    @domain = Resource
    @range = Literal
  end

end
#+END_SRC

The following are commonly used RDF and OWL definition properties.

- =rdf:type= --
- =rdfs:domain= and =rdfs:range= --
- =rdfs:subClassOf= and =rdfs:subPropertyOf= --
- =owl:equivalentClass= and =owl:equivalentProperty= --
- =owl:inverseOf= --
- =owl:disjointWith= --
- =owl:FunctionalProperty=, =owl:InverseFunctionalProperty=, =owl:SymmetricProperty= and =owl:TransitiveProperty= --

** <<sec:structured-types>>Structured Types

Structured types fall into two primary categories, /Product/ types and /Sum/ types. Product types have named and typed
/Members/ and in SDML these are structures, entities and events. Sum types on the other hand have /Variants/ and in SDML
these are enumerations and disjoint unions. In the surface syntax product type bodies are introduced by the keyword ~is~
whereas sum type bodies are introduced by the keyword ~of~.

*** <<sec:members>>Members

Product type members fall into the following categories.

- Identity :: A particular kind of member only available on entities, and required by them, to name the identifier for
  that entity type.
- By-Value :: A reference to a value type, i.e. Enumeration, Event, or Structure. Such a member may indicate the
  cardinality of the target.
- By-Reference :: A reference to an Entity type. Such a member may indicate the cardinality of the
  target as well as the name of the inverse member on the target type.

#+NAME: lst:grammar-identity-member
#+BEGIN_SRC ebnf
IdentityMember
    ::= "identity" Identifier
        ( PropertyMember | ( TypeExpression AnnotationOnlyBody? ) )
#+END_SRC

[[./ebnf-diagram/IdentityMember.svg]]

#+NAME: lst:grammar-value-member
#+BEGIN_SRC ebnf
MemberByValue
    ::= Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )
#+END_SRC

[[./ebnf-diagram/MemberByValue.svg]]

#+NAME: lst:grammar-reference-member
#+BEGIN_SRC ebnf
MemberByReference
    ::= "ref" Identifier
        ( PropertyMember | ( InverseName? TypeExpressionTo AnnotationOnlyBody? ) )
#+END_SRC

[[./ebnf-diagram/MemberByReference.svg]]

#+NAME: lst:grammar-reference-inverse
#+BEGIN_SRC ebnf
InverseName
    ::= "(" Identifier ")"
#+END_SRC

[[./ebnf-diagram/InverseName.svg]]

#+NAME: lst:grammar-property-member
#+BEGIN_SRC ebnf
PropertyMember
    ::= "in" IdentifierReference
#+END_SRC

[[./ebnf-diagram/PropertyMember.svg]]

In the following example we see two members, ~default~ and ~name~. The former is actually a reference to a property role,
specifically the role ~default~ within the property definition ~AccountId~ in module ~account~. The latter is a /defined/ member
with the name ~name~ and the type ~string~ and default cardinality.

*Example*:

#+NAME: lst:sdml-ex-members
#+CAPTION: Members in a Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import account

  structure Account is
    default in account:AccountId
    name -> string
  end

end
#+END_SRC

*Member Types*

For identity, by-value, and by-reference members the general syntax uses the /type reference/ operator, /name/ ~->~ /type/, with
additional keywords and cardinality included as follows.

#+NAME: tbl:member-summary
#+CAPTION: Summary of Member Formats
| Kind         | Keyword  | To-Cardinality | Target Types                            |
|--------------+----------+----------------+-----------------------------------------|
| Identity     | ~identity~ | No             | Enumeration, Event, Structure, or Union |
| By-Value     |          | Yes            | Enumeration, Event, Structure, or Union |
| By-Reference | ~ref~      | Yes            | Entity                                  |

Additionally, to allow for the capture of member names before the elaboration of all types the language allows for the
target type to be replaced with the keyword ~unknown~. This marks the member, and by extension it's owning type, as
/incomplete/. Note the grammar allows ASCII and Unicode representations of the /has type/ operator.

#+NAME: lst:grammar-type-expressions
#+BEGIN_SRC ebnf
TypeExpression 
    ::= HasType TypeReference
TypeExpressionTo
    ::= HasType Cardinality? TypeReference
HasType
    ::= "->" | "→" | "↦"
TypeReference
    ::=  UnknownType | IdentifierReference | BuiltinSimpleType | MappingType
UnknownType
    ::= "unknown"
#+END_SRC

[[./ebnf-diagram/TypeExpression.svg]]

[[./ebnf-diagram/TypeExpressionTo.svg]]

[[./ebnf-diagram/TypeReference.svg]]

A mapping type denotes a /functional relationship/ between the /domain/ (left-hand type) and /range/ (right-hand type).

#+BEGIN_SRC ebnf
MappingType
    ::= "(" TypeReference HasType TypeReference ")"
#+END_SRC

[[./ebnf-diagram/MappingType.svg]]

The syntax for mapping values is described in section [[sec:mapping-values]].

*Member Cardinality*

The *cardinality* of a member is specified as a range operation with a minimum and maximum number of occurrences
specified. Additionally cardinality constraints determine the ordering and uniqueness of the collection of member values
in a sequence type (see section [[sec:sequence-types]]).

- The form ~{1..3}~ specifies a cardinality of 1 to 3 inclusive, or $[1,3]$ in interval notation.
- The form ~{1..}~ specifies a minimum of 1 occurrences an unbounded maximum, or $[1,\infty]$ in interval notation.
- The form ~{1}~ specifies that 1 is both the minimum and maximum value, or $[1,1]$ in interval notation, commonly termed
  a /degenerate/ interval.

#+NAME: lst:grammar-cardinality
#+BEGIN_SRC ebnf
Cardinality
    ::= "{" SequenceOrdering? SequenceUniqueness? CardinalityInner "}"
CardinalityInner
    ::= Unsigned CardinalityRange?
CardinalityRange
    ::= ".." Unsigned?
#+END_SRC

[[./ebnf-diagram/Cardinality.svg]]

[[./ebnf-diagram/CardinalityInner.svg]]

[[./ebnf-diagram/CardinalityRange.svg]]

#+BEGIN_SRC ebnf
SequenceOrdering
    ::= ( "ordered" | "unordered" )
SequenceUniqueness
    ::= ( "unique" | "nonunique" )
#+END_SRC

[[./ebnf-diagram/SequenceOrdering.svg]]

[[./ebnf-diagram/SequenceUniqueness.svg]]

*** Variants

Sum type variants fall into the following categories.

- Value Variant :: A member within an enumeration that specifies a numeric value for each member rather than a type.
- *Type Variant* :: A type reference that is a unique variant of a disjoint union.

The details of the two variant types are in the sections on /enumerations/ and /disjoint unions/ following.

*** Structures

A structure is a product type that is composed of named and typed members. A structure is therefore akin to a record
type, a table in data modeling, or a class in object modeling.

#+NAME: lst:grammar-structure-def
#+BEGIN_SRC ebnf
StructureDef
    ::= "structure" Identifier StructureBody?
#+END_SRC

[[./ebnf-diagram/StructureDef.svg]]

*Example*:

As only the keyword ~structure~ and the identifier are required, the listing [[lst:sdml-ex-empty-structure]] is therefore a
valid model.

#+NAME: lst:sdml-ex-empty-structure
#+CAPTION: Empty Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length

end
#+END_SRC

The structure ~Length~ in listing [[lst:sdml-ex-empty-structure]] is /valid/ but considered incomplete. Adding a body to the
structure, between ~is~ and ~end~, makes it complete even if it has no actual members. In listing
[[lst:sdml-ex-annotated-structure]] the structure Length is now complete.


#+NAME: lst:grammar-structure-body
#+BEGIN_SRC ebnf
StructureBody
    ::= "is" Annotation* ( MemberByValue | StructureGroup )* "end"
#+END_SRC

[[./ebnf-diagram/StructureBody.svg]]

*Example*:

#+NAME: lst:sdml-ex-annotated-structure
#+CAPTION: Annotated Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length is
    @skos:prefLabel = "Length"@en
  end

end
#+END_SRC

*Example*:

Listing [[lst:sdml-ex-structure-members]] adds the members ~value~ and ~unit~ and their corresponding types.

#+NAME: lst:sdml-ex-structure-members
#+CAPTION: Structure Members
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length is
    @skos:prefLabel = "Length"@en

    value -> Decimal
    unit -> DistanceUnit
  end

end
#+END_SRC

In listing [[lst:sdml-ex-structure-groups]] we see a more complex structure with both members and groups.

#+NAME: lst:grammar-structure-group
#+BEGIN_SRC ebnf
StructureGroup
    ::= "group" Annotation* MemberByValue+ "end"
#+END_SRC

[[./ebnf-diagram/StructureGroup.svg]]

*Example*:

#+NAME: lst:sdml-ex-structure-groups
#+CAPTION: Structure Members and Groups
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Account is
  
    @skos:prefLabel = "Customer Account"@en

    group
      @skos:prefLabel = "Metadata"
      created -> xsd:dateTime
      lastModified -> xsd:dateTime
    end

    group
      @skos:prefLabel = "Customer Information"
      ref customer -> {1..1} Customer
    end
  
  end

end
#+END_SRC

*** Entities

#+NAME: lst:grammar-entity-def
#+BEGIN_SRC ebnf
EntityDef
    ::= "entity" Identifier EntityBody?

#+END_SRC

[[./ebnf-diagram/EntityDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-entity
#+CAPTION: Empty Entity
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person

end
#+END_SRC

The entity ~Person~ in listing [[lst:sdml-ex-empty-entity]] is /valid/ but /incomplete/.

#+BEGIN_SRC ebnf
EntityBody
    ::= "is"
        Annotation* IdentityMember ( EntityMember | EntityGroup )*
        "end"
#+END_SRC

[[./ebnf-diagram/EntityBody.svg]]

#+BEGIN_SRC ebnf
EntityGroup
    ::= "group" Annotation* EntityMember+ "end"
#+END_SRC

[[./ebnf-diagram/EntityGroup.svg]]

#+BEGIN_SRC ebnf
EntityMember
    ::= MemberByValue | MemberByReference
#+END_SRC

[[./ebnf-diagram/EntityMember.svg]]

*Example*:

#+NAME: lst:sdml-ex-entity-identifying-member
#+CAPTION: Entity with Identifying Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person is
    identity id -> PersonId
  end

end
#+END_SRC

The ~identity~ member is a required part of the entity definition, it not only tells us what type represents the unique
identifier for this entity but is also used in ~ref~ members and event sources (see section [[sec:entity-events]]). In the
case of a ~ref~ member the target entity, in our example =Person= is not included in the entity's structure, it's identifier
type, =PersonId= is instead.

#+NAME: lst:sdml-ex-entity-ref-member
#+CAPTION: Entity with Reference Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person is
  
    identity id -> PersonId

    ref emergency_contact (emergency_contact_for) -> {0..2} Person is
      @dc:description = "Emergency contact person"
    end
  
  end
end
#+END_SRC

*** <<sec:entity-events>>Entity Events

Entity Events, or simply Events, model notifications generated by an entity most often representing a state change in the entity.
As such a ~source~ reference denotes the entity which generates this event. Any expansion of the event structure *must* include the
identifiers of the source entity.

#+NAME: lst:grammar-event-def
#+BEGIN_SRC ebnf
EventDef
    ::= "event" Identifier
        "source" IdentifierReference
        StructureBody?
#+END_SRC

[[./ebnf-diagram/EventDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-event
#+CAPTION: Empty Event
#+BEGIN_SRC sdml :exports code :noeval
module example is

  event PersonNameChanged source Person

end
#+END_SRC

With the expansion of the ~source~ entity the event definition above is logically equivalent to the following structure.

#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure PersonNameChanged is
    id -> PersonId is
      @sdml:identifies = Person
    end
  end

end
#+END_SRC

As we have seen before, the event ~PersonNameChanged~ in listing [[lst:sdml-ex-empty-event]] is valid but incomplete.

*Example*:

The following is a valid /and/ complete event definition with two structure members.

#+NAME: lst:sdml-ex-event
#+CAPTION: Event
#+BEGIN_SRC sdml :exports code :noeval
module example is

  event PersonNameChanged source Person is
    fromValue -> Name
    toValue -> Name
  end

end
#+END_SRC

*** Enumerations

An enumeration is a numeric type that expressly names the values it may take. This is a restricted form of the =enum= type
found in most languages as not only *must* all names be unique but all names *must* specify a value *and* all values *must* also
be unique. Note also that the keyword =of= and not =is= starts an enumeration body.

#+NAME: lst:grammar-enum-def
#+BEGIN_SRC ebnf
EnumDef
    ::= "enum" Identifier EnumBody?
#+END_SRC

[[./ebnf-diagram/EnumDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-enum
#+CAPTION: Empty Enum
#+BEGIN_SRC sdml :exports code :noeval
module example is

  enum DistanceUnit

end
#+END_SRC

The enumeration ~DistanceUnit~ in [[lst:sdml-ex-empty-enum]] is valid but incomplete. Completion of the enumeration requires
the addition of a body with enumeration variants.

#+BEGIN_SRC ebnf
EnumBody
    ::= "of" Annotation* ValueVariant+ "end"
#+END_SRC

[[./ebnf-diagram/EnumBody.svg]]

#+NAME: lst:grammar-enum-variant
#+BEGIN_SRC ebnf
ValueVariant
    ::= Identifier "=" Unsigned AnnotationOnlyBody?
#+END_SRC
[[./ebnf-diagram/ValueVariant.svg]]

*Example*:

The following demonstrates a valid /and/ complete enumeration.

#+NAME: lst:sdml-ex-enum
#+CAPTION: Enum With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is

  enum DistanceUnit of
    Meter = 1
    Foot = 2
  end

end
#+END_SRC

*** Disjoint Unions

A disjoint, or discriminated, union is a mechanism to allow for a selection of disjoint types to be treated as a single
type. As such the /variants/ of the union are simply type references, although they do allow annotations. Note also that
the keyword =of= and not =is= starts a union body.

#+NAME: lst:grammar-union-def
#+BEGIN_SRC ebnf
UnionDef
    ::= "union" Identifier UnionBody?
#+END_SRC

[[./ebnf-diagram/UnionDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-union
#+CAPTION: Empty Union
#+BEGIN_SRC sdml :exports code :noeval
module example is

  union VehicleClass

end
#+END_SRC

The union ~VehicleClass~ in [[lst:sdml-ex-empty-union]] is valid but incomplete. Completion of the union requires the addition
of a body with type variants.

#+BEGIN_SRC ebnf
UnionBody
    ::= "of"
        Annotation* TypeVariant+
        "end"
#+END_SRC

[[./ebnf-diagram/UnionBody.svg]]

#+NAME: lst:grammar-type-variant
#+BEGIN_SRC ebnf
TypeVariant
    ::= IdentifierReference TypeVariantRename? AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/TypeVariant.svg]]

#+BEGIN_SRC ebnf
TypeVariantRename
    ::= "as" Identifier
#+END_SRC

[[./ebnf-diagram/TypeVariantRename.svg]]

*Example*:

The following is a valid /and/ complete example with three type variants and one that is renamed from =Van= to =LittleTruck=.

#+NAME: lst:sdml-ex-union
#+CAPTION: Union With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is

  union VehicleClass of
    Car
    Truck
    Van as LittleTruck
  end

end
#+END_SRC

** <<sec:properties>>Property Definitions

SDML provides for a data dictionary, or element-first, style of model capture where key properties of the domain are
defined and annotated in a stand-alone form. These are often key identifiers and other shared properties 

#+NAME: lst:grammar-property-def
#+BEGIN_SRC ebnf
PropertyDef
    ::= "property" Identifier PropertyBody?
#+END_SRC

[[./ebnf-diagram/PropertyDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-property
#+CAPTION: Empty Property Definition
#+BEGIN_SRC sdml :exports code :noeval
module example is

  property account_id

end
#+END_SRC

The property ~account_id~ in [[lst:sdml-ex-empty-property]] is valid but incomplete. Completion of the property requires the
addition of a body with roles defined.

#+NAME: lst:grammar-property-body
#+BEGIN_SRC ebnf
PropertyBody
    ::= "is" Annotation* PropertyRole+ "end"
PropertyRole
    ::= IdentityRole | RoleByValue | RoleByReference
#+END_SRC

[[./ebnf-diagram/PropertyBody.svg]]

[[./ebnf-diagram/PropertyRole.svg]]

Note that the syntax of role definitions is a subset of the syntax for members (see section [[sec:members]]). In each case
the choice between a property reference and a member definition is removed and only the definition part remains.

#+BEGIN_SRC ebnf
IdentityRole
    ::= "identity" Identifier TypeExpression AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/IdentityRole.svg]]

#+BEGIN_SRC ebnf
RoleByValue
    ::= Identifier TypeExpressionTo AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/RoleByValue.svg]]

#+BEGIN_SRC ebnf
RoleByReference
    ::= "ref" Identifier InverseName? TypeExpressionTo AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/RoleByReference.svg]]

*Example*:

The following is a valid /and/ complete example.

#+NAME: lst:sdml-ex-property-role
#+CAPTION: Property Definition with Roles
#+BEGIN_SRC sdml :exports code :noeval
module example is

  property accountId is

    identity identifier -> {1} account:AccountId is
      @skos:definition =
        "The identifier that denotes that this entity has a one-to-one relationship with a customer account."@en
    end

    ref reference -> {1} account:AccountId is
      @skos:definition =
        "Refers to an entity that has a one-to-one relationship with a customer account."@en
    end

  end

end
#+END_SRC

** <<sec:feature-grammar>>Feature Sets

#+NAME: lst:grammar-property-def
#+BEGIN_SRC ebnf
FeatureSetDef
    ::= "features" Identifier
        (
            FeatureSetConjunctiveBody
          | FeatureSetDisjunctiveBody
          | FeatureSetExclusiveDisjunctionBody
        )?
#+END_SRC

[[./ebnf-diagram/PropertyDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-featureset
#+CAPTION: Empty Feature Set Definition
#+BEGIN_SRC sdml :exports code :noeval
module example is

  features AccountFeatures

end
#+END_SRC

The feature set ~AccountFeatures~ in [[lst:sdml-ex-empty-featureset]] is valid but incomplete. Completion of the feature set
requires the addition of a body with members/variants defined.

*** Exclusive Disjunction Features

#+BEGIN_SRC ebnf
FeatureSetExclusiveDisjunctionBody
    ::= ( "{" "xor" "}" )?
        "of"
        Annotation* TypeVariant+
#+END_SRC

[[./ebnf-diagram/FeatureSetExclusiveDisjunctionBody.svg]]

*Example*:

#+NAME: lst:sdml-ex-xor-featureset
#+CAPTION: Exclusive Disjunction Feature Set
#+BEGIN_SRC sdml :exports code :noeval
module example is

  features AccountKind {xor} of
    PersonalAccount as Personal
    CorporateAccount as Business
  end

end
#+END_SRC

*** Disjunctive Features

#+BEGIN_SRC ebnf
FeatureSetDisjunctiveBody
    ::= "{" "or" "}" "of"
        Annotation* TypeVariant+
#+END_SRC

[[./ebnf-diagram/FeatureSetDisjunctiveBody.svg]]

*Example*:
#+NAME: lst:sdml-ex-or-featureset
#+CAPTION: Disjunctive Feature Set
#+BEGIN_SRC sdml :exports code :noeval
module example is

  features AccountUpgrades {or} is
    SkipCheckin
    AutoUpgrade
  end

end
#+END_SRC

*** Conjunctive Features

#+BEGIN_SRC ebnf
FeatureSetConjunctiveBody
    ::= "{" "and" "}" "is"
        Annotation* RoleByValue+
#+END_SRC

[[./ebnf-diagram/FeatureSetConjunctiveBody.svg]]

*Example*:

#+NAME: lst:sdml-ex-and-featureset
#+CAPTION: Conjunctive Feature Set
#+BEGIN_SRC sdml :exports code :noeval
module example is

  features AccountFeatures {and} is
    kind -> AccountKind
    upgrades -> AccountUpgrades
  end

end
#+END_SRC

** Common Questions

*** Why are Enumerations and Unions distinct

TBD

*** How to model Polymorphism

The term /polymorphism/ is, in itself, polymorphic; the intent in software to create a structure that may be of more than
one /type/ is useful enough that it has been invented a number of times.

#+BEGIN_QUOTE
/In programming language theory and type theory, polymorphism is the provision of a single interface to entities of
different types or the use of a single symbol to represent multiple different types./
--- /Wikipedia/[fn::https://en.wikipedia.org/wiki/Polymorphism_(computer_science)]
#+END_QUOTE

1. Pointers, and especially the C ~void*~
2. Operator overloading or dispatching, including methods and multi-methods
3. Discriminated Unions, also known as disjoint unions, variant records (Pascal family), tagged types (Ada)
4. Inheritance, of both interface and implementation
5. Interface, or protocol, implementation

As SDML does not support pointers, inheritance, or interface definitions, polymorphism is provided *only* via union types.

*** When to use Property Definitions

#+CAPTION: Union Type Definition
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ skos xsd ]

  datatype AccountId <- xsd:long

  datatype ExternalAccountId <- uri

  structure ChildAccountId is
    parent -> AccountId
    child -> AccountId
  end

  union AllAccountIds of
    AccountId,
    ExternalAccountId,
    ChildAccountId
  end

end
#+END_SRC

#+CAPTION: Union Type As Property
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ skos xsd ]

  property account_id is
  
  internal -> {1} xsd:long is
    @skos:definition = "This is our internal representation."@en
  end
  
  external -> {1} url is
    @skos:definition = "This is our external representation for customers."@en
  end
  
  child -> {2} xsd:long
  end

  entity Account is

    identity account_id as internal

  end

end
#+END_SRC

*** How to model Variability

Discuss role of unions in modeling variability

** <<sec:complete-grammar>>Complete Surface Syntax Grammar

The grammar of the surface syntax is presented in Extended Backus–Naur form (EBNF)[fn:ebnf]. The addition of a character literal
range operation =..= reduces the number of single character alternatives for clarity. There are also a set of pre-defined
terminals such as =ASCII_DIGIT=, =ASCII_HEX_DIGIT=, =UC_LETTER_UPPER=, and =UC_LETTER_LOWER= used to simplify character ranges.
While there are many variations[fn:ebnfs] of EBNF in existence, including multiple standardized forms, the specific form
used here follows the notation described the W3C Extensible Markup Language (XML) 1.0 (Fifth Edition), section 6
[[https://www.w3.org/TR/xml/#sec-notation][Notation]].

#+BEGIN_SRC ebnf
Module
    ::= "module" Identifier ModuleBase? ModuleBody

ModuleBase
    ::= "base" IriReference

ModuleBody
    ::= "is"
        ImportStatement* Annotation* Definition*
        "end"

MemberImport
    ::= QualifiedIdentifier

ModuleImport
    ::= Identifer

Import
    ::= MemberImport | ModuleImport

ImportStatement
    ::= "import" ( Import | "[" Import+ "]" )

Annotation
    ::= AnnotationProperty | Constraint

AnnotationProperty
    ::= "@" IdentiferReference "=" Value

Definition
    ::= DataTypeDef
        | EntityDef
        | EnumDef
        | EvqentDef
        | StructureDef
        | UnionDef
        | PropertyDef
        | FeatureSetDef

DataTypeDef
    ::= "datatype" Identifier TypeRestriction DataTypeBase AnnotationOnlyBody?

TypeRestriction
    ::= "<-" | "←"

DataTypeBase
    ::= IdentifierReference | BuiltinSimpleType

AnnotationOnlyBody
    ::= "is" Annotation+ "end"

EntityDef
    ::= "entity" Identifier EntityBody?

EntityBody
    ::= "is"
        Annotation* IdentityMember ( EntityMember | EntityGroup )*
        "end"

EntityGroup
    ::= "group" Annotation* EntityMember+ "end"

EntityMember
    ::= MemberByValue | MemberByReference

EnumDef
    ::= "enum" Identifier EnumBody?

EnumBody
    ::= "of" Annotation* ValueVariant+ "end"

ValueVariant
    ::= Identifier "=" Unsigned AnnotationOnlyBody?

EventDef
    ::= "event" Identifier
        "source" IdentifierReference
        StructureBody?

StructureDef
    ::= "structure" Identifier StructureBody?

StructureBody
    ::= "is" Annotation* ( MemberByValue | StructureGroup )* "end"

StructureGroup
    ::= "group" Annotation* MemberByValue+ "end"

UnionDef
    ::= "union" Identifier UnionBody?

UnionBody
    ::= "of"
        Annotation* TypeVariant+
        "end"

TypeVariant
    ::= IdentifierReference TypeVariantRename? AnnotationOnlyBody?

TypeVariantRename
    ::= "as" Identifier

PropertyDef
    ::= "property" Identifier PropertyBody?

PropertyBody
    ::= "is" Annotation* PropertyRole+ "end"

PropertyRole
    ::= IdentityRole | RoleByValue | RoleByReference

IdentityRole
    ::= "identity" Identifier TypeExpression AnnotationOnlyBody?

RoleByValue
    ::= Identifier TypeExpressionTo AnnotationOnlyBody?

RoleByReference
    ::= "ref" Identifier InverseName? TypeExpressionTo AnnotationOnlyBody?

FeatureSetDef
    ::= "features" Identifier
        (
            FeatureSetConjunctiveBody
          | FeatureSetDisjunctiveBody
          | FeatureSetExclusiveDisjunctionBody
        )?

FeatureSetConjunctiveBody
    ::= "{" "and" "}" "is"
        Annotation* RoleByValue+

FeatureSetDisjunctiveBody
    ::= "{" "or" "}" "is"
        Annotation* TypeVariant+

FeatureSetExclusiveDisjunctionBody
    ::= ( "{" "xor" "}" )?
        "is"
        Annotation* TypeVariant+

PropertyMember
    ::= "in" IdentifierReference

IdentityMember
    ::= "identity" Identifier
        ( PropertyMember | ( TypeExpression AnnotationOnlyBody? ) )

MemberByValue
    ::= Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )

MemberByReference
    ::= "ref" Identifier
        ( PropertyMember | ( InverseName? TypeExpressionTo AnnotationOnlyBody? ) )

TypeExpression
    ::= HasType TypeReference

TypeExpressionTo
    ::= HasType Cardinality? TypeReference

HasType
    ::= "->" | "→" | "↦"

TypeReference
    ::=  UnknownType | IdentifierReference | BuiltinSimpleType | MappingType

UnknownType
    ::= "unknown"

MappingType
    ::= "(" TypeReference HasType TypeReference ")"

Cardinality
    ::= "{" SequenceOrdering? SequenceUniqueness? CardinalityInner "}"

CardinalityInner
    ::= Unsigned CardinalityRange?

CardinalityRange
    ::= ".." Unsigned?

SequenceOrdering
    ::= ( "ordered" | "unordered" )

SequenceUniqueness
    ::= ( "unique" | "nonunique" )

InverseName
    ::= "(" Identifier ")"

Value
    ::=  SimpleValue
        | ValueConstructor
        | IdentifierReference
        | MappingValue
        | SequenceOfValues

BuiltinSimpleType
    ::= "string" | "double" | "decimal" | "integer" | "boolean" | "iri"

SimpleValue
    ::= String | Double | Decimal | Integer | Boolean | IriReference

Boolean
    ::= Tautology | Contradiction

Tautology
    ::= ( "true" | "⊤" )

Contradiction
    ::= ( "false" | "⊥" )

NumericSign
    ::= [+-]

Zero
    ::= [0]

NonZero
    ::= [1-9]

Unsigned
    ::= Zero | NonZero ASCII_DIGIT*

Integer
    ::= NumericSign? Unsigned

Decimal
    ::= Integer "." ASCII_DIGIT+

ExponentChar
    ::= [eE]

Double
    ::= Decimal ExponentChar NumericSign? Integer

HexPair
    ::= ASCII_HEX_DIGIT ASCII_HEX_DIGIT

Escape
    ::= "\\" ( CharacterEscape | UnicodeEscape )

CharacterEscape
    ::= [\"\\/abefnrtv]

UnicodeEscape
    ::= "u{" HexPair ( HexPair ( HexPair )? )? "}"

NotAllowed
    ::= [^\"\#x00-#x08#x0B-#x1F#x7F]

QuotedString
    ::= '"' ( Escape | NotAllowed )* '"'

LanguageTag
    ::= "@"
        LanguageTagPrimary
        LanguageTagExtended?
        LanguageTagScript?
        LanguageTagRegion?

LanguageTagPrimary
    ::= ASCII_LETTER_LOWER ASCII_LETTER_LOWER ASCII_LETTER_LOWER?

LanguageTagExtended
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_UPPER ASCII_LETTER_UPPER

LanguageTagScript
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_LOWER
        ASCII_LETTER_LOWER ASCII_LETTER_LOWER

LanguageTagRegion
    ::= "-"
        ( ( ASCII_LETTER_UPPER ASCII_LETTER_UPPER )
          | ( ASCII_DIGIT ASCII_DIGIT ASCII_DIGIT ) )

String
    ::= QuotedString LanguageTag?

IriReference
    ::=
    "<"
    ( [^<>\"{}|^`\#x00-#x20] | UnicodeEscape )*
    ">"

ValueConstructor
    ::= IdentifierReference "(" SimpleValue ")"

MappingValue
    ::= SimpleValue HasType Value

SequenceOfValues
    ::= SequenceValueConstraint? "["
        ( SimpleValue | ValueConstructor | IdentifierReference )+
        "]"

SequenceValueConstraint
    ::= "{"
        ( SequenceOrdering? SequenceUniqueness? )
        "}"

IdentifierInitial
    ::= UC_LETTER_UPPER | UC_LETTER_LOWER

IdentifierChar
    ::= IdentifierInitial | UC_NUMBER_DECIMAL

Identifier
    ::= IdentifierInitial IdentifierChar* ( "_" IdentifierChar+ )*

QualifiedIdentifier
    ::= Identifier ":" Identifier

IdentifierReference
    ::= QualifiedIdentifier | Identifier

LineComment
    ::= ";" [^\r\n]*

Whitespace
    ::= [^\f\n\r\t\v#x20#xa0#x1680#x2000#x200a#x2028#x2029#x202f#x205f#x3000#xfeff]
#+END_SRC

*** The Embedded Constraint Language

Given that the /formal/ constraint language component of SDML is likely to be used less frequently *and* the grammar is
fairly long we have made it a separate section.

#+BEGIN_SRC ebnf
Constraint
    ::= "assert" Identifier ( InformalConstraint | FormalConstraint )

InformalConstraint
    ::= "=" QuotedString ControlledLanguageTag?

ControlledLanguageTag
    ::= "@" LanguageTagPrimary ControlledLanguageScheme?

ControlledLanguageScheme
    ::= "-"
        ASCII_LETTER  ASCII_LETTER  ASCII_LETTER
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?

FormalConstraint
    ::= "is"
        ConstraintEnvironment? ConstraintSentence
        "end"

ConstraintSentence
    ::= SimpleSentence
        | BooleanSentence
        | QuantifiedSentence
        | "(" ConstraintSentence ")"

SimpleSentence
    ::= Atomic | Equation | Inequation

Atomic
    ::= Term "(" Term* ")"

Equation
    ::= Term "=" Term

Inequation
    ::= Term InequationRelation Term

InequationRelation
    ::= ( '/=' | '≠' | '<' | '>' | '<=' | '≤' | '>=' | '≥' )

BooleanSentence
    ::= Negation
        | ConstraintSentence
          (
            Conjunction | Disjunction | ExclusiveDisjunction |
            Implication | Biconditional
          )

Negation
    ::= ( "not" | "¬" ) ConstraintSentence

Conjunction
    ::= ( "and" | "∧" ) ConstraintSentence

Disjunction
    ::= ( "or" | "∨" ) ConstraintSentence

ExclusiveDisjunction
    ::= ( "xor" | "⊻" ) ConstraintSentence

Implication
    ::= ( "implies" | "⇒" ) ConstraintSentence

Biconditional
    ::= ( "iff" | "⇔" ) ConstraintSentence

QuantifiedSentence
    ::= QuantifiedVariableBinding+ QuantifiedBody

QuantifiedVariableBinding
    ::= ( Universal | Existential ) QuantifierBoundNames

Universal
    ::= "forall" | "∀"

Existential
    ::= "exists" | "∃"

QuantifierBoundNames
    ::= "self" | Identifer ( "," Identifer )* IteratorSource

IteratorSource
    ::= TypeIterator | SequenceIterator

TypeIterator
    ::= HasType ( "Self" | IdentifierReference )

SequenceIterator
    ::= ( "in" | "∈" ) ( FunctionComposition | Identifier | SequenceBuilder )

QuantifiedBody
    ::= "(" ConstraintSentence ")"

Term
    ::= FunctionComposition
        | Identifier
        | QualifiedIdentifier
        | PredicateValue
        | FunctionalTerm
        | SequenceBuilder

FunctionComposition
    ::= ( "self" | Identifier ) ( "." Identifier )+

PredicateValue
    ::= SimpleValue | SequenceOfPredicateValues

SequenceOfPredicateValues
    ::= "∅"
        | SequenceValueConstraint?
          "[" ( SimpleValue | IdentifierReference )* "]"

FunctionalTerm
    ::= Term "(" Term* ")"
#+END_SRC

*** Constraint Environment Definitions

#+BEGIN_SRC ebnf
ConstraintEnvironment
    ::= EnvironmentDef+ "in"

EnvironmentDef
    ::= "def" Identifier ( FunctionDef | ConstantDef )

FunctionDef
    ::= FunctionSignature ( ":=" | "≔" ) ConstraintSentence

FunctionSignature
    ::= "(" FunctionParameter+ ")" HasType FunctionType

FunctionParameter
    ::= Identifier HasType FunctionType

FunctionType
    ::=  FunctionCardinality? FunctionTypeRef

FunctionCardinality
    ::= "{"
        SequenceOrdering? SequenceUniqueness? ( Wildcard | CardinalityInner )
        "}"

FunctionTypeRef
    ::= Wildcard | IdentiferReference | BuiltinSimpleType | MappingType

Wildcard
    ::= "_"

ConstantDef
    ::= ( ":=" | "≔" ) ( PredicateValue | ConstraintSentence )
#+END_SRC

*** Sequence Builders

#+BEGIN_SRC ebnf
SequenceBuilder
    ::= "{"
        ( VariableNameSet | MappingVariable )
        "|"
        VariableBinding+ ConstraintSentence
        "}"

VariableNameSet
    ::= Identifier+

MappingVariable
    ::= "(" Identifier HasType Identifier ")"

VariableBinding
    ::= ( Universal | Existential ) QuantifierBinding ","
#+END_SRC


# ----- Footnotes

[fn:ebnf] [[https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form][Extended Backus-Naur Form (EBNF)]], Wikipedia
[fn:ebnfs] See [[http://www.cs.man.ac.uk/~pjj/bnf/ebnf.html][BNF/EBNF Variants]]
[fn:dcmi] [[https://www.dublincore.org/specifications/dublin-core/dcmi-terms/][DublinCoreDCMI Metadata Terms]], DublinCore
[fn:ucgc] [[https://unicode.org/reports/tr44/#GC_Values_Table][Unicode General Category]], Unicode.org
[fn:iri] RDF 1.1 Turtle – Terse RDF Triple Language, §[[https://www.w3.org/TR/turtle/#sec-iri-references][6.3 IRI References]], W3C
[fn:sparql] [[https://www.w3.org/TR/sparql11-overview/][SPARQL 1.1 Overview]], W3C
[fn:owlqr] [[https://www.w3.org/2007/OWL/wiki/Quick_Reference_Guide][OWL 2 Web Ontology Language Quick Reference Guide
(Second Edition)]], W3C
