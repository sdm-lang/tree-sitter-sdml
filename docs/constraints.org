#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* <<sec:model-constraints>>Capturing Model Constraints

In developing any data, domain, or information  model there are certain constraints between model elements that are
either difficult to represent in the model language itself. This is particularly true of visual languages or those with
a visual representation. For example, in UML it is not possible to define cross-attribute constraints (if this attribute
is true, that attribute must be false), or setting cardinality on transitive associations. To address this UML uses
Object Constraint Language[fn:ocl1][fn:ocl2], and similar languages have been proposed for parametric modeling
languages.

SDML allows constraints to be added to any model element where annotations are also allowed. Constraints are named,
and MAY be either /informally/, or /formally/ specified.

#+NAME: lst:grammar-constraint
#+BEGIN_SRC ebnf
Constraint          ::=
    "assert" Identifier ( InformalConstraint | FormalConstraint )
#+END_SRC

[[./ebnf-diagram/Constraint.svg]]

Informal constraints may be simple free-form strings, these are a common place to start even if you intend to make a
formal version later. An example informal constraint is shown in listing [[lst:ex-informal-constraint]]. However, they may
also be written using controlled natural languages for an additional level of specificity.

#+NAME: lst:ex-informal-constraint
#+CAPTION: Example Informal Constraint
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "All definitions in this module MUST have an annotation providing a skos:prefLabel value."

end
#+END_SRC

** Informal Constraints

Informal constraints, much like regular string values, have an optional language specifier. However, unlike regular
strings this specifier has a more limited range as it's purpose is to identify a /controlled natural language/ used for
specification.

#+NAME: lst:grammar-informal-constraint
#+BEGIN_SRC ebnf
InformalConstraint  ::= "=" QuotedString ControlledLanguageTag?
#+END_SRC

[[./ebnf-diagram/InformalConstraint.svg]]

The controlled language tag only includes the primary language component of a regular SDML string but adds a scheme
identifier.

#+BEGIN_SRC ebnf
ControlledLanguageTag ::=
    "@" LanguageTagPrimary ControlledLanguageScheme?
ControlledLanguageScheme ::=
    "-" ASCII_LETTER ASCII_LETTER ASCII_LETTER
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
#+END_SRC

[[./ebnf-diagram/ControlledLanguageTag.svg]]

[[./ebnf-diagram/ControlledLanguageScheme.svg]]

#+CAPTION: Informal Constraint with Natural Language
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "..."@en

end
#+END_SRC

For example, Common Logic Controlled English[fn:clce] (or Attempto Controlled English[fn:ace]) are well-known controlled
forms of English with formal structure and defined transformations into logical forms.  

#+CAPTION: Informal Constraint with Controlled Language
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "..."@en-CLCE

end
#+END_SRC

While no registry exists for scheme identifiers, the following identifiers *must* be used for the schemes listed in
table [[tbl:informal-constraint-schemes]].

#+NAME: tbl:informal-constraint-schemes
#+CAPTION: Informal Constraint Schemes
| Name                            | Identifier | Alternate | Formalism        |
|---------------------------------+------------+-----------+------------------|
| Attempto Controlled English     | ~ACE~        | ~Attempto~  |                  |
| Common Logic Controlled English | ~CLCE~       |           | ISO Common Logic |

** Formal Constraints

Formal constraints have their own embedded constraint language whose semantics are a subset of ISO Common
Logic[fn:isocl]. ISO Common Logic is most easily understood as an abstract language that allows for the interchange of
logical expressions based in first-order predicate logic between systems using standardized representations (Common
Logic Interchange Format (CLIF), Conceptual Graph Interchange Format (CGIF), and XML notation for Common Logic (XCL)).

#+NAME: lst:grammar-formal-constraint
#+BEGIN_SRC ebnf
FormalConstraint    ::= "is" ConstraintEnvironment? ConstraintSentence "end"
#+END_SRC

[[./ebnf-diagram/FormalConstraint.svg]]

Listing [[lst:ex-tagged-constraint-1]] is another informal constraint.

#+NAME: lst:ex-tagged-constraint-1
#+CAPTION: Example Formal Constraint (1 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  datatype Tag <- string

  structure Target is
    tags -> {0..} Tag
    ;; plus more interesing things...
  end

  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset = "All of target's tags must exist in my tags."
    end
  end
end
#+END_SRC

Listing [[lst:ex-tagged-constraint-2]] is a formal version of listing [[lst:ex-tagged-constraint-1]] which iterates over the set
of tags on the type ~Target~ which is the type of the member ~inner~ which is aliased to ~self~ (~self.tags~) within the constraint body.
For each element in the sequence of tags an existential statement ensures there is an equal tag within the enclosing
structure's tag collection (~self.container.tags~). 

#+NAME: lst:ex-tagged-constraint-2
#+CAPTION: Example Formal Constraint (2 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset is
        ∀ tag ∈ self.tags ( ∃ ptag ∈ self.container.tags ( ptag = tag ) )
      end
  end
end
#+END_SRC

Using the terminology of Common Logic a formal constraint consists of a constraint /sentence/ which is evaluated in the
context of the model element the constraint is attached to. This contextual element is bound to the identifier ~self~ and
the type of ~self~ is bound to the identifier ~Self~. Additionally, an optional /environment/ allows for the definition of
temporary values and functions for use in the constraint sentence.

#+NAME: lst:grammar-constraint-sentence
#+BEGIN_SRC ebnf
ConstraintSentence  ::=
    SimpleSentence | BooleanSentence | QuantifiedSentence |
        "(" ConstraintSentence ")"
#+END_SRC

[[./ebnf-diagram/ConstraintSentence.svg]]

*** Simple Sentences

#+NAME: lst:grammar-simple-sentence
#+BEGIN_SRC ebnf
SimpleSentence      ::= Atomic | Equation
Atomic              ::= Term "(" Term* ")"
Equation            ::= Term "=" Term
#+END_SRC

[[./ebnf-diagram/SimpleSentence.svg]]

[[./ebnf-diagram/Atomic.svg]]

[[./ebnf-diagram/Equation.svg]]

*** Boolean Sentences

Boolean sentences allow for the logical composition of sentences. 

#+NAME: lst:grammar-boolean-sentence
#+BEGIN_SRC ebnf
BooleanSentence     ::=
    Negation |
    ConstraintSentence
        (
          Conjunction | Disjunction | ExclusiveDisjunction |
          Implication | Biconditional
        )
#+END_SRC

[[./ebnf-diagram/BooleanSentence.svg]]

The usual operators for negation, conjunction, disjunction, and exclusive disjunction are as expected.

#+NAME: lst:grammar-boolean-sentence-cons
#+BEGIN_SRC ebnf
Negation            ::= ( "not" | "¬" ) ConstraintSentence
Conjunction         ::= ( "and" | "∧" ) ConstraintSentence
Disjunction         ::= ( "or" | "∨" ) ConstraintSentence
ExclusiveDisjunction ::= ( "xor" | "⊻" ) ConstraintSentence
#+END_SRC

[[./ebnf-diagram/Negation.svg]]

[[./ebnf-diagram/Conjunction.svg]]

[[./ebnf-diagram/Disjunction.svg]]

[[./ebnf-diagram/ExclusiveDisjunction.svg]]

#+NAME: lst:grammar-boolean-sentence-impl
#+BEGIN_SRC ebnf
Implication         ::= ( "implies" | "⇒" ) ConstraintSentence
Biconditional       ::= ( "iff" | "⇔" ) ConstraintSentence
#+END_SRC

[[./ebnf-diagram/Implication.svg]]

[[./ebnf-diagram/Biconditional.svg]]

*** Quantified Sentences

SDML supports, as shown in listing [[lst:ex-tagged-constraint-2]] sentences that range over values using the universal ($\forall$)
or existential ($\exists$) quantifier.

#+NAME: lst:grammar-quantified-sentence
#+BEGIN_SRC ebnf
QuantifiedSentence  ::= Universal | Existential
Universal           ::= ( "forall" | "∀" ) QuantifierBinding+ QuantifiedBody
Existential         ::= ( "exists" | "∃" ) QuantifierBinding+ QuantifiedBody
#+END_SRC

[[./ebnf-diagram/QuantifiedSentence.svg]]

[[./ebnf-diagram/Universal.svg]]

[[./ebnf-diagram/Existential.svg]]

#+NAME: lst:grammar-quantifier-binding
#+BEGIN_SRC ebnf
QuantifierBinding   ::= "self" | ( Identifer IteratorTarget )
IteratorTarget      ::=
    TypeIterator | SequenceIterator | "(" IteratorTarget ")"
#+END_SRC

[[./ebnf-diagram/QuantifierBinding.svg]]

[[./ebnf-diagram/IteratorTarget.svg]]

#+BEGIN_SRC ebnf
TypeIterator        ::= "->" ( "Self" | IdentifierReference )
#+END_SRC

[[./ebnf-diagram/TypeIterator.svg]]

#+BEGIN_SRC ebnf
SequenceIterator    ::=
    ( "in" | "∈" ) ( NamePath | Identifier | SequenceBuilder )
#+END_SRC

[[./ebnf-diagram/SequenceIterator.svg]]

#+NAME: lst:grammar-quantified-body
#+BEGIN_SRC ebnf
QuantifiedBody      ::= "(" ConstraintSentence ")"
#+END_SRC

[[./ebnf-diagram/QuantifiedBody.svg]]

More TBD

*** Terms

#+NAME: lst:grammar-constraint-term
#+BEGIN_SRC ebnf
Term                ::=
    NamePath
    | Identifier
    | QualifiedIdentifier
    | PredicateValue
    | FunctionalTerm
    | SequenceBuilder
#+END_SRC

[[./ebnf-diagram/Term.svg]]

#+NAME: lst:grammar-name-path
#+BEGIN_SRC ebnf
NamePath            ::= PathSubject ( "." Identifier )+
PathSubject         ::= ( "self" | Identifier )
#+END_SRC

[[./ebnf-diagram/NamePath.svg]]

[[./ebnf-diagram/PathSubject.svg]]

This notation is effectively syntactic sugar as it can be systematically transformed into the form above. The
transformation rules are:

1. The reserved words ~self~ and ~Self~ may only appear as the first element.
2. The list of names *after* the first are reversed and applied in turn as functions.
   * ~name.suffix~ becomes ~suffix(name(_))~
3. The first element will become the first argument to the inner-most function.
   * ~name.suffix~ becomes ~suffix(name(def))~
4. If the path ends in an argument list the arguments are added to the corresponding function call.
   *  ~suffix(name(def)) + ("Rental")~ becomes ~suffix(name(def) "Rental")~

Similarly the quantifier collection ~self.definitions~ becomes ~definitions(self)~.

#+NAME: lst:grammar-predicate-values
#+BEGIN_SRC ebnf
PredicateValue      ::=
    SimpleValue | SequenceOfPredicateValues
SequenceOfPredicateValues
    ::= "∅"
        | SequenceValueConstraint?
          "[" ( SimpleValue | IdentifierReference )* "]"
#+END_SRC

[[./ebnf-diagram/PredicateValue.svg]]

Note that the keyword ~∅~ denotes the empty set, or an empty sequence ~[]~ that is unique. Note that, like a normal sequence
of values, sequence constraints may be included.

[[./ebnf-diagram/SequenceOfPredicateValues.svg]]

#+NAME: lst:grammar-functional-term
#+BEGIN_SRC ebnf
FunctionalTerm      ::= Term "(" Term* ")"
#+END_SRC

[[./ebnf-diagram/FunctionalTerm.svg]]

*** <<sec:sequence-builders>>Sequence Builders

A sequence builder uses /set-builder/ notation to allow both specific selection of elements from sequences and
values from types. A sequence builder expression describes a sequence as a selection of values from existing sequences
filtered using predicates.

The simplest form of a builder expression is $\bigl\{ x \mid P(x)\bigr\}$, where $x$ is a variable and $P$ is a predicate that
evaluates to ~true~ to select the value of $x$. In natural language this expression read as follows "/construct a sequence
of values of $x$ *such that* the predicate $f$ holds true for $x$/".

#+NAME: lst:grammar-sequence-builder
#+BEGIN_SRC ebnf
SequenceBuilder     ::= "{" Variables "|" Expression "}"
#+END_SRC

[[./ebnf-diagram/SequenceBuilder.svg]]
#+NAME: lst:grammar-builder-variables
#+BEGIN_SRC ebnf
Variables           ::= TupleVariable | SequenceVariable | MappingVariable
TupleVariable       ::= Identifier+
SequenceVariable    ::= "[" Identifier+ "]"
MappingVariable     ::= "(" Identifier "->" Identifier ")"
#+END_SRC

[[./ebnf-diagram/Variables.svg]]

With a /tuple variable/ the builder returns a single value and a set of relations named for the variable identifiers.

$$t ≔ \bigl\{ x, y \mid P(x) \land Q(y) \land x = y \bigr\}$$

[[./ebnf-diagram/TupleVariable.svg]]

A /sequence variable/ returns a sequence where each element is another sequence comprising the values of the individual
identified values.

[[./ebnf-diagram/SequenceVariable.svg]]

Finally, a /mapping variable/ returns a sequence of mapping values which may comprise a lookup table.

$$t ≔ \bigl\{ \left(d \rightarrow r\right) \mid \forall d \in D \land \exists r \in R \land id_{D}(d) = id_{R}(r) \bigr\}$$

[[./ebnf-diagram/MappingVariable.svg]]

#+NAME: lst:grammar-builder-expression
#+BEGIN_SRC ebnf
Expression          ::=
    ConjunctiveExpression | LocalBinding | ConstraintSentence | "(" Expression ")"
ConjunctiveExpression   ::=
    Expression ( "and" | "∧" ) Expression
#+END_SRC

[[./ebnf-diagram/Expression.svg]]

[[./ebnf-diagram/ConjunctiveExpression.svg]]

#+NAME: lst:grammar-builder-local-binding
#+BEGIN_SRC ebnf
LocalBinding   ::=
    Identifier ( BindingFromType | BindingFromSequence )
#+END_SRC

[[./ebnf-diagram/LocalBinding.svg]]

*** Library Functions


#+BEGIN_EXAMPLE
def predicate(Type) -> boolean
def predicate(value -> Type) -> boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def relation(Type1, Type2) -> boolean
def relation(value1 -> Type1, value2 -> Type2) -> boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def function(Type, ...) -> RType
def function(value -> Type, ...) -> RType
#+END_EXAMPLE


Alternatively, listing [[lst:ex-tagged-constraint-3]] turns each sequence of tags into a set with the library function
~into_set~ and can then perform a simple subset check with the library function ~is_subset~.

#+NAME: lst:ex-tagged-constraint-3
#+CAPTION: Example Formal Constraint (3 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset is
        ∀ self ( is_subset( into_set(self.tags) into_set(self.container.tags)) )
      end
    end
  end
end
#+END_SRC

*** Constraint Environment

A formal constraint may start with an /environment/ that includes one or more /definitions/ that are then used in the
constraint body. A definition introduces a new /function/ or /constant/ -- a constant is effectively a 0-arity function --
although the function body may be a value or a constraint sentence and not specify side-effects.

#+NAME: lst:grammar-constraint-environment
#+BEGIN_SRC ebnf
ConstraintEnvironment ::= EnvironmentDef+ "in"
#+END_SRC

[[./ebnf-diagram/ConstraintEnvironment.svg]]

#+NAME: lst:grammar-environment-definition
#+BEGIN_SRC ebnf
EnvironmentDef      ::= "def" Identifier ( FunctionDef | ConstantDef )
#+END_SRC

[[./ebnf-diagram/EnvironmentDef.svg]]

A defined function has a signature that describes it's domain, or /parameters/, and it's range, or /return type/. 

#+NAME: lst:grammar-environment-function
#+BEGIN_SRC ebnf
FunctionDef         ::= FunctionSignature ( ":=" | "≔" ) ConstraintSentence
FunctionSignature   ::= "(" FunctionParameter+ ")" "->" FunctionType
FunctionParameter   ::= Identifier "->" FunctionType
#+END_SRC

[[./ebnf-diagram/FunctionDef.svg]]

[[./ebnf-diagram/FunctionSignature.svg]]

[[./ebnf-diagram/FunctionParameter.svg]]

Function type specifications may use wildcard symbols to denote their application to undefined types.

#+BEGIN_SRC ebnf
FunctionType        ::= FunctionCardinality? FunctionTypeRef
FunctionCardinality ::= "{" SequenceOrdering? SequenceUniqueness? ( Wildcard | CardinalityInner ) "}"
FunctionTypeRef     ::= Wildcard | IdentiferReference | BuiltinSimpleType | MappingType
Wildcard            ::= "_"
#+END_SRC

[[./ebnf-diagram/FunctionType.svg]]

[[./ebnf-diagram/FunctionCardinality.svg]]

[[./ebnf-diagram/FunctionTypeRef.svg]]

#+BEGIN_SRC ebnf
ConstantDef         ::= ( ":=" | "≔" ) ( PredicateValue | ConstraintSentence )
#+END_SRC

[[./ebnf-diagram/ConstantDef.svg]]

The example in listing [[lst:ex-formal-constraint]] is an expansion of the informal example in listing
[[lst:ex-informal-constraint]]. Here we check for the presence of the annotation on every top-level definition and then any
members of that definition. Note that this example also demonstrates the ability to create new predicates as in
~has_pref_label~ which simplifies the body of the constraint.

#+NAME: lst:ex-formal-constraint
#+CAPTION: Example Formal Constraint
#+BEGIN_SRC sdml :noeval :exports code
module labelled is

  assert must_have_preferred_label is
    def has_pref_label(anns -> {0..} Annotation) ≔
      ∃ a ∈ anns ( a.name = skos:prefLabel ∧ ¬a.value.is_empty )
  in
    has_pref_label(self.annotations)
    ∧ ∀ d ∈ self.definitions (
      has_pref_label(d.annotations)
      ∧ Entity(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Enumeration(d) ⇒ ∀ m ∈ d.variants ( has_pref_label(m.annotations) )
      ∧ Event(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Structure(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Union(d) ⇒ ∀ m ∈ d.variants ( has_pref_label(m.annotations) )
      ∧ Property(d) ⇒ ∀ m ∈ d.roles ( has_pref_label(m.annotations) )
    )
  end

end
#+END_SRC

# ----- Footnotes

[fn:ocl1] [[https://www.omg.org/spec/OCL/2.4][Object Constraint Language (OCL)]], OMG
[fn:ocl2] [[https://www.iso.org/standard/57306.html][ISO/IEC 19507:2012 Object Management Group Object Constraint Language (OCL)]], ISO/IEC
[fn:isocl] [[https://www.iso.org/standard/66249.html][ISO/IEC 24707:2018 Common Logic (CL) — A framework for a family of logic-based languages]], ISO/IEC
[fn:clce] [[http://www.jfsowa.com/clce/specs.htm][Common Logic Controlled English]], John F. Sowa, 2004.
[fn:ace] [[http://attempto.ifi.uzh.ch/site/][Attempto Controlled English (ACE)]], University of Zurich
