Module
    ::= "module" Identifier ModuleBase? ModuleBody

ModuleBase
    ::= "base" Iri

ModuleBody
    ::= "is"
        ImportStatement* Annotation* Definition*
        "end"

ImportStatement
    ::= "import" ( Import | "[" Import+ "]" )

Import
    ::= MemberImport | ModuleImport

ModuleImport
    ::= Identifer

MemberImport
    ::= QualifiedIdentifier

Annotation
    ::= AnnotationProperty | Constraint

AnnotationProperty
    ::= "@" IdentiferReference "=" Value

Definition
    ::= DataTypeDef
        | EntityDef
        | EnumDef
        | EvqentDef
        | StructureDef
        | UnionDef
        | PropertyDef
        | FeatureSetDef

DataTypeDef
    ::= "datatype" Identifier TypeRestriction DataTypeBase AnnotationOnlyBody?

TypeRestriction
    ::= "<-" | "←"

DataTypeBase
    ::= IdentifierReference | BuiltinSimpleType

AnnotationOnlyBody
    ::= "is" Annotation+ "end"

EntityDef
    ::= "entity" Identifier EntityBody?

EntityBody
    ::= "is"
        Annotation* IdentityMember ( EntityMember | EntityGroup )*
        "end"

EntityGroup
    ::= "group" Annotation* EntityMember+ "end"

EntityMember
    ::= MemberByValue | MemberByReference

EnumDef
    ::= "enum" Identifier EnumBody?

EnumBody
    ::= "of" Annotation* ValueVariant+ "end"

ValueVariant
    ::= Identifier "=" Unsigned AnnotationOnlyBody?

EventDef
    ::= "event" Identifier
        "source" IdentifierReference
        StructureBody?

StructureDef
    ::= "structure" Identifier StructureBody?

StructureBody
    ::= "is" Annotation* ( MemberByValue | StructureGroup )* "end"

StructureGroup
    ::= "group" Annotation* MemberByValue+ "end"

UnionDef
    ::= "union" Identifier UnionBody?

UnionBody
    ::= "of"
        Annotation* TypeVariant+
        "end"

TypeVariant
    ::= IdentifierReference TypeVariantRename? AnnotationOnlyBody?

TypeVariantRename
    ::= "as" Identifier

PropertyDef
    ::= "property" Identifier PropertyBody?

PropertyBody
    ::= "is" Annotation* PropertyRole+ "end"

PropertyRole
    ::= IdentityRole | RoleByValue | RoleByReference

IdentityRole
    ::= "identity" Identifier TypeExpression AnnotationOnlyBody?

RoleByValue
    ::= Identifier TypeExpressionTo AnnotationOnlyBody?

RoleByReference
    ::= "ref" Identifier InverseName? TypeExpressionTo AnnotationOnlyBody?

FeatureSetDef
    ::= "features" Identifier
        (
            FeatureSetConjunctiveBody
          | FeatureSetDisjunctiveBody
          | FeatureSetExclusiveDisjunctionBody
        )?

FeatureSetConjunctiveBody
    ::= "{" "and" "}" "is"
        Annotation* RoleByValue+

FeatureSetDisjunctiveBody
    ::= "{" "or" "}" "of"
        Annotation* TypeVariant+

FeatureSetExclusiveDisjunctionBody
    ::= ( "{" "xor" "}" )?
        "of"
        Annotation* TypeVariant+

PropertyMember
    ::= "in" IdentifierReference

IdentityMember
    ::= "identity" Identifier
        ( PropertyMember | ( TypeExpression AnnotationOnlyBody? ) )

MemberByValue
    ::= Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )

MemberByReference
    ::= "ref" Identifier
        ( PropertyMember | ( InverseName? TypeExpressionTo AnnotationOnlyBody? ) )

TypeExpression
    ::= HasType TypeReference

TypeExpressionTo
    ::= HasType Cardinality? TypeReference

HasType
    ::= "->" | "→" | "↦"

TypeReference
    ::=  UnknownType | IdentifierReference | BuiltinSimpleType | MappingType

UnknownType
    ::= "unknown"

MappingType
    ::= "(" TypeReference HasType TypeReference ")"

Cardinality
    ::= "{" SequenceOrdering? SequenceUniqueness? CardinalityInner "}"

CardinalityInner
    ::= Unsigned CardinalityRange?

CardinalityRange
    ::= ".." Unsigned?

SequenceOrdering
    ::= ( "ordered" | "unordered" )

SequenceUniqueness
    ::= ( "unique" | "nonunique" )

InverseName
    ::= "(" Identifier ")"

Value
    ::=  SimpleValue
        | ValueConstructor
        | IdentifierReference
        | MappingValue
        | SequenceOfValues

SimpleValue
    ::= Boolean
        | Unsigned | Integer | Decimal| Double
        | String | Iri | Binary

BuiltinSimpleType
    ::= "boolean"
        | "unsigned" | "integer"| "decimal"| "double"
        | "string" | "iri" | "binary"

Boolean
    ::= Tautology | Contradiction

Tautology
    ::= ( "true" | "⊤" )

Contradiction
    ::= ( "false" | "⊥" )

NumericSign
    ::= [+-]

Zero
    ::= [0]

NonZero
    ::= [1-9]

Unsigned
    ::= Zero | NonZero ASCII_DIGIT*

Integer
    ::= NumericSign? Unsigned

Decimal
    ::= Integer "." ASCII_DIGIT+

ExponentChar
    ::= [eE]

Double
    ::= Decimal ExponentChar NumericSign? Integer

String
    ::= QuotedString LanguageTag?

QuotedString
    ::= '"' ( Escape | NotAllowed )* '"'

NotAllowed
    ::= [^\"\#x00-#x08#x0B-#x1F#x7F]

Escape
    ::= "\\" ( CharacterEscape | UnicodeEscape )

CharacterEscape
    ::= [\"\\/abefnrtv]

UnicodeEscape
    ::= "u{" HexPair ( HexPair ( HexPair )? )? "}"

HexPair
    ::= ASCII_HEX_DIGIT ASCII_HEX_DIGIT

LanguageTag
    ::= "@"
        LanguageTagPrimary
        LanguageTagExtended?
        LanguageTagScript?
        LanguageTagRegion?

LanguageTagPrimary
    ::= ASCII_LETTER_LOWER ASCII_LETTER_LOWER ASCII_LETTER_LOWER?

LanguageTagExtended
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_UPPER ASCII_LETTER_UPPER

LanguageTagScript
    ::= "-"
        ASCII_LETTER_UPPER ASCII_LETTER_LOWER
        ASCII_LETTER_LOWER ASCII_LETTER_LOWER

LanguageTagRegion
    ::= "-"
        ( ( ASCII_LETTER_UPPER ASCII_LETTER_UPPER )
          | ( ASCII_DIGIT ASCII_DIGIT ASCII_DIGIT ) )

Iri
    ::= "<"
        ( [^<>\"{}|^`\#x00-#x20] | UnicodeEscape )*
        ">"

Binary
    ::= "#[" HexPair* "]"

ValueConstructor
    ::= IdentifierReference "(" SimpleValue ")"

MappingValue
    ::= SimpleValue HasType Value

SequenceOfValues
    ::= SequenceValueConstraint? "["
        ( SimpleValue | ValueConstructor | IdentifierReference )+
        "]"

SequenceValueConstraint
    ::= "{"
        ( SequenceOrdering? SequenceUniqueness? )
        "}"

IdentifierInitial
    ::= UC_LETTER_UPPER | UC_LETTER_LOWER

IdentifierChar
    ::= IdentifierInitial | UC_NUMBER_DECIMAL

Identifier
    ::= IdentifierInitial
        IdentifierChar* ( "_" IdentifierChar+ )*

QualifiedIdentifier
    ::= Identifier ":" Identifier

IdentifierReference
    ::= QualifiedIdentifier | Identifier

LineComment
    ::= ";" [^\r\n]*

Whitespace
    ::= [^\f\n\r\t\v#x20#xa0#x1680#x2000#x200a#x2028#x2029#x202f#x205f#x3000#xfeff]

/* --------------------------------------------------------------------------- */

Constraint
    ::= "assert" Identifier ( InformalConstraint | FormalConstraint )

InformalConstraint
    ::= "=" QuotedString ControlledLanguageTag?

ControlledLanguageTag
    ::= "@" LanguageTagPrimary ControlledLanguageScheme?

ControlledLanguageScheme
    ::= "-"
        ASCII_LETTER  ASCII_LETTER  ASCII_LETTER
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?

FormalConstraint
    ::= "is"
        ConstraintEnvironment? ConstraintSentence
        "end"

ConstraintSentence
    ::= SimpleSentence
        | BooleanSentence
        | QuantifiedSentence
        | "(" ConstraintSentence ")"

SimpleSentence
    ::= Atomic | Equation | Inequation

Atomic
    ::= Term "(" Term* ")"

Equation
    ::= Term "=" Term

Inequation
    ::= Term InequationRelation Term

InequationRelation
    ::= ( '/=' | '≠' | '<' | '>' | '<=' | '≤' | '>=' | '≥' )

BooleanSentence
    ::= Negation
        | ConstraintSentence
          (
            Conjunction | Disjunction | ExclusiveDisjunction |
            Implication | Biconditional
          )

Negation
    ::= ( "not" | "¬" ) ConstraintSentence

Conjunction
    ::= ( "and" | "∧" ) ConstraintSentence

Disjunction
    ::= ( "or" | "∨" ) ConstraintSentence

ExclusiveDisjunction
    ::= ( "xor" | "⊻" ) ConstraintSentence

Implication
    ::= ( "implies" | "⇒" ) ConstraintSentence

Biconditional
    ::= ( "iff" | "⇔" ) ConstraintSentence

QuantifiedSentence
    ::= QuantifiedVariableBinding+ QuantifiedBody

QuantifiedVariableBinding
    ::= ( Universal | Existential ) QuantifierBoundNames

Universal
    ::= "forall" | "∀"

Existential
    ::= "exists" | "∃"

QuantifierBoundNames
    ::= "self" | Identifer ( "," Identifer )* IteratorSource

IteratorSource
    ::= TypeIterator | SequenceIterator

TypeIterator
    ::= HasType ( "Self" | IdentifierReference )

SequenceIterator
    ::= ( "in" | "∈" ) ( FunctionComposition | Identifier | SequenceBuilder )

QuantifiedBody
    ::= "(" ConstraintSentence ")"

Term
    ::= FunctionComposition
        | Identifier
        | QualifiedIdentifier
        | PredicateValue
        | FunctionalTerm
        | SequenceBuilder

FunctionComposition
    ::= ( "self" | Identifier ) ( "." Identifier )+

PredicateValue
    ::= SimpleValue | SequenceOfPredicateValues

SequenceOfPredicateValues
    ::= "∅"
        | SequenceValueConstraint?
          "[" ( SimpleValue | IdentifierReference )* "]"

FunctionalTerm
    ::= Term "(" Term* ")"

/* --------------------------------------------------------------------------- */

ConstraintEnvironment
    ::= EnvironmentDef+ "in"

EnvironmentDef
    ::= "def" Identifier ( FunctionDef | ConstantDef )

FunctionDef
    ::= FunctionSignature ( ":=" | "≔" ) ConstraintSentence

FunctionSignature
    ::= "(" FunctionParameter+ ")" HasType FunctionType

FunctionParameter
    ::= Identifier HasType FunctionType

FunctionType
    ::=  FunctionCardinality? FunctionTypeRef

FunctionCardinality
    ::= "{"
        SequenceOrdering? SequenceUniqueness? ( Wildcard | CardinalityInner )
        "}"

FunctionTypeRef
    ::= Wildcard | IdentiferReference | BuiltinSimpleType | MappingType

Wildcard
    ::= "_"

ConstantDef
    ::= ( ":=" | "≔" ) ( PredicateValue | ConstraintSentence )

/* --------------------------------------------------------------------------- */

SequenceBuilder
    ::= "{"
        ( VariableNameSet | MappingVariable )
        "|"
        VariableBinding+ ConstraintSentence
        "}"

VariableNameSet
    ::= Identifier+

MappingVariable
    ::= "(" Identifier HasType Identifier ")"

VariableBinding
    ::= ( Universal | Existential ) QuantifierBinding ","
