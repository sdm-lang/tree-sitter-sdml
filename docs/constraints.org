#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* <<sec:model-constraints>>Capturing Model Constraints

In developing any data, domain, or information  model there are certain constraints between model elements that are
either difficult to represent in the model language itself. This is particularly true of visual languages or those with
a visual representation. For example, in UML it is not possible to define cross-attribute constraints (if this attribute
is true, that attribute must be false), or setting cardinality on transitive associations. To address this UML uses
Object Constraint Language[fn:ocl1][fn:ocl2], and similar languages have been proposed for parametric modeling
languages.

SDML allows constraints to be added to any model element where annotations are also allowed. Constraints are named,
and MAY be either /informally/, or /formally/ specified.

#+NAME: lst:grammar-constraint
#+BEGIN_SRC ebnf
Constraint          ::=
    "assert" Identifier ( InformalConstraint | FormalConstraint )
#+END_SRC

[[./ebnf-diagram/Constraint.svg]]

Informal constraints may be simple free-form strings, these are a common place to start even if you intend to make a
formal version later. An example informal constraint is shown in listing [[lst:ex-informal-constraint]]. However, they may
also be written using controlled natural languages for an additional level of specificity.

#+NAME: lst:ex-informal-constraint
#+CAPTION: Example Informal Constraint
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "All definitions in this module MUST have an annotation providing a skos:prefLabel value."

end
#+END_SRC

** Informal Constraints

Informal constraints, much like regular string values, have an optional language specifier. However, unlike regular
strings this specifier has a more limited range as it's purpose is to identify a /controlled natural language/ used for
specification.

#+NAME: lst:grammar-informal-constraint
#+BEGIN_SRC ebnf
InformalConstraint  ::= "=" QuotedString ControlledLanguageTag?
#+END_SRC

[[./ebnf-diagram/InformalConstraint.svg]]

The controlled language tag only includes the primary language component of a regular SDML string but adds a scheme
identifier.

#+BEGIN_SRC ebnf
ControlledLanguageTag ::=
    "@" LanguageTagPrimary ControlledLanguageScheme?
ControlledLanguageScheme ::=
    "-" ASCII_LETTER ASCII_LETTER ASCII_LETTER
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
#+END_SRC

[[./ebnf-diagram/ControlledLanguageTag.svg]]

[[./ebnf-diagram/ControlledLanguageScheme.svg]]

#+CAPTION: Informal Constraint with Natural Language
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "..."@en

end
#+END_SRC

For example, Common Logic Controlled English[fn:clce] (or Attempto Controlled English[fn:ace]) are well-known controlled
forms of English with formal structure and defined transformations into logical forms.  

#+CAPTION: Informal Constraint with Controlled Language
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "..."@en-CLCE

end
#+END_SRC

While no registry exists for scheme identifiers, the following identifiers *must* be used for the schemes listed in
table [[tbl:informal-constraint-schemes]].

#+NAME: tbl:informal-constraint-schemes
#+CAPTION: Informal Constraint Schemes
| Name                            | Identifier | Alternate | Formalism        |
|---------------------------------+------------+-----------+------------------|
| Attempto Controlled English     | ~ACE~        | ~Attempto~  |                  |
| Common Logic Controlled English | ~CLCE~       |           | ISO Common Logic |

** Formal Constraints

Formal constraints have their own embedded constraint language whose semantics are a subset of ISO Common
Logic[fn:isocl]. ISO Common Logic is most easily understood as an abstract language that allows for the interchange of
logical expressions based in first-order predicate logic between systems using standardized representations (Common
Logic Interchange Format (CLIF), Conceptual Graph Interchange Format (CGIF), and XML notation for Common Logic (XCL)).

#+NAME: lst:grammar-formal-constraint
#+BEGIN_SRC ebnf
FormalConstraint    ::= "is" ConstraintEnvironment? ConstraintSentence "end"
#+END_SRC

[[./ebnf-diagram/FormalConstraint.svg]]

Listing [[lst:ex-tagged-constraint-1]] is another informal constraint.

#+NAME: lst:ex-tagged-constraint-1
#+CAPTION: Example Formal Constraint (1 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  datatype Tag <- string

  structure Target is
    tags -> {0..} Tag
    ;; plus more interesing things...
  end

  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset = "All of target's tags must exist in my tags."
    end
  end
end
#+END_SRC

Listing [[lst:ex-tagged-constraint-2]] is a formal version of listing [[lst:ex-tagged-constraint-1]] which iterates over the set
of tags on the type ~Target~ which is the type of the member ~inner~ which is aliased to ~self~ (~self.tags~) within the constraint body.
For each element in the sequence of tags an existential statement ensures there is an equal tag within the enclosing
structure's tag collection (~self.container.tags~). 

#+NAME: lst:ex-tagged-constraint-2
#+CAPTION: Example Formal Constraint (2 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset is
        ∀ tag ∈ self.tags ( ∃ ptag ∈ self.container.tags ( ptag = tag ) )
      end
  end
end
#+END_SRC

Using the terminology of Common Logic a formal constraint consists of a constraint /sentence/ which is evaluated in the
context of the model element the constraint is attached to. This contextual element is bound to the identifier ~self~ and
the type of ~self~ is bound to the identifier ~Self~. Additionally, an optional /environment/ allows for the definition of
temporary values and functions for use in the constraint sentence.

#+NAME: lst:grammar-constraint-sentence
#+BEGIN_SRC ebnf
ConstraintSentence  ::=
    SimpleSentence | BooleanSentence | QuantifiedSentence |
        "(" ConstraintSentence ")"
#+END_SRC

[[./ebnf-diagram/ConstraintSentence.svg]]

*** Simple Sentences

#+NAME: lst:grammar-simple-sentence
#+BEGIN_SRC ebnf
SimpleSentence      ::= Atomic | Equation
Atomic              ::= Term "(" Term* ")"
Equation            ::= Term "=" Term
#+END_SRC

[[./ebnf-diagram/SimpleSentence.svg]]

[[./ebnf-diagram/Atomic.svg]]

[[./ebnf-diagram/Equation.svg]]

*** Boolean Sentences

Boolean sentences allow for the logical composition of sentences. 

#+NAME: lst:grammar-boolean-sentence
#+BEGIN_SRC ebnf
BooleanSentence     ::=
    Negation |
    ConstraintSentence
        (
          Conjunction | Disjunction | ExclusiveDisjunction |
          Implication | Biconditional
        )
#+END_SRC

[[./ebnf-diagram/BooleanSentence.svg]]

The usual operators for negation, conjunction, disjunction, and exclusive disjunction are as expected.

#+NAME: lst:grammar-boolean-sentence-cons
#+BEGIN_SRC ebnf
Negation            ::= ( "not" | "¬" ) ConstraintSentence
Conjunction         ::= ( "and" | "∧" ) ConstraintSentence
Disjunction         ::= ( "or" | "∨" ) ConstraintSentence
ExclusiveDisjunction ::= ( "xor" | "⊻" ) ConstraintSentence
#+END_SRC

[[./ebnf-diagram/Negation.svg]]

[[./ebnf-diagram/Conjunction.svg]]

[[./ebnf-diagram/Disjunction.svg]]

[[./ebnf-diagram/ExclusiveDisjunction.svg]]

#+NAME: lst:grammar-boolean-sentence-impl
#+BEGIN_SRC ebnf
Implication         ::= ( "implies" | "⇒" ) ConstraintSentence
Biconditional       ::= ( "iff" | "⇔" ) ConstraintSentence
#+END_SRC

[[./ebnf-diagram/Implication.svg]]

[[./ebnf-diagram/Biconditional.svg]]

*** Quantified Sentences

SDML supports, as shown in listing [[lst:ex-tagged-constraint-2]] sentences that range over values using the universal ($\forall$)
or existential ($\exists$) quantifier.

#+NAME: lst:grammar-quantified-sentence
#+BEGIN_SRC ebnf
QuantifiedSentence  ::= Universal | Existential
Universal           ::= ( "forall" | "∀" ) QuantifierBinding+ QuantifiedBody
Existential         ::= ( "exists" | "∃" ) QuantifierBinding+ QuantifiedBody
#+END_SRC

[[./ebnf-diagram/QuantifiedSentence.svg]]

[[./ebnf-diagram/Universal.svg]]

[[./ebnf-diagram/Existential.svg]]

#+NAME: lst:grammar-quantifier-binding
#+BEGIN_SRC ebnf
QuantifierBinding   ::= "self" | ( Identifer IteratorTarget )
IteratorTarget      ::=
    TypeIterator | SequenceIterator | "(" IteratorTarget ")"
#+END_SRC

[[./ebnf-diagram/QuantifierBinding.svg]]

[[./ebnf-diagram/IteratorTarget.svg]]

#+BEGIN_SRC ebnf
TypeIterator        ::= "->" ( "Self" | IdentifierReference )
#+END_SRC

[[./ebnf-diagram/TypeIterator.svg]]

#+BEGIN_SRC ebnf
SequenceIterator    ::=
    ( "in" | "∈" ) ( NamePath | Identifier | SequenceBuilder )
#+END_SRC

[[./ebnf-diagram/SequenceIterator.svg]]

#+NAME: lst:grammar-quantified-body
#+BEGIN_SRC ebnf
QuantifiedBody      ::= "(" ConstraintSentence ")"
#+END_SRC

[[./ebnf-diagram/QuantifiedBody.svg]]

More TBD

*** Terms

#+NAME: lst:grammar-constraint-term
#+BEGIN_SRC ebnf
Term                ::=
    NamePath
    | Identifier
    | QualifiedIdentifier
    | PredicateValue
    | FunctionalTerm
    | SequenceBuilder
#+END_SRC

[[./ebnf-diagram/Term.svg]]

#+NAME: lst:grammar-name-path
#+BEGIN_SRC ebnf
NamePath            ::= PathSubject ( "." Identifier )+
PathSubject         ::= ( "self" | Identifier )
#+END_SRC

[[./ebnf-diagram/NamePath.svg]]

[[./ebnf-diagram/PathSubject.svg]]

This notation is effectively syntactic sugar as it can be systematically transformed into the form above. The
transformation rules are:

1. The reserved words ~self~ and ~Self~ may only appear as the first element.
2. The list of names *after* the first are reversed and applied in turn as functions.
   * ~name.suffix~ becomes ~suffix(name(_))~
3. The first element will become the first argument to the inner-most function.
   * ~name.suffix~ becomes ~suffix(name(def))~
4. If the path ends in an argument list the arguments are added to the corresponding function call.
   *  ~suffix(name(def)) + ("Rental")~ becomes ~suffix(name(def) "Rental")~

Similarly the quantifier collection ~self.definitions~ becomes ~definitions(self)~.

#+NAME: lst:grammar-predicate-values
#+BEGIN_SRC ebnf
PredicateValue      ::=
    SimpleValue | ListOfPredicateValues
ListOfPredicateValues ::= "∅" | ( "[" ( SimpleValue | IdentifierReference )* "]" )
#+END_SRC

[[./ebnf-diagram/PredicateValue.svg]]

[[./ebnf-diagram/ListOfPredicateValues.svg]]

#+NAME: lst:grammar-functional-term
#+BEGIN_SRC ebnf
FunctionalTerm      ::= Term "(" Term* ")"
#+END_SRC

[[./ebnf-diagram/FunctionalTerm.svg]]

*** <<sec:sequence-builders>>Sequence Builders

A sequence builder uses /set-builder/ notation to allow both specific selection of elements from sequences and
values from types. A sequence builder expression describes a sequence as a selection of values from existing sequences
filtered using predicates.

The simplest form of a builder expression is $\bigl\{ x \mid P(x)\bigr\}$, where $x$ is a variable and $P$ is a predicate that
evaluates to ~true~ to select the value of $x$. In natural language this expression read as follows "/construct a sequence
of values of $x$ *such that* the predicate $f$ holds true for $x$/".

#+NAME: lst:grammar-sequence-builder
#+BEGIN_SRC ebnf
SequenceBuilder     ::= "{" Variables "|" Expression "}"
#+END_SRC

[[./ebnf-diagram/SequenceBuilder.svg]]
#+NAME: lst:grammar-builder-variables
#+BEGIN_SRC ebnf
Variables           ::= TupleVariable | SequenceVariable | MappingVariable
TupleVariable       ::= Identifier+
SequenceVariable    ::= "[" Identifier+ "]"
MappingVariable     ::= "(" Identifier "->" Identifier ")"
#+END_SRC

[[./ebnf-diagram/Variables.svg]]

With a /tuple variable/ the builder returns a single value and a set of relations named for the variable identifiers.

$$t ≔ \bigl\{ x, y \mid P(x) \land Q(y) \land x = y \bigr\}$$

[[./ebnf-diagram/TupleVariable.svg]]

A /sequence variable/ returns a sequence where each element is another sequence comprising the values of the individual
identified values.

[[./ebnf-diagram/SequenceVariable.svg]]

Finally, a /mapping variable/ returns a sequence of mapping values which may comprise a lookup table.

$$t ≔ \bigl{ \left(d -> r\right) \mid \forall d \in D \land \exists r \in R \land d.id = r.id \bigr}$$

[[./ebnf-diagram/MappingVariable.svg]]

#+NAME: lst:grammar-builder-expression
#+BEGIN_SRC ebnf
Expression          ::=
    ConjunctiveExpression | LocalBinding | ConstraintSentence | "(" Expression ")"
ConjunctiveExpression   ::=
    Expression ( "and" | "∧" ) Expression
#+END_SRC

[[./ebnf-diagram/Expression.svg]]

[[./ebnf-diagram/ConjunctiveExpression.svg]]

#+NAME: lst:grammar-builder-local-binding
#+BEGIN_SRC ebnf
LocalBinding   ::=
    Identifier ( BindingFromType | BindingFromSequence )
#+END_SRC

[[./ebnf-diagram/LocalBinding.svg]]

*** Library Functions


#+BEGIN_EXAMPLE
def predicate(Type) -> boolean
def predicate(value -> Type) -> boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def relation(Type1, Type2) -> boolean
def relation(value1 -> Type1, value2 -> Type2) -> boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def function(Type, ...) -> RType
def function(value -> Type, ...) -> RType
#+END_EXAMPLE


Alternatively, listing [[lst:ex-tagged-constraint-3]] turns each sequence of tags into a set with the library function
~into_set~ and can then perform a simple subset check with the library function ~is_subset~.

#+NAME: lst:ex-tagged-constraint-3
#+CAPTION: Example Formal Constraint (3 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset is
        ∀ self ( is_subset( into_set(self.tags) into_set(self.container.tags)) )
      end
    end
  end
end
#+END_SRC

*** Constraint Environment

TBD

#+NAME: lst:grammar-constraint-environment
#+BEGIN_SRC ebnf
ConstraintEnvironment ::= EnvironmentDef+ "in"
#+END_SRC

[[./ebnf-diagram/ConstraintEnvironment.svg]]

#+NAME: lst:grammar-environment-definition
#+BEGIN_SRC ebnf
EnvironmentDef      ::= "def" Identifier ( FunctionDef | ValueDef )
#+END_SRC

[[./ebnf-diagram/EnvironmentDef.svg]]

#+NAME: lst:grammar-environment-function
#+BEGIN_SRC ebnf
FunctionDef         ::= FunctionSignature ( ":=" | "≔" ) ConstraintSentence
FunctionSignature   ::= "(" FunctionParameter+ ")" "->" FunctionType
FunctionParameter   ::= Identifier "->" FunctionType
FunctionType        ::=  FunctionCardinality? FunctionTypeRef
#+END_SRC

[[./ebnf-diagram/FunctionDef.svg]]

[[./ebnf-diagram/FunctionSignature.svg]]

[[./ebnf-diagram/FunctionParameter.svg]]

[[./ebnf-diagram/FunctionType.svg]]

#+BEGIN_SRC ebnf
FunctionCardinality ::= "{}" | Cardinality
FunctionTypeRef     ::= "_" | IdentiferReference | BuiltinSimpleType | MappingType
#+END_SRC

[[./ebnf-diagram/FunctionCardinality.svg]]

[[./ebnf-diagram/FunctionTypeRef.svg]]

#+BEGIN_SRC ebnf
ValueDef            ::= ( ":=" | "≔" ) ( PredicateValue | ConstraintSentence )
#+END_SRC

[[./ebnf-diagram/ValueDef.svg]]

The example in listing [[lst:ex-formal-constraint]] is an expansion of the informal example in listing
[[lst:ex-informal-constraint]]. Here we check for the presence of the annotation on every top-level definition and then any
members of that definition. Note that this example also demonstrates the ability to create new predicates as in
~has_pref_label~ which simplifies the body of the constraint.

#+NAME: lst:ex-formal-constraint
#+CAPTION: Example Formal Constraint
#+BEGIN_SRC sdml :noeval :exports code
module labelled is

  assert must_have_preferred_label is
    def has_pref_label(anns -> {0..} Annotation) ≔
      ∃ a ∈ anns ( a.name = skos:prefLabel ∧ ¬a.value.is_empty )
  in
    has_pref_label(self.annotations)
    ∧ ∀ d ∈ self.definitions (
      has_pref_label(d.annotations)
      ∧ Entity(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Enumeration(d) ⇒ ∀ m ∈ d.variants ( has_pref_label(m.annotations) )
      ∧ Event(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Structure(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Union(d) ⇒ ∀ m ∈ d.variants ( has_pref_label(m.annotations) )
      ∧ Property(d) ⇒ ∀ m ∈ d.roles ( has_pref_label(m.annotations) )
    )
  end

end
#+END_SRC

** Constraint Semantics

The embedded constraint language is purely functional and constraint assertions MUST return a single boolean value
determining correctness. The constraint language follows the naming convention of Common Logic, and so a constraint
corresponds to a Common Logic /sentence/ which may be one of the following forms.

*Notation*

- We use the letters $f, g, h, \cdots$, to denote /functions/, and the letters $P, Q, R, \cdots$ to denote /predicates/. Properly
  these are function and predicate /symbols/, however this level of indirection is not useful in this description.
- We use $A$ to denote the universe of concrete $values$
- Functions map a /domain/ $\mathcal{d}$ to a /range/ $\mathcal{r}$ of values in $A$.
- Predicates are functions over a domain of /relations/ and have a range of /boolean/ values.
- We also associate with each function and predicate symbol a non-negative integer, called its arity which indicates the
  number of arguments a function or relation takes.
  - A function or predicate of arity 0 is called a constant.
  - Sometimes we use superscripts to indicate the arity of a symbol, e.g., we may write $f^2$ for a binary function.
- We use the letters $x, y, z, \cdots$ to denote (individual) variables, ranging over elements of a specified domain.
- We use the symbol $\mathcal{D}$ to denote the domain of discourse.

- Given the above, the relationship between /symbols/ and concrete functions and predicates is as follows.
  - For each /n/-ary function symbol $f \in \mathcal{F}$, there exists an /n/-ary function $f^\mathcal{D}: A^n \rightarrow A$.
  - For each /n/-ary predicate symbol $P \in \mathcal{P}$ there exists an /n/-ary predicate $P^\mathcal{D}: ⊆ A^n$.
     
*General Semantics*

1. Let $\mathcal{F}$ and $\mathcal{P}$ be sets of functions and predicates respectively, and $\mathcal{X}$ be a set of
   variables.
1. The set $\mathcal{T} (\mathcal{F}, \mathcal{V})$ of terms (over $\mathcal{F}$ and $\mathcal{X}$) is defined inductively
   by:
   - every variable $x$ in $\mathcal{X}$ is a term, and
   - if $f$ is a function in $\mathcal{F}$ of arity $n$, and $t_1, \cdots, t_n$ are terms, then $f(t_1,\cdots, t_n)$ is also a term.
1. For example, if $f$ is a binary function, $a$ is a constant, and $x$ is a variable, then $a$, $f(a, x)$, and $f(a, a)$
   are all terms.
1. Similarly, we define:
   - if $P$ is a predicate symbol in $\mathcal{P}$ of arity $n$, and $t1, \cdots, t_n$ are terms, then $P(t_1, \cdots, t_n)$ is an
     atomic formula, or /atom/ for short.
1. Thus, if $P$ is a binary predicate symbol, then $P(x, x)$ and $P(a, f(x, a))$ are atomic formulas.
1. If a term or atom contains no variables, it is said to be variable-free or /ground/.
1. The same variable may occur several times in a formula. We distinguish between free and bound occurrences of variables.
1. Each occurrence of a variable $x$ that is in the scope of a quantifier expression $∀x$ or $∃x$ is said to be /bound/.
   An occurrence of $x$ that is not bound is said to be /free/.
1. For example, in $∀x∃y P(x, y)$ all variable occurrences are bound, whereas in $∃y P(x, y)$ the occurrence of $x$ is free.
1. The same variable may have both free and bound occurrences in a formula, e.g., the variable $x$ in $Q(x) ∨ ∃x ¬R(x)$.
1. Formulas without free occurrences of variables are called /sentences/. Thus, $∀x∃y P(x, y)$ is a sentence but $∃y P(x,
   y)$ is not.

Semantically, sentences are formulas that can be true or false, whereas the truth value of a formula with free
occurrences of variables depends on the assignment of values to these variables.

*** Simple Sentences

An /atomic sentence/ takes the form of a predicate with a set of zero or more arguments.

#+BEGIN_EXAMPLE
predicate(a1, ..., an)
#+END_EXAMPLE

An /equation/ sentence asserts the equality of two terms.

#+BEGIN_EXAMPLE
rhs = rhs
#+END_EXAMPLE
  
*** Boolean Sentences

The /conjunction/ of two sentences takes the form of the application of the logical /and/ operation.

#+BEGIN_EXAMPLE
lhs and rhs
lhs  ∧  rhs
#+END_EXAMPLE

The /disjunction/ of two sentences takes the form of the application of the logical /or/ operation.

#+BEGIN_EXAMPLE
lhs or rhs
lhs ∧  rhs
#+END_EXAMPLE

The /exclusive disjunction/ of two sentences takes the form of the application of the logical /xor/ operation.

#+BEGIN_EXAMPLE
lhs xor rhs
lhs  ⊻  rhs
#+END_EXAMPLE

An /implication/ relation between two sentences holds true when the right-hand proposition is a logical
consequence of the left-hand. In effect it says that "if the left-hand side is true, then the right-hand side is also
true"; however, it does not say what one can deduce if the left-hand side is not true, or under what other conditions
the right-hand side may be true.

Note that the left-hand side is often named the /antecedent/ and the right-hand side is the /consequent/. The entire
expression is often termed a /conditional/.

#+BEGIN_EXAMPLE
lhs implies rhs
lhs   ==>   rhs
lhs    ⇒    rhs
#+END_EXAMPLE

A /biconditional/ relation between two sentences holds true when the both sides are either true or false. In effect, "the
left-hand side implies the right-hand side and the right-hand side implies the left-hand-side".

#+BEGIN_EXAMPLE
lhs iff  rhs
lhs <==> rhs
lhs  ⇔   rhs
#+END_EXAMPLE

$$L \iff R \equiv (L \implies R) \land (R \implies L)$$
    
*** Quantified Sentences

The /universal quantification/ over a type says that "for all values $v$ of type $T$ the sentence $s$ must hold true".

#+BEGIN_EXAMPLE
forall v -> Type (s)
     ∀ v -> Type (s)
#+END_EXAMPLE

The /universal quantification/ over a sequence says that "for all elements $e$ in the sequence $S$ the sentence $s$ must hold
true".

#+BEGIN_EXAMPLE
forall e in Sequence (s)
     ∀ e ∈  Sequence (s)
#+END_EXAMPLE

The /existential quantification/ over a type says that "there exists a value $v$ of type $T$ where the sentence $s$ holds
true".

#+BEGIN_EXAMPLE
exists v -> Type (s)
     ∃ v -> Type (s)
#+END_EXAMPLE

The /existential quantification/ over a sequence says that "there exists an element $e$ in the sequence $S$ where the sentence
$s$ holds true".

#+BEGIN_EXAMPLE
exists e in Sequence (s)
     ∃ e ∈  Sequence (s)
#+END_EXAMPLE
    
*** Sequence Builders

*Notation*

- We use the symbol $\mathbb{S}$ to denote an arbitrary sequence of values such that $\mathbb{S} ⊆ A$.
- We use the type $\mathbb{T}$ to denote an arbitrary type which is a set of values such that $\mathbb{T} ⊆ A$.
- We use the symbol $\tau_x$ to denote the type $\mathbb{T}$ of a value $x \in A$. Given that a function or predicate with an
  arity of $0$ is a constant value:
  - for functions the following equivalence holds $\forall f \in \mathcal{F} \left(arity(f) = 0 \implies \mathcal{r}_f =
    \tau_f\right)$, and
  - for predicates the following equivalence holds $\forall p \in \mathcal{P} \left(arity(p) = 0 \implies \mathcal{r}_p = \tau_p\right)$.
  
The value of a sequence builder of the form $t ≔ \bigl\{ x, y \mid \ldots\}$ provides a relation for each variable of
the form $x(\tau_t) → \tau_x$ and $y(\tau_t) \rightarrow \tau_y$. This can be expressed in the following:

$$t ≔ \bigl\{ x_1, \cdots, x_n \mid \ldots \bigr\} \implies \forall x \in x_1, \cdots, x_n, \exists f \in \mathcal{F} \bigl(arity(f) = 1 \land \mathcal{d}_f =
\tau_t \land \mathcal{r}_f = \tau_x\bigr)$$

The expression from section [[sec:sequence-builders]] does not provide a domain for the variable $x$ and so will take on all
values from the domain of discourse, $\mathcal{D}$. We may then define a transform in the following manner.

$$\bigl\{ x \mid P(x)\bigr\} \equiv \bigl\{ x \mid x \in \mathcal{D} \land P(x)\bigr\}$$

In natural language this transformed expression read as follows "construct a sequence of values of $x$ *such that* $x$ is
in the sequence $\mathcal{D}$ *and* the predicate $P$ holds true for $x$".

Predicates may also be combined with the usual boolean operations; negation $\bigl\{ x \mid ¬P(x)\bigr\}$, conjunction
$\bigl\{ x \mid P(x) \wedge Q(x)\bigr\}$, disjunction $\bigl\{ x \mid P(x) \vee Q(x)\bigr\}$, and exclusive disjunction $\{ x
\mid P(x) \veebar Q(x)\bigr\}$.

The domain for each variable $x$ may either be described as the set of all elements in a sequence value
$\mathbb{S}$, or the set of all values for a type $\mathbb{T}$.

1. $\bigl\{ x \mid x \in \mathbb{S} \land P(x)\bigr\}$ returns a sequence of all values $x$ in the collection $\mathbb{S}$ for which the
   predicate $P$ holds (evaluates to ~true~).
   - Example: $\bigl\{ m \mid x \in self.members \land optional(m)\bigr\}$
1. $\bigl\{ x \mid x \in \mathbb{T} \land P(x)\bigr\}$ returns a sequence of all values $x$ in the type $\mathbb{T}$ for which the
   predicate $P$ holds (evaluates to ~true~).
   - Example: $\bigl\{ v \mid v \in FutureDate \land gt(v, today)\bigr\}$.
   - Example: $\bigl\{ v \mid v → FutureDate \land gt(v, today)\bigr\}$.

It can be shown that this is a universal quantification, /all/ values from the type $\mathbb{T}$ or sequence
$\mathbb{S}$ will be considered. A variable can be identified as existentially quantified by prefacing it's definition
with either the keyword ~exists~ or the operator ~∃~.

$$\bigl\{ x \mid x \in self.tags \land ∃ y \in self.container.tags \land x = y\bigr\}$$

The following definitions are taken from the standard library and act as filters over a sequence of ~Annotation~ union
values to provide sequences which only contain one or other of the types in the union.

#+BEGIN_EXAMPLE
def annotation_properties(anns -> {} Annotation) -> {} AnnotationProperty
    ≔ {a | a ∈ anns ∧ AnnotationProperty(a)}

def constraints(anns - > {}  Annotation) -> {} Constraint
    ≔ {a | a ∈ anns ∧ Constraint(a)}
#+END_EXAMPLE

*** Quantified Sentences as Sequence Builders


The existential qualifier specifically determines that there is /at least one/ element in the type or sequence where the
sentence provided holds true. If you need to ensure a specific cardinality, for example that /exactly three/ elements in
type or sequence are selected, use a sequence comprehension.

#+BEGIN_EXAMPLE
count({ e | e in Sequence ∧ s}) = 3
#+END_EXAMPLE

By this definition we can show that the following are equivalent.

#+BEGIN_EXAMPLE
exists e in Sequence (s)
not is_empty({ e | e in Sequence ∧ s})
#+END_EXAMPLE

More formally, the following equivalence holds true.

$$∃ e \in \mathbb{S} \bigl(P\left(e\right)\bigr) ≡ ¬\bigl\{e \mid e \in \mathbb{S} ∧ P\left(e\right)\bigr\}=∅$$

We can also show that the following are equivalent for universal quantification.

#+BEGIN_EXAMPLE
forall e in Sequence (s)
is_empty({ e | e in Sequence ∧ not s}
#+END_EXAMPLE

$$∀ e \in \mathbb{S} \bigl(P\left(e\right)\bigr) ≡ \bigl\{e \mid e \in \mathbb{S} ∧ ¬P(e)\bigr\}=∅$$

In this manner we can treat the quantified sentences as syntactic sugar over specific forms of sequence comprehensions.

# ----- Footnotes

[fn:ocl1] [[https://www.omg.org/spec/OCL/2.4][Object Constraint Language (OCL)]], OMG
[fn:ocl2] [[https://www.iso.org/standard/57306.html][ISO/IEC 19507:2012 Object Management Group Object Constraint Language (OCL)]], ISO/IEC
[fn:isocl] [[https://www.iso.org/standard/66249.html][ISO/IEC 24707:2018 Common Logic (CL) — A framework for a family of logic-based languages]], ISO/IEC
[fn:clce] [[http://www.jfsowa.com/clce/specs.htm][Common Logic Controlled English]], John F. Sowa, 2004.
[fn:ace] [[http://attempto.ifi.uzh.ch/site/][Attempto Controlled English (ACE)]], University of Zurich
