#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* Appendix: Standard Library

The standard library provided with SDML contains the language library itself, SDML modules representing commonly used
external namespaces, and a set of predicates and functions that are available for writing constraints.

** SDML Module

The ~sdml~ module contains the set of types that represent the language itself, most of which are only used in the writing
of constraints. However, the pre-defined simple types ~boolean~, ~decimal~, etc. are also defined here.

#+BEGIN_SRC sdml :noeval :exports code
module sdml base <http://sdml.io/sdml-owl.ttl#> is
  structure Datatype ;; ...
  structure Annotation ;; ...
  structure AnnotationProperty ;; ...
  structure ByReferenceMember ;; ...
  structure ByValueMember ;; ...
  structure Cardinality ;; ...
  structure Constraint ;; ...
  structure Definition ;; ...
  structure Entity ;; ...
  structure EntityGroup ;; ...
  structure EntityMember ;; ...
  structure Enumeration ;; ...
  structure Event ;; ...
  structure FormalConstraint ;; ...
  structure Identifier ;; ...
  structure IdentiferReference ;; ...
  structure IdentityMember ;; ...
  structure ImportStatement ;; ...
  structure Import ;; ...
  structure Member ;; ...
  structure MemberImport ;; ...
  structure Module ;; ...
  structure ModuleImport ;; ...
  structure Property ;; ...
  structure PropertyRole ;; ...
  structure QualifiedIdentifier ;; ...
  structure Structure ;; ...
  structure StructureGroup ;; ...
  structure TypeVariant ;; ...
  structure Union ;; ...
  structure ValueVariant ;; ...

  datatype boolean <- xsd:boolean ;; ...
  datatype unsigned <- xsd:unsignedLong ;; ...
  datatype integer <- xsd:long ;; ...
  datatype double <- xsd:double ;; ...
  datatype decimal <- xsd:decimal ;; ...
  datatype language <- xsd:language ;; ...
  datatype string <- xsd:string ;; ...
  datatype iri <- xsd:anyURI ;; ...
  datatype binary <- xsd:hexBinary ;; ...

  datatype u8 <- xsd:unsignedByte ;; ...
  datatype i8 <- xsd:byte ;; ...
  datatype u16 <- xsd:unsignedShort ;; ...
  datatype i16 <- xsd:short ;; ...
  datatype u32 <- xsd:unsignedInt ;; ...
  datatype i32 <- xsd:int ;; ...
  datatype u64 <- xsd:unsignedLong ;; ...
  datatype i64 <- xsd:long ;; ...

end
#+END_SRC

** Commonly Used Modules

*** Dublin Core Elements

This module 

#+BEGIN_SRC sdml :noeval :exports code
module dc base <http://purl.org/dc/elements/1.1/> is
  structure contributor ;; ...
  structure coverage ;; ...
  structure creator ;; ...
  structure date ;; ...
  structure description ;; ...
  structure format ;; ...
  structure identifier ;; ...
  structure language ;; ...
  structure publisher ;; ...
  structure relation ;; ...
  structure rights ;; ...
  structure source ;; ...
  structure subject ;; ...
  structure title ;; ...
  structure type ;; ...
end
#+END_SRC

*** DCMI Abstract Model

This module 

#+BEGIN_SRC sdml :noeval :exports code
module dcam base <http://purl.org/dc/dcam/> is
  structure VocabularyEncodingScheme ;; ...
  structure domainIncludes ;; ...
  structure memberOf ;; ...
  structure rangeIncludes ;; ...
end
#+END_SRC

*** DCMI Type Vocabulary

This module 

#+BEGIN_SRC sdml :noeval :exports code
module dcmi_type base <http://purl.org/dc/dcmitype/> is
 structure Collection ;; ...
  structure Dataset ;; ...
  structure Event ;; ...
  structure Image ;; ...
  structure InteractiveResource ;; ...
  structure MovingImage ;; ...
  structure PhysicalObject ;; ...
  structure Service ;; ...
  structure Software ;; ...
  structure Sound ;; ...
  structure StillImage ;; ...
  structure Text ;; ...
end
#+END_SRC

*** DCMI Metadata Terms 

This module 

#+BEGIN_SRC sdml :noeval :exports code
module dcterms base <http://purl.org/dc/terms/> is
  structure Agent ;; ...
  structure AgentClass ;; ...
  structure BibliographicResource ;; ...
  structure Box ;; ...
  structure DCMIType ;; ...
  structure DDC ;; ...
  structure FileFormat ;; ...
  structure Frequency ;; ...
  structure IMT ;; ...
  structure ISO3166 ;; ...
  structure ISO639_2 ;; ...
  structure ISO639_3 ;; ...
  structure Jurisdiction ;; ...
  structure LLC ;; ...
  structure LCSH ;; ...
  structure LicenseDocument ;; ...
  structure LinguisticSystem ;; ...
  structure Location ;; ...
  structure LocationPeriodOrJurisdiction ;; ...
  structure MESH ;; ...
  structure MediaType ;; ...
  structure MediaTypeOrExtent ;; ...
  structure MethodOfAccrual ;; ...
  structure MethodOfInstruction ;; ...
  structure NLM ;; ...
  structure Period ;; ...
  structure PeriodOfTime ;; ...
  structure PhysicalMedium ;; ...
  structure PhysicalResource ;; ...
  structure Point ;; ...
  structure Policy ;; ...
  structure ProvenanceStatement ;; ...
  structure RFC1766 ;; ...
  structure RFC3066 ;; ...
  structure RFC4646 ;; ...
  structure RFC5646 ;; ...
  structure RightsStatement ;; ...
  structure SizeOrDuration ;; ...
  structure Standard ;; ...
  structure TGN ;; ...
  structure UDC ;; ...
  structure URI ;; ...
  structure WthreeCDTF ;; ...
  structure abstract ;; ...
  structure accessRights ;; ...
  structure accrualMethod ;; ...
  structure accrualPeriodicity ;; ...
  structure accrualPolicy ;; ...
  structure alternative ;; ...
  structure audience ;; ...
  structure available ;; ...
  structure bibliographicCitation ;; ...
  structure conformsTo ;; ...
  structure contributor ;; ...
  structure coverage ;; ...
  structure created ;; ...
  structure creator ;; ...
  structure date ;; ...
  structure dateCopyrighted ;; ...
  structure dateSubmitted ;; ...
  structure description ;; ...
  structure educationLevel ;; ...
  structure extent ;; ...
  structure forma ;; ...
  structure hasFormat ;; ...
  structure hasPart ;; ...
  structure hasVersion ;; ...
  structure identifier ;; ...
  structure instructionalMethod ;; ...
  structure isFormatOf ;; ...
  structure isPartOf ;; ...
  structure isReferencedBy ;; ...
  structure isReplacedBy ;; ...
  structure isRequiredBy ;; ...
  structure isVersionOf ;; ...
  structure issued ;; ...
  structure language ;; ...
  structure license ;; ...
  structure mediator ;; ...
  structure medium ;; ...
  structure modified ;; ...
  structure provenance ;; ...
  structure publisher ;; ...
  structure references ;; ...
  structure relation ;; ...
  structure replaces ;; ...
  structure requires ;; ...
  structure rights ;; ...
  structure rightsHolder ;; ...
  structure source ;; ...
  structure spatial ;; ...
  structure subject ;; ...
  structure tableOfContents ;; ...
  structure temporal ;; ...
  structure title ;; ...
  structure type ;; ...
  structure valid ;; ...
end
#+END_SRC

*** The OWL 2 Schema Vocabulary 
This module 

#+BEGIN_SRC sdml :noeval :exports code
module owl base <http://www.w3.org/2002/07/owl#> is end
#+END_SRC

*** The RDF Concepts Vocabulary

This module 

#+BEGIN_SRC sdml :noeval :exports code
module rdf base <http://www.w3.org/1999/02/22-rdf-syntax-ns#> is
  structure Alt ;; ...
  structure Bag ;; ...
  structure CompoundLiteral ;; ...
  structure HTML  ;; ...
  structure JSON ;; ...
  structure List ;; ...
  structure PlainLiteral ;; ...
  structure Property ;; ...
  structure Seq ;; ...
  structure Statement ;; ...
  structure XMLLiteral ;; ...
  structure direction
  structure first ;; ...
  structure langString ;; ...
  structure language ;; ...
  structure nil ;; ...
  structure object ;; ...
  structure predicate ;; ...
  structure rest ;; ...
  structure subject ;; ...
  structure type ;; ...
  structure value ;; ...
end
#+END_SRC

*** The RDF Schema Vocabulary

This module 

#+BEGIN_SRC sdml :noeval :exports code
module rdfs base <http://www.w3.org/2000/01/rdf-schema#> is
  structure Class ;; ...
  structure Container ;; ...
  structure ContainerMembershipProperty  ;; ...
  structure Datatype ;; ...
  structure Literal ;; ...
  structure Resource ;; ...
  structure comment ;; ...
  structure domain ;; ...
  structure isDefinedBy ;; ...
  structure label ;; ...
  structure member ;; ...
  structure range ;; ...
  structure seeAlso ;; ...
  structure subClassOf ;; ...
  structure subPropertyOf ;; ...
end
#+END_SRC

*** Simple Knowledge Organization System Namespace

This module 

#+BEGIN_SRC sdml :noeval :exports code
module skos base <http://www.w3.org/2004/02/skos/core#> is
  structure Collection  ;; ...
  structure Concept ;; ...
  structure ConceptScheme ;; ...
  structure OrderedCollection ;; ...
  structure altLabel ;; ...
  structure broadMatch ;; ...
  structure broader ;; ...
  structure broaderTransitive ;; ...
  structure changeNote ;; ...
  structure closeMatch ;; ...
  structure definition ;; ...
  structure editorialNote ;; ...
  structure exactMatch ;; ...
  structure example ;; ...
  structure hasTopConcept ;; ...
  structure hiddenLabel ;; ...
  structure historyNote ;; ...
  structure inScheme ;; ...
  structure mappingRelation ;; ...
  structure member ;; ...
  structure memberList ;; ...
  structure narrowMatch ;; ...
  structure narrower ;; ...
  structure narrowerTransitive ;; ...
  structure notation ;; ...
  structure note ;; ...
  structure prefLabel ;; ...
  structure related ;; ...
  structure relatedMatch ;; ...
  structure scopeNote ;; ...
  structure semanticRelation ;; ...
  structure topConceptOf ;; ...
end
#+END_SRC

*** The xml Namespace

This module 

#+BEGIN_SRC sdml :noeval :exports code
module xml <http://www.w3.org/XML/1998/namespace> is end
#+END_SRC

*** XML Schema Datatypes

This module 

#+BEGIN_SRC sdml :noeval :exports code
module xsd base <http://www.w3.org/2001/XMLSchema#> is end
#+END_SRC

** Constraint Language Library

Note that all of the predicates, relations, and functions in this section exist within the ~sdml~ module scope but
qualification is optional unless the application is ambiguous in a particular context.

*** The Type ~Type~

*Class: Type*

#+BEGIN_EXAMPLE
def Type(_) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed value is a ~Type~, else ~false~.

#+BEGIN_EXAMPLE
def is_unknown(self → _) → boolean
    ≔ Type(self) ⇒ self = sdml:Unknown ∨ is_unknown(type_of(self))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def name(Type) → QualifiedIdentifier
#+END_EXAMPLE

The qualified identifier that names this type. In all cases the module portion of the name will be ~"sdml"~.

example: ~type_of(rentals:Customer) = "sdml:Entity"~

#+BEGIN_EXAMPLE
def type_of(_) → Type
#+END_EXAMPLE

Returns the SDML type of the passed value.

example: ~type_of(rentals:Customer) = sdml:Entity~

*** Equality and Inequality

#+BEGIN_EXAMPLE
def eq(_ _) → boolean
#+END_EXAMPLE

Returns ~true~ if the two values are equal, else ~false~.

#+BEGIN_EXAMPLE
def gt(_ _) → boolean
#+END_EXAMPLE

Returns ~true~ if the first value is greater than the second, else ~false~.

#+BEGIN_EXAMPLE
def gte(v1 → _ v2 → _) → boolean
    ≔ gt(v1 v2) ∨ eq(v1 v2)
#+END_EXAMPLE

Returns ~true~ if the first value is greater than or equal to the second, else ~false~.

#+BEGIN_EXAMPLE
def lt(v1 → _ v2 → _) → boolean
    ≔ ¬gte(v1 v2)
#+END_EXAMPLE

Returns ~true~ if the first value is less than the second, else ~false~.

#+BEGIN_EXAMPLE
def lte(v1 → _ v2 → _) → boolean
    ≔ ¬gt(v1 v2)
#+END_EXAMPLE

Returns ~true~ if the first value is less than or equal to the second, else ~false~.

#+BEGIN_EXAMPLE
def ne(v1 → _ v2 → _) → boolean
    ≔ ¬eq(v1 v2)
#+END_EXAMPLE

Returns ~true~ if the two values are not equal, else ~false~.

*** Identifiers

*Class: Identifier*

#+BEGIN_EXAMPLE
def Identifier(self → _) → boolean
    ≔ type_of(self) = sdml:Identifier
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Identifier~, else ~false~.

#+BEGIN_EXAMPLE
def join(Identifier Identifer) → QualifiedIdentifier
#+END_EXAMPLE

Return a new qualified identifier with the first parameter as the module name and the second as the member name.

*Class: QualifiedIdentifier*

#+BEGIN_EXAMPLE
def QualifiedIdentifier(self → _) → boolean
    ≔ type_of(self) = sdml:QualifiedIdentifier
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~QualifiedIdentifier~, else ~false~.

#+BEGIN_EXAMPLE
def member(QualifiedIdentifier) → Identifier
#+END_EXAMPLE

Return the member name part of the identifier.

#+BEGIN_EXAMPLE
def module(QualifiedIdentifier) → Identifier
#+END_EXAMPLE

Return the module name part of the identifier.

*Union: IdentifierReference*

#+BEGIN_EXAMPLE
def IdentifierReference(self → _) → boolean
    ≔ type_of(self) = sdml:IdentiferReference
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~IdentifierReference~, else ~false~.

#+BEGIN_EXAMPLE
def as_identifier(IdentifierReference) → {0..1} Identifier
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_qualified_identifier(IdentifierReference) → {0..1} QualifiedIdentifier
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_identifier(IdentifierReference) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_qualified_identifier(IdentifierReference) → boolean
#+END_EXAMPLE

*** Module Definition

*Class: Module*

#+BEGIN_EXAMPLE
def Module(self → _) → boolean
    ≔ type_of(self) = sdml:Module
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Module~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Module) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def base_uri(Module) → {0..1} iri
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def definitions(Module) → {unique 0..} Definition
#+END_EXAMPLE

Returns an unordered, unique, sequence of variants contained within the union.

#+BEGIN_EXAMPLE
def imports(Module) → {unique 0..} ImportStatement
#+END_EXAMPLE

Returns an unordered, unique, sequence of import statements.

#+BEGIN_EXAMPLE
def is_complete(self → Module) → boolean
    ≔ ∀ d ∈ definitions(self) ( is_complete(d) )
#+END_EXAMPLE

Returns ~true~ if the module definition is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def name(Module) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def resolved_uri(Module) → iri
#+END_EXAMPLE

*Union: Definition*

#+BEGIN_EXAMPLE
def Definition(self → _) → boolean
    ≔ type_of(self) = sdml:Definition
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Definition~, else ~false~.

#+BEGIN_EXAMPLE
def as_datatype(Definition) → {0..1} Datatype
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_entity(Definition) → {0..1} Entity
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_enumeration(Definition) → {0..1} Enumeration
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_event(Definition) → {0..1} Event
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_structure(Definition) → {0..1} Structure
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_property(Definition) → {0..1} Property
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_datatype(Definition) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_entity(Definition) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_enumeration(Definition) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_event(Definition) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_structure(Definition) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_property(Definition) → boolean
#+END_EXAMPLE

*** Imports

*Class: ImportStatement*

#+BEGIN_EXAMPLE
def ImportStatement(self → _) → boolean
    ≔ type_of(self) = sdml:ImportStatement
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~ImportStatement~, else ~false~.

#+BEGIN_EXAMPLE
def imports(ImportStatement) → {0..} Import
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def member_imports(i → ImportStatement)
    ≔ {i | i ∈ imports(i) ∧ MemberImport(i)}
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def module_imports(i → ImportStatement)
    ≔ {i | i ∈ imports(i) ∧ ModuleImport(i)}
#+END_EXAMPLE

*Class: Import*

#+BEGIN_EXAMPLE
def Import(self → _) → boolean
    ≔ type_of(self) = sdml:Import
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Import~, else ~false~.

#+BEGIN_EXAMPLE
def is_module_import(Import) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_member_import(Import) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_module_import(Import) → Maybe of ModuleImport
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_member_import(Import) → Maybe of MemberImport
#+END_EXAMPLE

*Class: ModuleImport*

#+BEGIN_EXAMPLE
def ModuleImport(self → _) → boolean
    ≔ type_of(self) = sdml:ModuleImport
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~ModuleImport~, else ~false~.

#+BEGIN_EXAMPLE
def module(ModuleImport) → Identifier
#+END_EXAMPLE

*Class: MemberImport*

#+BEGIN_EXAMPLE
def MemberImport(self → _) → boolean
    ≔ type_of(self) = sdml:MemberImport
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~MemberImport~, else ~false~.

#+BEGIN_EXAMPLE
def module(MemberImport) → Identifier
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def member(MemberImport) → Identifier
#+END_EXAMPLE

*** Datatypes and Values

*Class: Datatype*

#+BEGIN_EXAMPLE
def Datatype(self → _) → boolean
    ≔ type_of(self) = sdml:Datatype
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Datatype~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Module) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def base_type(Datatype) → {0..1} Datatype
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def container(Datatype) → Module
#+END_EXAMPLE

Returns the module that contains this model element's definition.

#+BEGIN_EXAMPLE
def is_ordinal(Datatype) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed type is an /ordinal type/, else ~false~.

#+BEGIN_EXAMPLE
def name(Datatype) → IdentifierReference
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def qualified_name(c → Constraint) → Identifier
    ≔ join(name(container(c)) name(c))
#+END_EXAMPLE

Return the qualified identifier naming this model element and it's containing module.

*Datatype: decimal*

#+BEGIN_EXAMPLE
def decimal(_) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~decimal~, else ~false~.

#+BEGIN_EXAMPLE
def whole_part(decimal) → decimal
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def decimal_part(decimal) → decimal
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def round(decimal) → decimal
#+END_EXAMPLE

*Datatype: double*

#+BEGIN_EXAMPLE
def double(_) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~double~, else ~false~.

#+BEGIN_EXAMPLE
def whole_part(double) → double
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def decimal_part(double) → double
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def round(double) → double
#+END_EXAMPLE

*Datatype: integer*

#+BEGIN_EXAMPLE
def integer(_) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~integer~, else ~false~.

*Datatype: iri*

#+BEGIN_EXAMPLE
def iri(_) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~iri~, else ~false~.

#+BEGIN_EXAMPLE
def is_absolute(iri) → boolean
#+END_EXAMPLE

*Datatype: language*

#+BEGIN_EXAMPLE
def language(_) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~language~, else ~false~.

#+BEGIN_EXAMPLE
def broader(languageTag languageTag) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def language_extended_part(languageTag) → string
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def language_part(languageTag) → string
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def narrower(languageTag languageTag) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def region_part(languageTag) → string
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def script_part(languageTag) → string
#+END_EXAMPLE

*Datatype: string*

#+BEGIN_EXAMPLE
def string(_) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~string~, else ~false~.

#+BEGIN_EXAMPLE
def contains(string sub → string) → boolean
#+END_EXAMPLE

Returns ~true~ if the value of the second string is contained within the first, else ~false~.

#+BEGIN_EXAMPLE
def eq_ci(string string) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def into_list(string) → {ordered 0..} unsigned
#+END_EXAMPLE

Returns a new list where each element is the Unicode code-point of a character in the input string.

#+BEGIN_EXAMPLE
def join(string string) → string
#+END_EXAMPLE

Return a new string which is the concatenation of the two input strings.

#+BEGIN_EXAMPLE
def language_part(string) → Maybe of language
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def length(string) → integer
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def matches(string regex → string) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def ne_ci(string string) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def prefix(string prefix → string) → boolean
#+END_EXAMPLE

Returns ~true~ if the first string starts with the value of the second, else ~false~.

#+BEGIN_EXAMPLE
def quoted_part(string) → string
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def suffix(string suffix → string) → boolean
#+END_EXAMPLE

Returns ~true~ if the first string ends with the value of the second, else ~false~.

*Datatype: unsigned*

#+BEGIN_EXAMPLE
def unsigned(_) → boolean
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~unsigned~, else ~false~.

#+BEGIN_EXAMPLE
def into_integer(unsigned) → integer
#+END_EXAMPLE

*** <<seq:library-sequence-types>>Sequence Types

*Class: Sequence*

#+BEGIN_EXAMPLE
def Sequence(self → {_}) → boolean
    ≔ type_of(self) = sdml:Sequence
#+END_EXAMPLE

Returns ~true~ if the value is of type ~Sequence~ or any sub-type of ~Sequence~, else ~false~.

#+BEGIN_EXAMPLE
def contains(s → {_} t → _) → boolean
    ≔ ¬is_empty({ e | e ∈ s ∧ e = t})
#+END_EXAMPLE

Returns ~true~ if the sequence ~s~ contains the element ~t~, else ~false~.

#+BEGIN_EXAMPLE
def count({_}) → unsigned
#+END_EXAMPLE

Returns the number of elements in the sequence.

#+BEGIN_EXAMPLE
def element_type({_}) → Type
#+END_EXAMPLE

Returns the type of the members within this sequence.

#+BEGIN_EXAMPLE
def into_bag(seq → {_}) → {0..} _
#+END_EXAMPLE

Transforms the input sequence into a ~Bag~, this *may* remove ordering and uniqueness constraints from the input sequence
but *will not* remove any elements.

#+BEGIN_EXAMPLE
def into_list(seq → {_}) → {ordered nonunique 0..} _
#+END_EXAMPLE

Transforms the input sequence into a ~List~, this *may* add ordering and remove uniqueness constraints from the input sequence
but *will not* remove any elements.

#+BEGIN_EXAMPLE
def into_ordered_set(seq → {_}) → {ordered unique 0..} _
#+END_EXAMPLE

Transforms the input sequence into a ~OrderedSet~, this *may* add both ordering and uniqueness constraints to the input sequence
and *will* remove duplicate elements.

#+BEGIN_EXAMPLE
def into_set({_}) → {unordered unique 0..} _
#+END_EXAMPLE

Transforms the input sequence into a ~Set~, this *may* remove ordering and add uniqueness constraints to the input sequence
and *will* remove duplicate elements.

#+BEGIN_EXAMPLE
def is_empty(seq → {_}) → boolean
    ≔ count(seq) = 0
#+END_EXAMPLE

Return ~true~ if the sequence has no elements, else ~false~.

#+BEGIN_EXAMPLE
def is_ordered(t → {_}) → boolean
    ≔ fold_head(lte t)
#+END_EXAMPLE

Returns ~true~ if the provided type ~t~ is an ordered sequence, else ~false~.

#+BEGIN_EXAMPLE
def is_unique(t → {_}) → boolean
    ≔ count(t) == count(fold(∅ union t))
#+END_EXAMPLE

Returns ~true~ if the provided type ~t~ is a sequence that guarantees uniqueness of elements, else ~false~.

#+BEGIN_EXAMPLE
def join({_} sep → string) → string
#+END_EXAMPLE

Return a new string where the string form of each value in the sequence is concatenated with the value of the string
placed between each.

Example: ~join([1 2 3] ",") = "1,2,3"~

*Class: List*

Returns ~true~ if the passed value is of type ~List~, else ~false~.

#+BEGIN_EXAMPLE
def drop({ordered nonunique 0..} _ count → unsigned) → List of _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def get({ordered nonunique 0..} _ index → unsigned) → _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def order({ordered nonunique 0..} _) → List of _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def reverse({ordered nonunique 0..} _) → List of _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def slice({ordered nonunique 0..} _ start → unsigned count → unsigned) → List of _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def take({ordered nonunique 0..} _ count → unsigned) → List of _
#+END_EXAMPLE

*Class: OrderedSet*

#+BEGIN_EXAMPLE
drop({ordered unique 0..}  _ count → unsigned) → {ordered unique 0..} _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
get({ordered unique 0..} _ index → unsigned) → _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
intersection(lhs → {ordered unique 0..} _ rhs → {ordered unique 0..} _) → OrderedSet of _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
is_strict_subset(lhs → {ordered unique 0..} _ rhs → {ordered unique 0..} _) → boolean
    ≔ is_subset(lhs rhs) ∧ ¬eq(lhs rhs)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
is_strict_superset(lhs → {ordered unique 0..} _ rhs → {ordered unique 0..} _) → boolean
    ≔ is_superset(lhs rhs) ∧ ¬eq(lhs rhs)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
is_subset(lhs → {ordered unique 0..} _ rhs → {ordered unique 0..} _) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
is_superset(lhs → {ordered unique 0..} _ rhs → {ordered unique 0..} _) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
minus(lhs → {ordered unique 0..} _ rhs → OrderedSet of _) → {ordered unique 0..} _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
reverse({ordered unique 0..} _) → {ordered unique 0..} _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
slice({ordered unique 0..} _ start → unsigned count → unsigned) → {ordered unique 0..} _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
take({ordered unique 0..} _ count → unsigned) → {ordered unique 0..} _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
union({ordered unique 0..} _ rhs → {ordered unique 0..} _) → {ordered unique 0..} _
#+END_EXAMPLE

*Class: Set*

#+BEGIN_EXAMPLE
intersection(lhs → {unordered unique 0..} _ rhs → Set of _) → {unordered unique 0..} _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
is_strict_subset(lhs → {unordered unique 0..} _ rhs → {unordered unique 0..} _) → boolean
    ≔ is_subset(lhs rhs) ∧ ¬eq(lhs rhs)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
is_strict_superset(lhs → {unordered unique 0..} _ rhs → {unordered unique 0..} _) → boolean
    ≔ is_superset(lhs rhs) ∧ ¬eq(lhs rhs)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
is_subset(lhs → {unordered unique 0..} _ rhs → {unordered unique 0..} _) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
is_superset(lhs → {unordered unique 0..} _ rhs → {unordered unique 0..} _) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
minus(lhs → {unordered unique 0..} _ rhs → {unordered unique 0..} _) → Set of _
#+END_EXAMPLE

#+BEGIN_EXAMPLE
union(lhs → {unordered unique 0..} _ rhs → {unordered unique 0..} _) → {unordered unique 0..} _
#+END_EXAMPLE

*** Annotations

*Class Annotation*

#+BEGIN_EXAMPLE
def Annotation(self → _) → boolean
    ≔ type_of(self) = sdml:Annotation
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Annotation~, else ~false~.

#+BEGIN_EXAMPLE
def as_annotation_property(Annotation) → {0..1} AnnotationProperty
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_constraint(Annotation) → {0..1} Constraint
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_annotation_property(Annotation) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_constraint(Annotation) → boolean
#+END_EXAMPLE

*Class AnnotationProperty*

#+BEGIN_EXAMPLE
def AnnotationProperty(self → _) → boolean
    ≔ type_of(self) = sdml:AnnotationProperty
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~AnnotationProperty~, else ~false~.

#+BEGIN_EXAMPLE
def container(Member) → ModelElement
#+END_EXAMPLE

Returns the model element that contains this annotation assertion.

#+BEGIN_EXAMPLE
def name(AnnotationProperty) → IdentiferReference
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def value(AnnotationProperty) → Value
#+END_EXAMPLE

*Class Constraint*

#+BEGIN_EXAMPLE
def Constraint(self → _) → boolean
    ≔ type_of(self) = sdml:Constraint
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Constraint~, else ~false~.

#+BEGIN_EXAMPLE
def as_formal(Constraint) → {0..1} FormalConstraint
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_informal(Constraint) → {0..1} string
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def container(Member) → ModelElement
#+END_EXAMPLE

Returns the model element that contains this annotation assertion.

#+BEGIN_EXAMPLE
def is_formal(Constraint) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_informal(Constraint) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def name(Constraint) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

*Annotation Collections*

#+BEGIN_EXAMPLE
def annotation_properties(as → {0..} Annotation)
    ≔ {a | a ∈ as ∧ AnnotationProperty(a)}
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def constraints(as - > {0..} Annotation)
    ≔ {a | a ∈ as ∧ Constraint(a)}
#+END_EXAMPLE

*** Structured Type Members

*Class: Member*

#+BEGIN_EXAMPLE
def Member(self → _) → boolean
    ≔ type_of(self) = sdml:Member
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Member~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Member) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(Member) → Type
#+END_EXAMPLE

Returns the container type that contains this member's definition.

#+BEGIN_EXAMPLE
def is_complete(self → Member) → boolean
    ≔ ¬Unknown(type_of(self))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def name(Member) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def target_type(Member) → Type
#+END_EXAMPLE

*Class: IdentityMember*

#+BEGIN_EXAMPLE
def IdentityMember(self → _) → boolean
    ≔ type_of(self) = sdml:IdentityMember
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~IdentityMember~, else ~false~.

*Class: ByReferenceMember*

#+BEGIN_EXAMPLE
def ByReferenceMember(self → _) → boolean
    ≔ type_of(self) = sdml:ByReferenceMember
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~ByReferenceMember~, else ~false~.

*Class: ByValueMember*

#+BEGIN_EXAMPLE
def ByValueMember(self → _) → boolean
    ≔ type_of(self) = sdml:ByValueMember
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~ByValueMember~, else ~false~.

*Class: Cardinality*

#+BEGIN_EXAMPLE
def Cardinality(self → _) → boolean
    ≔ type_of(self) = sdml:Cardinality
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Cardinality~, else ~false~.

#+BEGIN_EXAMPLE
def is_optional(c → Cardinality) → boolean
    ≔ min(c) = 0 ∧ eq(max(c) 1)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_range(Cardinality) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_range_unbounded(c → Cardinality) → boolean
    ≔ is_range(c) ∧ is_empty(max(c))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def max(Cardinality) → {0..} unsigned
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def min(Cardinality) → unsigned
#+END_EXAMPLE

*** Entities

*Class: Entity*

#+BEGIN_EXAMPLE
def Entity(self → _) → boolean
    ≔ type_of(self) = sdml:Entity
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Entity~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Entity) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(Entity) → Module
#+END_EXAMPLE

Returns the module that contains this model element's definition.

#+BEGIN_EXAMPLE
def flat_members(Entity) → {ordered unique 0..} EntityMember
#+END_EXAMPLE

Returns an unordered, unique, sequence of members contained within the entity.

#+BEGIN_EXAMPLE
def groups(Entity) → {ordered unique 0..} EntityGroup
#+END_EXAMPLE

Returns an unordered, unique, sequence of members contained within the entity.

#+BEGIN_EXAMPLE
def identity(Entity) → IdentityMember
#+END_EXAMPLE

Returns the identity member for this entity.

#+BEGIN_EXAMPLE
def is_complete(self → Structure) → boolean
    ≔ has_body(self)
    ∧ ∀ member ∈ flat_members(self) (is_complete(member))
#+END_EXAMPLE

Returns ~true~ if the entity definition is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def members(Entity) → {ordered unique 0..} EntityMember
#+END_EXAMPLE

Returns an unordered, unique, sequence of members contained within the entity.

#+BEGIN_EXAMPLE
def name(Entity) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def qualified_name(self → Constraint) → Identifier
    ≔ join(name(container(self)) name(self))
#+END_EXAMPLE

Return the qualified identifier naming this model element and it's containing module.

*Class: EntityGroup*

#+BEGIN_EXAMPLE
def EntityGroup(self → _) → boolean
    ≔ type_of(self) = sdml:EntityGroup
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~EntityGroup~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(EntityGroup) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(EntityGroup) → Entity
#+END_EXAMPLE

Returns the entity that contains group's definition.

#+BEGIN_EXAMPLE
def is_complete(self → Structure) → boolean
    ∀ member ∈ members(self) (is_complete(member))
#+END_EXAMPLE

Returns ~true~ if the entity group is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def members(EntityGroup) → {ordered unique 0..} EntityMember
#+END_EXAMPLE

Returns an unordered, unique, sequence of variants contained within the union.

*Union: EntityMember*

#+BEGIN_EXAMPLE
def EntityMember(self → _) → boolean
    ≔ type_of(self) = sdml:EntityMember
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~EntityMember~, else ~false~.

#+BEGIN_EXAMPLE
def as_by_reference(EntityMember) → {0..1} ByReferenceMember
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def as_by_value(EntityMember) → {0..1} ByValueMember
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_by_reference(EntityMember) → boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def is_by_value(EntityMember) → boolean
#+END_EXAMPLE

*** Entity Events

*Class: Event*

#+BEGIN_EXAMPLE
def Event(self → _) → boolean
    ≔ type_of(self) = sdml:Event
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Event~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Event) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(Event) → Module
#+END_EXAMPLE

Returns the module that contains this model element's definition.

#+BEGIN_EXAMPLE
def flat_members(Event) → {ordered unique 0..} ByValueMember
#+END_EXAMPLE

Returns an unordered, unique, sequence of members contained within the event.

#+BEGIN_EXAMPLE
def groups(Event) → {ordered unique 0..} StructureGroup
#+END_EXAMPLE

Returns an unordered, unique, sequence of groups contained within the event.

#+BEGIN_EXAMPLE
def is_complete(self → Event) → boolean
    ≔ has_body(self)
    ∧ ∀ member ∈ flat_members(self) (is_complete(member))
#+END_EXAMPLE

Returns ~true~ if the structure definition is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def members(Event) → {ordered unique 0..} ByValueMember
#+END_EXAMPLE

Returns an unordered, unique, sequence of members contained within the event.

#+BEGIN_EXAMPLE
def name(Event) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def qualified_name(c → Constraint) → Identifier
    ≔ join(name(container(c)) name(c))
#+END_EXAMPLE

Return the qualified identifier naming this model element and it's containing module.

#+BEGIN_EXAMPLE
def source(Event) → IdentifierReference
#+END_EXAMPLE

*** Enumerations

*Class: Enumeration*

#+BEGIN_EXAMPLE
def Enumeration(self → _) → boolean
    ≔ type_of(self) = sdml:Enumeration
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Enumeration~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Enumeration) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(Enumeration) → Module
#+END_EXAMPLE

Returns the module that contains this model element's definition.

#+BEGIN_EXAMPLE
def is_complete(self → Enumeration) → boolean
    ≔ has_body(self)
#+END_EXAMPLE

Returns ~true~ if the enumeration definition is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def name(Enumeration) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def qualified_name(self → Constraint) → Identifier
    ≔ join(name(container(self)) name(self))
#+END_EXAMPLE

Return the qualified identifier naming this model element and it's containing module.

#+BEGIN_EXAMPLE
def variants(Enumeration) → {ordered unique 1..} ValueVariant
#+END_EXAMPLE

Returns an ordered, unique, sequence of variants contained within the enumeration.

*Class: ValueVariant*

#+BEGIN_EXAMPLE
def ValueVariant(self → _) → boolean
    ≔ type_of(self) = sdml:ValueVariant
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~ValueVariant~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(ValueVariant) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(ValueVariant) → Enumeration
#+END_EXAMPLE

Returns the enumeration that contains this variant's definition.

#+BEGIN_EXAMPLE
def name(ValueVariant) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def value(ValueVariant) → integer
#+END_EXAMPLE

*** Structures

*Class: Structure*

#+BEGIN_EXAMPLE
def Structure(self → _) → boolean
    ≔ type_of(self) = sdml:Structure
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Structure~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Structure) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(Structure) → Module
#+END_EXAMPLE

Returns the module that contains this model element's definition.

#+BEGIN_EXAMPLE
def flat_members(Structure) → {unique 0..} ByValueMember
#+END_EXAMPLE

Returns an unordered, unique, sequence of members contained within the structure and all of it's groups.

#+BEGIN_EXAMPLE
def groups(Structure) → {ordered unique 0..} StructureGroup
#+END_EXAMPLE

Returns an unordered, unique, sequence of groups contained within the structure.

#+BEGIN_EXAMPLE
def is_complete(self → Structure) → boolean
    ≔ has_body(self)
    ∧ ∀ member ∈ flat_members(self) (is_complete(member))
#+END_EXAMPLE

Returns ~true~ if the structure definition is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def members(Structure) → {ordered unique 0..} ByValueMember
#+END_EXAMPLE

Returns an unordered, unique, sequence of members contained within the structure.

#+BEGIN_EXAMPLE
def name(Structure) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def qualified_name(self → Structure) → Identifier
    ≔ join(name(container(self)) name(self))
#+END_EXAMPLE

Return the qualified identifier naming this model element and it's containing module.

*Class: StructureGroup*

#+BEGIN_EXAMPLE
def StructureGroup(self → _) → boolean
    ≔ type_of(self) = sdml:StructureGroup
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~StructureGroup~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(StructureGroup) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(StructureGroup) → Structure
#+END_EXAMPLE

Returns the structure that contains this group's definition.

#+BEGIN_EXAMPLE
def is_complete(self → StructureGroup) → boolean
    ≔ ∀ member ∈ members(self) (is_complete(member))
#+END_EXAMPLE

Returns ~true~ if the structure group is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def members(StructureGroup) → {ordered unique 0..} ByValueMember
#+END_EXAMPLE

Returns an unordered, unique, sequence of members contained within the structure group.

*** Disjoint Unions

*Class: Union*

#+BEGIN_EXAMPLE
def Union(self → _) → boolean
    ≔ type_of(self) = sdml:Union
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Union~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Union) → Bag of Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(Union) → Module
#+END_EXAMPLE

Returns the module that contains this model element's definition.

#+BEGIN_EXAMPLE
def is_complete(self → Union) → boolean
    ≔ has_body(self)
#+END_EXAMPLE

Returns ~true~ if the union definition is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def name(Union) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def qualified_name(self → Union) → Identifier
    ≔ join(name(container(self)) name(self))
#+END_EXAMPLE

Return the qualified identifier naming this model element and it's containing module.

#+BEGIN_EXAMPLE
def variants(Union) → {unique 0..} TypeVariant
#+END_EXAMPLE

Returns an unordered, unique, sequence of variants contained within the union.

*Class: TypeVariant*

#+BEGIN_EXAMPLE
def TypeVariant(self → _) → boolean
    ≔ type_of(self) = sdml:TypeVariant
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~TypeVariant~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(TypeVariant) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(TypeVariant) → Union
#+END_EXAMPLE

Returns the union that contains this variant's definition.

#+BEGIN_EXAMPLE
def is_renamed(PropertyRole) → boolean
#+END_EXAMPLE

Returns ~true~ if variant has a rename clause, else ~false~.

#+BEGIN_EXAMPLE
def name(TypeVariant) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element, this identifier *must* refer to a type definition.

#+BEGIN_EXAMPLE
def renamed_as(PropertyRole) → {0..1} Identifier
#+END_EXAMPLE

Returns the identifier representing the new name of the variant.

*** Property Definitions

*Class: Property*

#+BEGIN_EXAMPLE
def Property(self → _) → boolean
    ≔ type_of(self) = sdml:Property
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~Property~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(Property) → {0..} Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(Property) → Module
#+END_EXAMPLE

Returns the module that contains this model element's definition.

#+BEGIN_EXAMPLE
def is_complete(self → Property) → boolean
    ≔ self.body.present ∧ ∀ role in self.roles ( role.is_complete )
#+END_EXAMPLE

Returns ~true~ if the property definition is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def name(Property) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def qualified_name(self → Property) → Identifier
    ≔ join(name(container(self)) name(self))
#+END_EXAMPLE

Return the qualified identifier naming this model element and it's containing module.

#+BEGIN_EXAMPLE
def roles(Property) → {unique 0..} PropertyRole
#+END_EXAMPLE

Returns an unordered set of roles defined within this property.

*Class: Property Role*

#+BEGIN_EXAMPLE
def PropertyRole(self → _) → boolean
    ≔ type_of(self) = sdml:PropertyRole
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~PropertyRole~, else ~false~.

#+BEGIN_EXAMPLE
def annotations(PropertyRole) → Bag of Annotation
#+END_EXAMPLE

Returns an unordered sequence of annotations attached to this model element.

#+BEGIN_EXAMPLE
def container(PropertyRole) → Property
#+END_EXAMPLE

Returns the property that contains this role's definition.

#+BEGIN_EXAMPLE
def is_complete(self → PropertyRole) → boolean
    ≔ ¬(type_of(self) = Unknown)
#+END_EXAMPLE

Returns ~true~ if the property role definition is /complete/, else ~false~.

#+BEGIN_EXAMPLE
def name(PropertyRole) → Identifier
#+END_EXAMPLE

Returns the identifier naming this model element.

#+BEGIN_EXAMPLE
def source_cardinality(PropertyRole) → {0..1} Cardinality
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def target_type(PropertyRole) → Type
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def target_cardinality(PropertyRole) → Cardinality
#+END_EXAMPLE

*** Formal Constraints

TBD

*Class: FormalConstraint*

#+BEGIN_EXAMPLE
def FormalConstraint(_) → boolean
    ≔ type_of(self) = sdml:FormalConstraint
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~FormalConstraint~, else ~false~.

#+BEGIN_EXAMPLE
def environment(FormalConstraint) → {0..1} ConstraintEnvironment
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def sentence(FormalConstraint) → ConstraintSentence
#+END_EXAMPLE

*** Constraint Sentences

*Class: AtomicSentence*

TBD

#+BEGIN_EXAMPLE
def predicate(AtomicSentence) → Term
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def arguments(AtomicSentence) → {ordered 0..} Term
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def arity(AtomicSentence) → unsigned
#+END_EXAMPLE

*Union: BindingFromSequence*

TBD

*Class: BindingFromType*

TBD

*Union: BindingTarget*

TBD

*Enumeration: BinaryOperation*

TBD

#+BEGIN_EXAMPLE
BinaryOperation::Conjunction = 1
#+END_EXAMPLE

#+BEGIN_EXAMPLE
BinaryOperation::Disjunction = 2
#+END_EXAMPLE

#+BEGIN_EXAMPLE
BinaryOperation::ExclusiveDisjunction = 3
#+END_EXAMPLE

#+BEGIN_EXAMPLE
BinaryOperation::Implication = 4
#+END_EXAMPLE

#+BEGIN_EXAMPLE
BinaryOperation::Biconditional = 5
#+END_EXAMPLE

*Class: BinarySentence*

TBD

*Union: BooleanSentence*

TBD

*Union: ConstraintSentence*

TBD

*Class: EquationSentence*

TBD

#+BEGIN_EXAMPLE
def left_hand_side(EquationSentence) → Term
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def right_hand_side(EquationSentence) → Term
#+END_EXAMPLE

*Class: Negation*

TBD

*Union: QuantifiedSentence*

TBD

*Class: QuantifierBinding*

TBD

*Enumeration: QuantifierKind*

#+BEGIN_EXAMPLE
QuantifierKind::Existential = 1
#+END_EXAMPLE

#+BEGIN_EXAMPLE
QuantifierKind::Universal = 2
#+END_EXAMPLE

*Union: SimpleSentence*

TBD

*** Constraint Terms

*Class: BinaryExpression*

TBD

*Union: BooleanExpression*

TBD

*Union: Expression*

TBD

*Class: ExpressionBinding*

TBD

*Class: ExpressionNegation*

TBD

*Class: FunctionalTerm*

TBD

#+BEGIN_EXAMPLE
def arity(FunctionalTerm) → unsigned
#+END_EXAMPLE


*Class: ListOfPredicateValues*

TBD

*Class: NamePath*

TBD

*Union: PredicateValue*

TBD

*Union: ReturnValues*

TBD

*Class: SequenceComprehension*

TBD

*Union: Term*

TBD

*** Constraint Environment

*Class: ConstraintEnvironment*

#+BEGIN_EXAMPLE
def ConstraintEnvironment(_) → boolean
    ≔ type_of(self) = sdml:ConstraintEnvironment
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~ConstraintEnvironment~, else ~false~.

#+BEGIN_EXAMPLE
def bindings(ConstraintEnvironment) → {ordered 0..} EnvironmentBinding
#+END_EXAMPLE

*Class: CollectionType*

#+BEGIN_EXAMPLE
def CollectionType(_) → boolean
    ≔ type_of(self) = sdml:CollectionType
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~CollectionType~, else ~false~.

#+BEGIN_EXAMPLE
def sequence(CollectionType) → Type
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def element(CollectionType) → {0..1} Type
#+END_EXAMPLE

*Class: EnvironmentBinding*

#+BEGIN_EXAMPLE
def EnvironmentBinding(_) → boolean
    ≔ type_of(self) = sdml:EnvironmentBinding
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~EnvironmentBinding~, else ~false~.

#+BEGIN_EXAMPLE
def arity(EnvironmentBinding) → unsigned
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def name(EnvironmentBinding) → Identifer
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def signature(EnvironmentBinding) → {0..1} FunctionSignature
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def body(EnvironmentBinding) → EnvironmentBindingValue
#+END_EXAMPLE

*Union: EnvironmentBindingValue*

#+BEGIN_EXAMPLE
def EnvironmentBindingValue(_) → boolean
    ≔ type_of(self) = sdml:EnvironmentBindingValue
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~EnvironmentBindingValue~, else ~false~.

TBD

*Class: FunctionParameter*

#+BEGIN_EXAMPLE
def FunctionParameter(_) → boolean
    ≔ type_of(self) = sdml:FunctionParameter
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~FunctionParameter~, else ~false~.

#+BEGIN_EXAMPLE
def name(FunctionParameter) → {0..1} Identifier
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def type(FunctionParameter) → FunctionType
#+END_EXAMPLE

*Class: FunctionSignature*

#+BEGIN_EXAMPLE
def FunctionSignature(_) → boolean
    ≔ type_of(self) = sdml:FunctionSignature
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~FunctionSignature~, else ~false~.

#+BEGIN_EXAMPLE
def arity(FunctionSignature) → unsigned
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def parameters(FunctionSignature) → {ordered 1..} FunctionParameter
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def type(FunctionSignature) → FunctionType
#+END_EXAMPLE

*Union: FunctionType*

#+BEGIN_EXAMPLE
def FunctionType(_) → boolean
    ≔ type_of(self) = sdml:FunctionType
#+END_EXAMPLE

Returns ~true~ if the passed value is of type ~FunctionType~, else ~false~.

TBD

 
