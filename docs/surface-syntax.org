>#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* <<sec:surface-syntax>>Surface Syntax

This section describes the SDML surface syntax, a syntax intended to look and feel like a programming language but with
extensibility provided by it's underlying RDF and OWL foundation. The goal of the following syntax is to allow for rapid
capture of domain information but allowing elaboration of details over time. To this end we have made language features
optional wherever possible such that the minimum information neccessary is required to build a valid model. This
document will use the terms /valid/ to denote a model that has no syntactic errors and /complete/ to denote a valid model
that has no short-form, or /incomplete/, model elements.

For the complete grammar, and notes on BNF notation, see Appendix [[app:syntax]].

** Whitespace and Comments

This grammar chooses to use the JavaScript regular expression character class =\s= which includes the following values,
including all Unicode whitespace.

#+NAME: lst:grammar-whitespace
#+BEGIN_SRC ebnf
Whitespace      =
    "\f" | "\n" | "\r" | "\t" | "\v"
    | "\u{0020}" | "\u{00a0}" | "\u{1680}" | "\u{2000}".."\u{200a}"
    | "\u{2028}" | "\u{2029}" | "\u{202f}" | "\u{205f}" | "\u{3000}"
    | "\u{feff}"
#+END_SRC

Comments follow Lisp-like forms, starting with a semi-colon character and continuing to the end of line.

#+NAME: lst:grammar-line-comment
#+BEGIN_SRC ebnf
LineComment     = ";", ( -( "\r" | "\n" ) )*
#+END_SRC

#+NAME: lst:sdml-ex-comments
#+CAPTION: Comments
#+BEGIN_SRC sdml :exports code :noeval
; <- comments start here, end here ->
#+END_SRC

Lisp conventions for single, double, and triple comment characters are useful but in no way enforced.

#+NAME: lst:sdml-ex-comment-conventions
#+CAPTION: Comment Conventions
#+BEGIN_SRC sdml :exports code :noeval
;;; File-level comment
;; Comment at-point
; Comments in right margin
#+END_SRC

** Identifiers

An identifier is a string of characters corresponding to the Unicode General Category[fn:ucgc] *Lu* (an uppercase letter),
*Ll* (a lowercase letter), *Nd* (decimal digit), or the Unicode Low Line (underscore, "_", =U+005F=) character. Specifically
an identifer *must* start with and *must* begin and end with a letter such that the low line character may only appear
/within/ the identifier. The following is the BNF description of the identifier syntax.

#+NAME: lst:grammar-identifier
#+BEGIN_SRC ebnf
Identifier        = IdentifierInitial, IdentifierChar*, ( "_", IdentifierChar+ )*
IdentifierInitial = UC_LETTER_UPPER | UC_LETTER_LOWER
IdentifierChar    = IdentifierInitial | UC_NUMBER_DECIMAL
#+END_SRC
    
Naming Conventions:

- *Module Name* :: lower Camel Case; i.e. =xsd=, =skos=, =bank=, or =customer=. In general this should be a broad noun.
- *Structure/Entity/Event/Enum Name* :: Upper Camel Case; i.e. =Customer=, =Account=, =Address=, or =Name=. In general
  these are nouns related to, and often narrower than, the module name.
- *Data Type Name* :: Upper Camel Case; i.e. =ShortString=, =AccountNumber=, or =SocialSecurityNumber=. In general these are
  broad nouns, with either a property noun suffix as in =AccountNumber= or a qualifier noun prefix as in =ShortString=. Do
  not create capitalized acronym (SSN) or abbreviation (ID) forms unless these are universally understood within the
  domain.
- *Type Member Name* :: lower Camel Case; i.e. =street=, =accountName=, or =currentValue=. As in data type definitions these are
  broad nouns, with either a property noun suffix as in =accountNumber= or a qualifier noun prefix as in =shortName=. These
  are commonly simply the lower Camel Case version of the corresponding type name.
- *Enum and Union Variant Name* :: Upper Camel Case is the preferred, although SHOUTY CASE is acceptable.

*** Qualified Identifier

A qualified identifier comprises a module identifier followed by the Colon (":", =U+003A=) character and the identifier of a
member within that module.

#+NAME: lst:grammar-qualified-identifier
#+BEGIN_SRC ebnf
QualifiedIdentifier = Identifier, ":", Identifier
#+END_SRC

A type reference may be to a locally defined type by an identifier, or an imported type by a qualified identifier.

#+NAME: lst:grammar-identifier-reference
#+BEGIN_SRC ebnf
IdentifierReference = QualifiedIdentifier | Identifier
#+END_SRC

** <<sec:modules-and-imports>> Module Declaration and Imports

A module is the container for a set of type definitions and typically models a /Domain/ or /Sub-domain/. A single resource
(in the web sense of some /thing/ identified by an IRI) may contain only a single module. Therefore, the smallest valid
resource is one with an empty model.

#+NAME: lst:grammar-module
#+BEGIN_SRC ebnf
Module          = "module", Identifier, ModuleBase?, ModuleBody
ModuleBase      = "base", IriReference
ModuleBody      = "is", ImportStatement*, Annotation*, TypeDef*, "end"
#+END_SRC

An empty module (listing [[lst:sdml-ex-empty-module]]), specifically a module with an empty /body/ which is the content
between the keywords *=is=* and *=end=*.

#+NAME: lst:sdml-ex-empty-module
#+CAPTION: Empty Module
#+BEGIN_SRC sdml :exports code :noeval
module example is end
#+END_SRC

*** The base Specifier

The keyword =base= provides the base IRI for the module and corresponding RDF schema or OWL ontology. This corresponds to
the use of the =xml:base= attribute in RDF/XML and the =@base= directive in Turtle and SPARQL[fn:sparql]. This IRI is used
as a prefix for defined type names so that each type has a unique IRI. The example in listing
[[lst:sdml-ex-empty-module-base]] demonstrates the assigned IRI identifier for the structure type named ~Thing~.

#+NAME: lst:sdml-ex-empty-module-base
#+CAPTION: Empty Module with Base
#+BEGIN_SRC sdml :exports code :noeval
module example base <https://example.org/rdf/example#> is

  structure Thing
  ;; IRI: https://example.org/rdf/example#Thing

end
#+END_SRC

*** Importing Modules and Members

To import types from other modules you add one or more import statements to the module body. Each statement may
reference one or more module names or the qualified name of a type within a module.

#+NAME: lst:grammar-import-statement
#+BEGIN_SRC ebnf
ImportStatement = "import", ( Import | "[", Import+, "]" )
Import          = MemberImport | ModuleImport
MemberImport    = QualifiedIdentifier
ModuleImport    = Identifer
#+END_SRC


The module in listing [[lst:sdml-ex-import-module]] contains a single import statement /referencing/ the module named =xsd=
making it's members /visible/ in the qualified form =xsd:*=.

#+NAME: lst:sdml-ex-import-module
#+CAPTION: Importing Module
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xsd
end
#+END_SRC

The module in listing [[lst:sdml-ex-import-member]] contains a single import statement /referencing/ the member named =integer= from
the module =xsd= making it visible.

#+NAME: lst:sdml-ex-import-member
#+CAPTION: Importing Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xsd:integer
end
#+END_SRC

To reduce the number of import statements a list of identifiers, both module and member, may be /referenced/ as a list.
Listing [[lst:sdml-ex-import-list]] makes the members =author= and =title= from the module =dc= visible. Lists in SDML start
with the Left Square Bracket ("[", =U+005B=) character and end with the Right Square Bracket ("]", =U+005D=) character with
no separator character between members of the list.

#+NAME: lst:sdml-ex-import-list
#+CAPTION: Importing a List
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import [ dc:title dc:author ]
end
#+END_SRC

** Data Types and Values

A data /value/ is either a simple value, a value constructor expression, an identifier reference or a list of values.

#+NAME: lst:grammar-value
#+BEGIN_SRC ebnf
Value           =
    SimpleValue
    | ValueConstructor
    | IdentifierReference
    | ListOfValues
#+END_SRC

The inclusion of an identifier reference as a value allows for annotations whose value is another model element.

*** Simple Values

The core data types supported by SDML are ~boolean~, ~integer~, ~decimal~, ~double~, ~string~, (Language-Tagged String), and ~iri~
for IRI References. Values corresponding to these types are termed /simple values/.

#+NAME: lst:grammar-simple-value
#+BEGIN_SRC ebnf
SimpleValue     =
    String
    | Double
    | Decimal
    | Integer
    | Boolean
    | IriReference
#+END_SRC

A *Boolean* value in SDML is either the keyword ~true~ or ~false~.

#+NAME: lst:grammar-boolean
#+BEGIN_SRC ebnf
Boolean         = "true" | "false"
#+END_SRC

An *Integer* value in SDML is a string of ASCII decimal digits, without leading zeros; zero, =0=, is a valid value however
=00= and =01= are not. The Integer type corresponds to a 64-bit signed integer number.

#+NAME: lst:grammar-integer
#+BEGIN_SRC ebnf
Integer         = NumericSign?, Unsigned
Unsigned        = Zero | NonZero, ( ASCII_DIGIT )*
NumericSign     = "+" | "-"
Zero            = "0"
NonZero         = "1".."9"
#+END_SRC

A *Decimal* value in SDML is an integer-like value, followed by the Full Stop (".", =U+002E=) character and another
integer-like value. The Decimal type corresponds to a 128-bit representation of a fixed-precision decimal number.

#+NAME: lst:grammar-decimal
#+BEGIN_SRC ebnf
Decimal         = Integer, ".", ( ASCII_DIGIT )+
#+END_SRC

A *Double* value in SDML is a decimal-like value followed by a lower or upper case letter E (Latin Small Letter E, "e",
=U+0065= or Latin Capital Letter E, "E", =U+0045=), a sign character (Hyphen Minus, "-", =U+002D= or Plus Sign, "+", =U+002B=)
and an integer-like value. The Double type is a 64-bit floating point number (specifically, the "binary64" type defined
in IEEE 754-2008).

#+NAME: lst:grammar-double
#+BEGIN_SRC ebnf
Double          = Decimal, ExponentChar, NumericSign?, Integer
ExponentChar    = "e" | "E"
#+END_SRC

A *String* value in SDML is a sequence of Unicode characters starting and ending with a Quotation Mark ('"', =U+0022=) character. While
standard escape sequences allow for embedding non-printing characters. The form =\u{XXXX}=, where =X= is a single hex digit,
allows for the inclusion of any Unicode characters by their code point. Note that this form requires a minimum of 2 and
a maximum of 6 such digits. In addition,the following single-character escape characters are supported.

#+NAME: lst:grammar-string
#+BEGIN_SRC ebnf
String          = QuotedString, LanguageTag?
QuotedString    = "\"", ( -NotAllowed | CharacterEscape | UnicodeEscape )*, "\""
NotAllowed      = "\"" | "\\" | "\u{00}".."\u{08}" | "\u{0B}".."\u{1F}" | "\u{7F}"
CharacterEscape = "\\", ( "\"" | "\\" | "\/" | "a" | "b"
                          "e" | "f" | "n" | "r" | "t" | "v" )
UnicodeEscape   = "\\u{", HexPair, ( HexPair ( HexPair )? )?, "}"
HexPair         = ASCII_HEX_DIGIT, ASCII_HEX_DIGIT
LanguageTag     =
    "@", ASCII_LETTER_LOWER, ASCII_LETTER_LOWER, ASCII_LETTER_LOWER?
        ( "-", ASCII_LETTER_UPPER, ASCII_LETTER_UPPER, ASCII_LETTER_UPPER )?
        ( "-", ASCII_LETTER_UPPER, ASCII_LETTER_LOWER,
               ASCII_LETTER_LOWER, ASCII_LETTER_LOWER )?
        ( "-", ( ( ASCII_LETTER_UPPER, ASCII_LETTER_UPPER )
               | ( ASCII_DIGIT, ASCII_DIGIT, ASCII_DIGIT ) ) )
#+END_SRC

Note also that strings allow literal newlines and do not /require/ they be present in escaped form. This means that a
string literal supports multiline forms.

#+NAME: tbl:string-escape-characters
#+CAPTION: String Escape Characters
| Escape Character | Character Name (Common Name)          | Unicode Equivalent |
|------------------+---------------------------------------+--------------------|
| =\\=               | Reverse Solidus (Backslash)           | =\u{005C}=           |
| =\/=               | Solidus (Forward Slash)               | =\u{002F}=           |
| =\"=               | Quotation Mark                        | =\u{0022}=           |
| =\a=               | Bell                                  | =\u{0007}=           |
| =\b=               | Backspace                             | =\u{0008}=           |
| =\e=               | Escape                                | =\u{001B}=           |
| =\f=               | Form Feed (Page Break)                | =\u{000C}=           |
| =\n=               | Line Feed (New Line)                  | =\u{000A}=           |
| =\r=               | Carriage Return                       | =\u{000D}=           |
| =\t=               | Character Tabulation (Horizontal Tab) | =\u{0009}=           |
| =\v=               | Line Tabulation (Vertical Tab)        | =\u{000B}=           |

A *Language-Tagged String* value in SDML is a String as above but immediately followed by a Commercial At ("@", =U+0040=)
character and an unquoted string of characters that conform to a language identifier. Note that both components of such
a string contribute to equality tests, so that ="abc"@en= is not equal to ="abc"@fr=.

An *IRI Reference value* in SDML is a value IRI value, either absolute or relative, between a Less-Than Sign ("<", =U+003C=)
character and a Greater-Than Sign (">", =U+003E=) character. IRI references are more permissive in the SDML grammar than
the Turtle[fn:iri] language.

#+NAME: lst:grammar-iri-reference
#+BEGIN_SRC ebnf
IriReference    =
    "<",
    (
    - ("<" | ">" | "\"" | "{" | "}" | "|" | "^" | "`" | "\\" | "\u{00}".."\u{20}")
    | UnicodeEscape
    )*,
    ">"
#+END_SRC

See section [[sec:mapping-values]] for a more detailed description of values, literals, and data types.

*** Value Constructors

While the value =101= is defined to be an Integer literal, in the presence of sub-types how do you specify the type of a
literal? To accomplish this a /value constructor/ allows for specifying the precise type, or casting a value to a specific
type.

The syntax appears as a function call with a type reference followed by a valid /simple value/ surrounded by the Left
Parenthesis ("(", =U+0028=) and Right Parenthesis (")", =U+0029=) characters. The literal value MUST be valid for the
referenced type, or one of it's super-types.

#+NAME: lst:grammar-value-constructor
#+BEGIN_SRC ebnf
ValueConstructor    = IdentifierReference, "(", SimpleValue, ")"
#+END_SRC

Here we assert that the value =1= is an unsigned rather than the default signed integer.

#+NAME: lst:sdml-ex-type-constructor
#+CAPTION: Value Constructor Example
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import ex

  @ex:thing = xsd:unsigned(1)
end
#+END_SRC

You can ignore the syntax of ~@ex:thing~ which is an annotation, see section [[sec:annotations]], used to ensure the syntax is
complete for all examples.

*** Value Lists

As stated in section [[sec:modules-and-imports]], lists in SDML start with the Left Square Bracket ("[", =U+005B=)
character and end with the Right Square Bracket ("]", =U+005D=) character with no separator character between members of
the list. Value lists are, as one might expect, lists of values and specifically of simple values. Value lists are also
heterogeneous and may contain elements of different types.

#+NAME: lst:grammar-list-of-values
#+BEGIN_SRC js :noeval
ListOfValues    =
    "[", ( SimpleValue | ValueConstructor | IdentifierReference )+, "]"
#+END_SRC

#+NAME: lst:sdml-ex-value-lists
#+CAPTION: Value List Example
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import ex

  @ex:thing = [ "yes" "no" "maybe" ]
end
#+END_SRC

*** Defining Data Types

A datatype definition introduces a new simple data type by /restriction/ of some existing base type.

#+NAME: lst:grammar-data-type-def
#+BEGIN_SRC ebnf
DataTypeDef     =
    "datatype", Identifier, "<-", DataTypeBase, AnnotationOnlyBody?
DataTypeBase    = BuiltinSimpleType | IdentifierReference
BuiltinSimpleType   = 
    "string" | "double" | "decimal" | "integer" | "boolean" | "iri"
#+END_SRC

Listing [[lst:sdml-ex-datatype]] shows the /type restriction/ operator, =<-=, defining a new type named ~name~ as a restriction on
the existing XML Schema data type ~xsd:string~.

#+NAME: lst:sdml-ex-datatype
#+CAPTION: New Datatype
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import ex

  datatype Name <- string
end
#+END_SRC

While such a type is useful for conveying semantic meaning with types it doesn't provide any actual restriction on the
value space of the type. This is accomplished by using a subset of the /facets/ described in XML Schema part 2 to specify
constraints on the new type. For example, in listing [[lst:sdml-ex-restricted-datatype]] we now see that the Name type
is a string whose length is between 5 and 25 characters only.

#+NAME: lst:sdml-ex-restricted-datatype
#+CAPTION: New Datatype with Restrictions
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import ex

  datatype Name <- string is
    @xsd:minLength = 5
    @xsd:maxLength = 25
  end
end
#+END_SRC

From OWL 2 Web Ontology Language Quick Reference Guide[fn:owlqr]:

#+NAME: tbl:owl-facets
#+CAPTION: OWL Built-in Datatype Facets
| Facet                                                                  | Value                                      | Applicable Datatypes       | Explanation                                                                                |
|------------------------------------------------------------------------+--------------------------------------------+----------------------------+--------------------------------------------------------------------------------------------|
| =xsd:minInclusive=, =xsd:maxInclusive=, =xsd:minExclusive=, =xsd:maxExclusive= | literal in the corresponding datatype      | Numbers, Time Instants     | Restricts the value-space to greater than (equal to) or lesser than (equal to) a value     |
| =xsd:minLength=, =xsd:maxLength=, =xsd:length=                               | Non-negative integer                       | Strings, Binary Data, IRIs | Restricts the value-space based on the lengths of the literals                             |
| =xsd:pattern=                                                            | =xsd:string= literal as a regular expression | Strings, IRIs              | Restricts the value space to literals that match the regular expression                    |
| =rdf:langRange=                                                          | =xsd:string= literal as a regular expression | =rdf:PlainLiteral=           | Restricts the value space to literals with language tags that match the regular expression |

*** The Built-in Simple Types

In the preceding sections we introduced the set of built-in simple types: string, double, decimal, integer, boolean, and
iri. These are keywords in SDML and have specific rules applied when parsing. Each keyword is translated into a
qualified identifier where the module name is the reserved name =sdml=. This set of standard library types have an
underlying RDFOWL equivalence relationship to a subset of the XML Schema datatypes, all shown in table
[[tbl:builtin-simple-types]].

#+NAME: tbl:builtin-simple-types
#+CAPTION: Built-in Simple Type Mapping
| Type Keyword | Qualified Identifier | Equivalent XML Schema Datatype |
|--------------+----------------------+--------------------------------|
| ~string~       | ~sdml:string~          | ~xsd:string~                     |
| ~double~       | ~sdml:double~          | ~xsd:double~                     |
| ~decimal~      | ~sdml:decimal~         | ~xsd:decimal~                    |
| ~integer~      | ~sdml:integer~         | ~xsd:integer~                    |
| ~boolean~      | ~sdml:boolean~         | ~xsd:boolean~                    |
| ~iri~          | ~sdml:iri~             | ~xsd:anyURI~                     |

** <<sec:annotations>>Annotations

Annotations are an extension mechanism that interacts directly with the underlying RDF representation of the subject
model element. While these may look like Java /annotations/, Python /decorators/, or Rust /attributes/ it is more powerful in
that it can express arbitrary statements about the model element. An SDML annotation starts with the symbol "@" and then
has an identifier that resolves to an OWL annotation property (see section [[sec:define-rdf]] for the detailed rules), and a
value for the corresponding property range.

#+NAME: lst:grammar-annotation
#+BEGIN_SRC ebnf
Annotation      = "@", IdentiferReference, "=", Value
#+END_SRC

*Example:*

The following example demonstrates a common annotation attached to a module.

#+NAME: lst:sdml-ex-annotation-property
#+CAPTION: Annotation Property
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import skos

  @skos:note = "This is an example annotation"
end
#+END_SRC

*Example:*

#+NAME: lst:sdml-ex-annotation-property-list
#+CAPTION: Annotation Property List
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import skos

  @skos:prefLabel = [
    "example"@en
    "exemple"@fr
    "例子"@zh-CH
  ]
end
#+END_SRC

*Example:*

#+NAME: lst:sdml-ex-annotated-module
#+CAPTION: Annotated Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ dc skos ]

  @dc:description = "This is an example module, with two annotations"
  @skos:prefLabel = "Example Module"@en

end
#+END_SRC

From [[https://www.w3.org/TR/owl-ref/#AnnotationProperty-def][OWL Web Ontology Language Reference]], Appendix E: Rules of Thumb for OWL DL ontologies:

#+BEGIN_QUOTE
If a property =a= is used where an annotation property is expected then it should either be one of the built in
annotation properties (=owl:versionInfo=, =rdfs:label=, =rdfs:comment=, =rdfs:seeAlso=, and =rdfs:isDefinedBy=) or there
should be a triple:

=a rdf:type owl:AnnotationProperty=
#+END_QUOTE

*** <<sec:define-rdf>> Defining RDF Classes and Properties

In general only properties that have an RDF type of =owl:AnnotationProperty=, or are sub-properties of such a property,
may appear as annotations. This maintains the assertion that they are annotations of their subject and allows the use of
a range of pre-defined annotation properties from RDF, RDF Schema, OWL, and the Dublin Core Metadata Initiative
(DCMI)[fn:dcmi].

For example the annotation property =rdfs:comment= is defined in the following manner allowing it's use on any resource
and with a value that may be any literal.

#+NAME: lst:rdfs-comment
#+CAPTION: The definition of rdfs:comment
#+BEGIN_SRC ttl
rdfs:comment rdf:type rdf:Property, owl:AnnotationProperty ;
	rdfs:isDefinedBy <http://www.w3.org/2000/01/rdf-schema#> ;
	rdfs:label "comment" ;
	rdfs:comment "A description of the subject resource." ;
	rdfs:domain rdfs:Resource ;
	rdfs:range rdfs:Literal .
#+END_SRC

To allow the standard library to define SDML equivalents of such properties it is necessary to provide a mechanism to
use non-annotation properties such as =rdf:type=, =rdfs:domain=, and =rdfs:range= as demonstrated in the example above. To
allow this, if a model element has the property =rdf:type= then the transformation from that element to RDF *does not* use
any of the transformations described here but an explicit mapping from *only* the provided properties.

Rewriting the RDF from listing [[lst:rdfs-comment]] into SDML results in the definition in listing [[lst:rdfs-comment-in-sdml]].

#+NAME: lst:rdfs-comment-in-sdml
#+CAPTION: The SDML definition of rdfs:comment
#+BEGIN_SRC sdml :exports code :noeval
module rdfs is
  structure comment is
    @rdf:type = [ rdf:Property owl:AnnotationProperty ]
    @isDefinedBy = <http://www.w3.org/2000/01/rdf-schema#>
    @label = "comment"
    @comment = "A description of the subject resource."
    @domain = Resource
    @range = Literal
  end
end
#+END_SRC

The following are commonly used RDF and OWL definition properties.

- =rdf:type= --
- =rdfs:domain= and =rdfs:range= --
- =rdfs:subClassOf= and =rdfs:subPropertyOf= --
- =owl:equivalentClass= and =owl:equivalentProperty= --
- =owl:inverseOf= --
- =owl:disjointWith= --
- =owl:FunctionalProperty=, =owl:InverseFunctionalProperty=, =owl:SymmetricProperty= and =owl:TransitiveProperty= --

** Structured Types

Structured types fall into two primary categories, /Product/ types and /Sum/ types. Product types have named and typed
/Members/ and in SDML these are structures, entities and events. Sum types on the other hand have /Variants/ and in SDML
these are enumerations and disjoint unions. In the surface syntax product type bodies are introduced by the keyword ~is~
whereas sum type bodies are introduced by the keyword ~of~.

Along with the previously described datatype these comprise the set of type definitions available in SDML; this is
represented in listing [[lst:grammar-type-def]].

#+NAME: lst:grammar-type-def
#+BEGIN_SRC ebnf
TypeDef         =
    DataTypeDef
    | EntityDef
    | EnumDef
    | EventDef
    | StructureDef
    | UnionDef
#+END_SRC

*** Members

Structured type members fall into the following categories.

- Identity :: A particular kind of member only available on entities, and required by them, to name the identifier for
  that entity type.
- By-Value :: A reference to a value type, i.e. Enumeration, Event, or Structure. Such a member may indicate the
  cardinality of the target.
- By-Reference :: A reference to an Entity type. Such a member may indicate the cardinality of both the source and the
  target.
- Variant :: A member within an enumeration that specifies a numeric value for each member rather than a type.
- *Type Variant* :: A type reference that is a unique variant of a disjoint union.

#+NAME: lst:grammar-members
#+BEGIN_SRC ebnf
IdentityMember      =
    "identity", Identifier, TypeExpression, AnnotationOnlyBody?
MemberByValue       =
    Identifier, TypeExpressionTo, AnnotationOnlyBody?
MemberByReference   =
    "ref", Identifier, TypeExpressionFromTo,AnnotationOnlyBody?
#+END_SRC

For identity, by-value, and by-reference members the general syntax uses the /type reference/ operator, /name/ ~->~ /type/, with
additional keywords and cardinality included as follows.

#+NAME: tbl:member-summary
#+CAPTION: Summary of Member Formats
| Kind         | Keyword  | From-Cardinality | To-Cardinality | Target Types                     |
|--------------+----------+------------------+----------------+----------------------------------|
| Identity     | ~identity~ | No               | No             | Enumeration, Event, or Structure |
| By-Value     |          | No               | Yes            | Enumeration, Event, or Structure |
| By-Reference | ~ref~      | Yes              | Yes            | Entity                           |

Additionally, to allow for the capture of member names before the elaboration of all types the language allows for the
target type to be replaced with the keyword ~unknown~. This marks the member, and by extension it's owning type, as
/incomplete/.

#+NAME: lst:grammar-type-expressions
#+BEGIN_SRC ebnf
TypeExpression          = "->" TypeReference
TypeExpressionTo        = "->" Cardinality? TypeReference
TypeExpressionFromto    = Cardinality? TypeExpressionTo
TypeReference           = UnknownType | IdentifierReference | BuiltinSimpleType
UnknownType             = "unknown"
#+END_SRC

The cardinality of a member is specified as a range operation with a minimum and maximum number of occurrences
specified.

- The form ~{1..3}~ specifies a cardinality of 1 to 3 inclusive, or $[1,3]$ in interval notation.
- The form ~{1..}~ specifies a minimum of 1 occurrences an unbounded maximum, or $[1,\infty]$ in interval notation.
- The form ~{1}~ specifies that 1 is both the minimum and maximum value, or $[1,1]$ in interval notation, commonly termed
  a /degenerate/ interval.

#+NAME: lst:grammar-cardinality
#+BEGIN_SRC ebnf
CardinalityExpression   = "{", Unsigned, CardinalityRange?, "}"
CardinalityRange        = "..", Unsigned?
#+END_SRC

*** Structures

A structure is a product type that is composed of named and typed members. A structure is therefore akin to a record
type, a table in data modeling, or a class in object modeling.

#+NAME: lst:grammar-structure-def
#+BEGIN_SRC ebnf
StructureDef    = "structure", Identifier, StructureBody?
#+END_SRC

*Example*:

As only the keyword ~structure~ and the identifier are required, the listing [[lst:sdml-ex-empty-structure]] is therefore a
valid model.

#+NAME: lst:sdml-ex-empty-structure
#+CAPTION: Empty Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length
end
#+END_SRC

The structure ~Length~ in listing [[lst:sdml-ex-empty-structure]] is /valid/ but considered incomplete. Adding a body to the
structure, between ~is~ and ~end~, makes it complete even if it has no actual members. In listing
[[lst:sdml-ex-annotated-structure]] the structure Length is now complete.


#+NAME: lst:grammar-structure-body
#+BEGIN_SRC ebnf
StructureBody   = "is", Annotation*, ( MemberByValue | StructureGroup )*, "end"
#+END_SRC

*Example*:

#+NAME: lst:sdml-ex-annotated-structure
#+CAPTION: Annotated Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length is
    @skos:prefLabel = "Length"@en
  end
end
#+END_SRC

*Example*:

Listing [[lst:sdml-ex-structure-members]] adds the members ~value~ and ~unit~ and their corresponding types.

#+NAME: lst:sdml-ex-structure-members
#+CAPTION: Structure Members
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length is
    @skos:prefLabel = "Length"@en

    value -> Decimal
    unit -> DistanceUnit
  end
end
#+END_SRC

In listing [[lst:sdml-ex-structure-groups]] we see a more complex structure with both members and groups.

#+NAME: lst:grammar-structure-group
#+BEGIN_SRC ebnf
StructureGroup  = "group", Annotation*, MemberByValue*, "end"
#+END_SRC

*Example*:

#+NAME: lst:sdml-ex-structure-groups
#+CAPTION: Structure Members and Groups
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Account is
    @skos:prefLabel = "Customer Account"@en

    group
      @skos:prefLabel = "Metadata"
      created -> xsd:dateTime
      lastModified -> xsd:dateTime
    end

    group
      @skos:prefLabel = "Customer Information"
      ref customer -> {1..1} Customer
    end
  end

end
#+END_SRC

*** Entities

#+NAME: lst:grammar-entity-def
#+BEGIN_SRC ebnf
EntityDef       = "entity", Identifier, EntityBody?
EntityBody      =
    "is",
    Annotation*,
    IdentityMember,
    ( MemberByValue | MemberByReference | EntityGroup )*,
    "end"
EntityGroup     = "group", Annotation*, ( MemberByValue | MemberByReference )*
#+END_SRC

*Example*:

#+NAME: lst:sdml-ex-empty-entity
#+CAPTION: Empty Entity
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person
end
#+END_SRC

The entity ~Person~ in listing [[lst:sdml-ex-empty-entity]] is /valid/ but /incomplete/.

*Example*:

#+NAME: lst:sdml-ex-entity-identifying-member
#+CAPTION: Entity with Identifying Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person is
    identity id -> PersonId
  end
end
#+END_SRC

The ~identity~ member is a required part of the entity definition, it not only tells us what type represents the unique
identifier for this entity but is also used in ~ref~ members and event sources (see section [[sec:entity-events]]). In the
case of a ~ref~ member the target entity, in our example =Person= is not included in the entity's structure, it's identifier
type, =PersonId= is instead.

#+NAME: lst:sdml-ex-entity-ref-member
#+CAPTION: Entity with Reference Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person is
    identity id -> PersonId

    ref contact {0..} -> {0..2} Person is
      @dc:description = "Emergency contact person"
    end
  end
end
#+END_SRC

*** <<sec:entity-events>>Entity Events

Entity Events, or simply Events, model notifications generated by an entity most often representing a state change in the entity.
As such a ~source~ reference denotes the entity which generates this event. Any expansion of the event structure *must* include the
identifiers of the source entity.

#+NAME: lst:grammar-event-def
#+BEGIN_SRC ebnf
EventDef        =
    "event", Identifier,
    "source", IdentifierReference,
    StructureBody?
#+END_SRC

*Example*:

#+NAME: lst:sdml-ex-empty-event
#+CAPTION: Empty Event
#+BEGIN_SRC sdml :exports code :noeval
module example is
  event PersonNameChanged source Person
end
#+END_SRC

With the expansion of the ~source~ entity the event definition above is logically equivalent to the following structure.

#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure PersonNameChanged is
    id -> PersonId is
      sdml:identifies Person
    end
  end
end
#+END_SRC

As we have seen before, the event ~PersonNameChanged~ in listing [[lst:sdml-ex-empty-event]] is valid but incomplete.

*Example*:

The following is a valid /and/ complete event definition with two structure members.

#+NAME: lst:sdml-ex-event
#+CAPTION: Event
#+BEGIN_SRC sdml :exports code :noeval
module example is
  event PersonNameChanged source Person is
    fromValue -> Name
    toValue -> Name
  end
end
#+END_SRC

*** Enumerations

An enumeration is a numeric type that expressly names the values it may take. This is a restricted form of the =enum= type
found in most languages as not only *must* all names be unique but all names *must* specify a value *and* all values *must* also
be unique. Note also that the keyword =of= and not =is= starts an enumeration body.

#+NAME: lst:grammar-enum-def
#+BEGIN_SRC ebnf
EnumDef         = "enum", Identifier, EnumBody?
EnumBody        = "of", Annotation*, EnumVariant*, "end"
#+END_SRC

*Example*:

#+NAME: lst:sdml-ex-empty-enum
#+CAPTION: Empty Enum
#+BEGIN_SRC sdml :exports code :noeval
module example is
  enum DistanceUnit
end
#+END_SRC

The enumeration ~DistanceUnit~ in [[lst:sdml-ex-empty-enum]] is valid but incomplete. Completion of the enumeration requires
the addition of a body with enumeration variants.

#+NAME: lst:grammar-enum-variant
#+BEGIN_SRC ebnf
EnumVariant     = Identifier, "=", Unsigned, AnnotationOnlyBody?
#+END_SRC

*Example*:

The following demonstrates a valid /and/ complete enumeration.

#+NAME: lst:sdml-ex-enum
#+CAPTION: Enum With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is
  enum DistanceUnit of
    Meter = 1
    Foot = 2
  end
end
#+END_SRC

*** Disjoint Unions

A disjoint, or discriminated, union is a mechanism to allow for a selection of disjoint types to be treated as a single
type. As such the /variants/ of the union are simply type references, although they do allow annotations. Note also that
the keyword =of= and not =is= starts a union body.

#+NAME: lst:grammar-union-def
#+BEGIN_SRC ebnf
UnionDef        = "union", Identifier, UnionBody?
UnionBody       = "of", Annotation*, TypeVariant*, "end"
#+END_SRC

*Example*:

#+NAME: lst:sdml-ex-empty-union
#+CAPTION: Empty Union
#+BEGIN_SRC sdml :exports code :noeval
module example of
  union VehicleClass
end
#+END_SRC

The union ~VehicleClass~ in [[lst:sdml-ex-empty-union]] is valid but incomplete. Completion of the union requires the addition
of a body with type variants.

#+NAME: lst:grammar-type-variant
#+BEGIN_SRC ebnf
TypeVariant         = IdentifierReference TypeVariantRename? AnnotationOnlyBody?
TypeVariantRename   = "as" Identifier
#+END_SRC

*Example*:

The following is a valid /and/ complete example with three type variants and one that is renamed from =Van= to =LittleTruck=.

#+NAME: lst:sdml-ex-union
#+CAPTION: Union With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is
  union VehicleClass of
    Car
    Truck
    Van as LittleTruck
  end
end
#+END_SRC

# ----- Footnotes

[fn:dcmi] [[https://www.dublincore.org/specifications/dublin-core/dcmi-terms/][DublinCoreDCMI Metadata Terms]], DublinCore
[fn:ucgc] [[https://unicode.org/reports/tr44/#GC_Values_Table][Unicode General Category]], Unicode.org
[fn:iri] RDF 1.1 Turtle – Terse RDF Triple Language, §[[https://www.w3.org/TR/turtle/#sec-iri-references][6.3 IRI References]], W3C
[fn:sparql] [[https://www.w3.org/TR/sparql11-overview/][SPARQL 1.1 Overview]], W3C
[fn:owlqr] [[https://www.w3.org/2007/OWL/wiki/Quick_Reference_Guide][OWL 2 Web Ontology Language Quick Reference Guide
(Second Edition)]], W3C
