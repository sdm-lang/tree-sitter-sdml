#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* <<sec:surface-syntax>>The Surface Syntax

This section describes the SDML surface syntax, a syntax intended to look and feel like a programming language but with
extensibility provided by it's underlying RDF and OWL foundation. The goal of the following syntax is to allow for rapid
capture of domain information but allowing elaboration of details over time. To this end we have made language features
optional wherever possible such that the minimum information neccessary is required to build a valid model. This
document will use the terms /valid/ to denote a model that has no syntactic errors and /complete/ to denote a valid model
that has no short-form, or /incomplete/, model elements.

For the complete grammar, and notes on BNF notation, see section [[sec:complete-grammar]].

** Whitespace and Comments

This grammar chooses to use the JavaScript regular expression character class =\s= which includes the following values,
including all Unicode whitespace.

#+NAME: lst:grammar-whitespace
#+BEGIN_SRC ebnf
Whitespace      ::=
    [^\f\n\r\t\v#x20#xa0#x1680#x2000#x200a#x2028#x2029#x202f#x205f#x3000#xfeff]
#+END_SRC

Comments follow Lisp-like forms, starting with a semi-colon character and continuing to the end of line. Comments are
intended to capture only information regarding the file contents and not model contents. Because of this, parsers are
*not* required to capture comments, and tools are *not* required to emit comments back into changed files. For model-related
comments relevant annotations should be attached to the model elements.

#+NAME: lst:grammar-line-comment
#+BEGIN_SRC ebnf
LineComment     ::= ";" [^\r\n]*
#+END_SRC

[[./ebnf-diagram/LineComment.svg]]

#+CAPTION: Comments
#+BEGIN_SRC sdml :exports code :noeval
; <- comments start here and end here ->
#+END_SRC

In the following example a tool reading the following file is not required to preserve the comment, which in this case
is OK as the ~editorialNote~ is preserved and correctly used for the same purpose.

#+CAPTION: Comments
#+BEGIN_SRC sdml :exports code :noeval
module foo is
  import [dc skos]

  ; Should come up with a better name.
  @skos:prefLabel = "Foo"@en
  @dc:description = "Here's a descriptive comment"
  @skos:editorialNode = "Someone should fix the name"
end
#+END_SRC

** Identifiers

An identifier is a string of characters corresponding to the Unicode General Category[fn:ucgc] *Lu* (an uppercase letter),
*Ll* (a lowercase letter), *Nd* (decimal digit), or the Unicode Low Line (underscore, "_", =U+005F=) character. Specifically
an identifer *must* start with and *must* begin and end with a letter such that the low line character may only appear
/within/ the identifier. The following is the BNF description of the identifier syntax.

#+NAME: lst:grammar-identifier
#+BEGIN_SRC ebnf
Identifier          ::= IdentifierInitial IdentifierChar* ( "_" IdentifierChar+ )*
#+END_SRC

[[./ebnf-diagram/Identifier.svg]]

#+BEGIN_SRC ebnf
IdentifierInitial   ::= UC_LETTER_UPPER | UC_LETTER_LOWER
#+END_SRC

[[./ebnf-diagram/IdentifierInitial.svg]]

#+BEGIN_SRC ebnf
IdentifierChar      ::= IdentifierInitial | UC_NUMBER_DECIMAL
#+END_SRC

[[./ebnf-diagram/IdentifierChar.svg]]

Naming Conventions:

- *Module Name* :: lower Camel Case; i.e. =xsd=, =skos=, =bank=, or =customer=. In general this should be a broad noun.
- *Structure/Entity/Event/Enum Name* :: Upper Camel Case; i.e. =Customer=, =Account=, =Address=, or =Name=. In general
  these are nouns related to, and often narrower than, the module name.
- *Data Type Name* :: Upper Camel Case; i.e. =ShortString=, =AccountNumber=, or =SocialSecurityNumber=. In general these are
  broad nouns, with either a property noun suffix as in =AccountNumber= or a qualifier noun prefix as in =ShortString=. Do
  not create capitalized acronym (SSN) or abbreviation (ID) forms unless these are universally understood within the
  domain.
- *Type Member Name* :: lower Camel Case; i.e. =street=, =accountName=, or =currentValue=. As in data type definitions these are
  broad nouns, with either a property noun suffix as in =accountNumber= or a qualifier noun prefix as in =shortName=. These
  are commonly simply the lower Camel Case version of the corresponding type name.
- *Enum and Union Variant Name* :: Upper Camel Case is the preferred, although SHOUTY CASE is acceptable.

*** Qualified Identifier

A qualified identifier comprises a module identifier followed by the Colon (":", =U+003A=) character and the identifier of a
member within that module.

#+NAME: lst:grammar-qualified-identifier
#+BEGIN_SRC ebnf
QualifiedIdentifier ::= Identifier ":" Identifier
#+END_SRC

[[./ebnf-diagram/QualifiedIdentifier.svg]]

A type reference may be to a locally defined type by an identifier, or an imported type by a qualified identifier.

#+NAME: lst:grammar-identifier-reference
#+BEGIN_SRC ebnf
IdentifierReference ::= QualifiedIdentifier | Identifier
#+END_SRC

[[./ebnf-diagram/IdentifierReference.svg]]

** <<sec:modules-and-imports>> Module Definition and Imports

A module is the container for a set of type definitions and typically models a /Domain/ or /Sub-domain/. A single resource
(in the web sense of some /thing/ identified by an IRI) may contain only a single module. Therefore, the smallest valid
resource is one with an empty model.

#+NAME: lst:grammar-module
#+BEGIN_SRC ebnf
Module              ::= "module" Identifier ModuleBase? ModuleBody
#+END_SRC

[[./ebnf-diagram/Module.svg]]

An empty module (listing [[lst:sdml-ex-empty-module]]), specifically a module with an empty /body/ which is the content
between the keywords *=is=* and *=end=*.

#+NAME: lst:sdml-ex-empty-module
#+CAPTION: Empty Module
#+BEGIN_SRC sdml :exports code :noeval
module example is end
#+END_SRC

*** The base Specifier

#+BEGIN_SRC ebnf
ModuleBase          ::= "base" IriReference
#+END_SRC

[[./ebnf-diagram/ModuleBase.svg]]

The keyword =base= provides the base IRI for the module and corresponding RDF schema or OWL ontology. This corresponds to
the use of the =xml:base= attribute in RDF/XML and the =@base= directive in Turtle and SPARQL[fn:sparql]. This IRI is used
as a prefix for defined type names so that each type has a unique IRI. The example in listing
[[lst:sdml-ex-empty-module-base]] demonstrates the assigned IRI identifier for the structure type named ~Thing~.

#+NAME: lst:sdml-ex-empty-module-base
#+CAPTION: Empty Module with Base
#+BEGIN_SRC sdml :exports code :noeval
module example base <https://example.org/rdf/example#> is

  structure Thing
  ;; IRI: https://example.org/rdf/example#Thing

end
#+END_SRC

*Module URI Resolution*

Each module has an identifer/name defined within the module source as well as a base URI used to assign URIs to every
model element within the resource. This URI identifier for each model element necessary as the identifier for the
corresponding RDF resource(s). Our first problem is to determine the base URI for the module,as follows:

1. If the module has a ~base~ specifier it MUST be used as the module URI.
2. If the reader has access to an SDML catalog file (For details of the catalog file format see appendix [[sec:resolver-catalog]]), a matching catalog entry MUST be used as the module URI.
3. A URI is calculated for the module using the =file:= scheme and the file path relative to a /project root/.

Considering the following simple module in the file =vehicle.sdm=.

#+BEGIN_SRC sdml :exports code :noeval
module vehicle is end
#+END_SRC

If the following file is in the same directory as the vehicle module it is possible to   

#+BEGIN_SRC json :noeval
{
  "base": "https://example.org/rentals/",
  "entries": {
    "rentals": {
      "item": {
        "relative_name": "vehicle#",
        "relative_path": "vehicle-v1.sdm"
      }
    }
  }
}
#+END_SRC

*** Importing Modules and Members

#+BEGIN_SRC ebnf
ModuleBody          ::= "is" ImportStatement* Annotation* Definition* "end"
#+END_SRC

[[./ebnf-diagram/ModuleBody.svg]]

To import types from other modules you add one or more import statements to the module body. Each statement may
reference one or more module names or the qualified name of a type within a module.

#+NAME: lst:grammar-import-statement
#+BEGIN_SRC ebnf
ImportStatement     ::= "import" ( Import | "[" Import+ "]" )
#+END_SRC

[[./ebnf-diagram/ImportStatement.svg]]

#+BEGIN_SRC ebnf
Import              ::= MemberImport | ModuleImport
#+END_SRC

[[./ebnf-diagram/Import.svg]]

#+BEGIN_SRC ebnf
ModuleImport        ::= Identifer
#+END_SRC

[[./ebnf-diagram/ModuleImport.svg]]

#+BEGIN_SRC ebnf
MemberImport        ::= QualifiedIdentifier
#+END_SRC

[[./ebnf-diagram/MemberImport.svg]]

The module in listing [[lst:sdml-ex-import-module]] contains a single import statement /referencing/ the module named =xsd=
making it's members /visible/ in the qualified form =xsd:*=.

#+NAME: lst:sdml-ex-import-module
#+CAPTION: Importing Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import xsd

end
#+END_SRC

The module in listing [[lst:sdml-ex-import-member]] contains a single import statement /referencing/ the member named =integer= from
the module =xsd= making it visible.

#+NAME: lst:sdml-ex-import-member
#+CAPTION: Importing Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import xsd:integer

end
#+END_SRC

To reduce the number of import statements a list of identifiers, both module and member, may be /referenced/ as a list.
Listing [[lst:sdml-ex-import-list]] makes the members =author= and =title= from the module =dc= visible. Lists in SDML start
with the Left Square Bracket ("[", =U+005B=) character and end with the Right Square Bracket ("]", =U+005D=) character with
no separator character between members of the list.

#+NAME: lst:sdml-ex-import-list
#+CAPTION: Importing a List
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ dc:title dc:author ]

end
#+END_SRC

*** Definitions

#+NAME: lst:sdml-type-model
#+BEGIN_SRC dot :file sdml-type-model.svg :exports results
strict digraph {
   bgcolor="transparent";
   rankdir=BT;
   fontname="Helvetica,Arial,sans-serif";
   node [shape="rect"; fontname="Helvetica,Arial,sans-serif"; fontsize=10; width=1.0; height=0.4];
   edge [arrowhead=onormal; fontname="Helvetica,Arial,sans-serif"; fontsize=9; fontcolor="darkgrey"];
   
   Type [label="Any"];
   Scalar -> Type;
   Scalar [color="grey"; fontcolor="grey"];
   Datatype -> Scalar;
   Sum [color="grey"; fontcolor="grey"];
   Sum -> Type;
   Enumeration -> Sum;
   Union -> Sum;
   Product [color="grey"; fontcolor="grey"];
   Product -> Type;
   Entity -> Product;
   Event -> Product;
   Structure -> Product;
   Unknown -> Type [label="disjoint"];
}
#+END_SRC

#+NAME: fig:sdml-type-model
#+CAPTION: The SDML Type Model
#+RESULTS: lst:sdml-type-model
[[file:sdml-type-model.svg]]

#+BEGIN_SRC ebnf
Definition          ::=
    DataTypeDef | EntityDef | EnumDef | EventDef | StructureDef | UnionDef | PropertyDef
#+END_SRC

[[./ebnf-diagram/Definition.svg]]

** Data Types and Values

A data /value/ is either a simple value, a value constructor expression, an identifier reference or a list of values.

#+NAME: lst:grammar-value
#+BEGIN_SRC ebnf
Value               ::=
    SimpleValue | ValueConstructor | IdentifierReference | ListOfValues
#+END_SRC

[[./ebnf-diagram/Value.svg]]

The inclusion of an identifier reference as a value allows for annotations whose value is another model element.

*** Simple Values

The core data types supported by SDML are ~boolean~, ~integer~, ~decimal~, ~double~, ~string~, (Language-Tagged String), and ~iri~
for IRI References. Values corresponding to these types are termed /simple values/.

#+NAME: lst:grammar-simple-value
#+BEGIN_SRC ebnf
SimpleValue         ::=
    String | Double | Decimal | Integer | Boolean | IriReference
#+END_SRC

[[./ebnf-diagram/SimpleValue.svg]]

A *Boolean* value in SDML is either the keyword ~true~ or ~false~.

#+NAME: lst:grammar-boolean
#+BEGIN_SRC ebnf
Boolean             ::= Tautology | Contradiction
#+END_SRC

[[./ebnf-diagram/Boolean.svg]]

#+BEGIN_SRC ebnf
Tautology           ::= "true" | "⊤"
#+END_SRC

[[./ebnf-diagram/Tautology.svg]]

#+BEGIN_SRC ebnf
Contradiction       ::= "false" | "⊥"
#+END_SRC

[[./ebnf-diagram/Contradiction.svg]]

An *unsigned* value in SDML is

#+NAME: lst:grammar-unsigned
#+BEGIN_SRC ebnf
Unsigned            ::= Zero | NonZero ASCII_DIGIT*
#+END_SRC

[[./ebnf-diagram/Unsigned.svg]]

#+BEGIN_SRC ebnf
Zero                ::= [0]
#+END_SRC

[[./ebnf-diagram/Zero.svg]]

#+BEGIN_SRC ebnf
NonZero             ::= [1-9]
#+END_SRC

[[./ebnf-diagram/NonZero.svg]]

An *Integer* value in SDML is a string of ASCII decimal digits, without leading zeros; zero, =0=, is a valid value however
=00= and =01= are not. The Integer type corresponds to a 64-bit signed integer number.

#+NAME: lst:grammar-integer
#+BEGIN_SRC ebnf
Integer             ::= NumericSign? Unsigned
#+END_SRC

[[./ebnf-diagram/Integer.svg]]

#+BEGIN_SRC ebnf
NumericSign         ::= [+-]
#+END_SRC

[[./ebnf-diagram/NumericSign.svg]]

A *Decimal* value in SDML is an integer-like value, followed by the Full Stop (".", =U+002E=) character and another
integer-like value. The Decimal type corresponds to a 128-bit representation of a fixed-precision decimal number.

#+NAME: lst:grammar-decimal
#+BEGIN_SRC ebnf
Decimal             ::= Integer "." ASCII_DIGIT+
#+END_SRC

A *Double* value in SDML is a decimal-like value followed by a lower or upper case letter E (Latin Small Letter E, "e",
=U+0065= or Latin Capital Letter E, "E", =U+0045=), a sign character (Hyphen Minus, "-", =U+002D= or Plus Sign, "+", =U+002B=)
and an integer-like value. The Double type is a 64-bit floating point number (specifically, the "binary64" type defined
in IEEE 754-2008).

#+NAME: lst:grammar-double
#+BEGIN_SRC ebnf
Double              ::= Decimal ExponentChar NumericSign? Integer
#+END_SRC

[[./ebnf-diagram/Double.svg]]

#+BEGIN_SRC ebnf
ExponentChar        ::=[eE]
#+END_SRC

[[./ebnf-diagram/ExponentChar.svg]]

A *String* value in SDML is a sequence of Unicode characters starting and ending with a Quotation Mark ('"', =U+0022=) character. While
standard escape sequences allow for embedding non-printing characters. The form =\u{XXXX}=, where =X= is a single hex digit,
allows for the inclusion of any Unicode characters by their code point. Note that this form requires a minimum of 2 and
a maximum of 6 such digits. In addition,the following single-character escape characters are supported.

#+NAME: lst:grammar-string
#+BEGIN_SRC ebnf
NotAllowed          ::= [^\#x00-#x08#x0B-#x1F#x7F]
QuotedString        ::= "\"" ( Escape | NotAllowed )* "\""
String              ::= QuotedString LanguageTag?
#+END_SRC

[[./ebnf-diagram/NotAllowed.svg]]

[[./ebnf-diagram/QuotedString.svg]]

[[./ebnf-diagram/String.svg]]

#+NAME: lst:grammar-string-escape
#+BEGIN_SRC ebnf
HexPair             ::= HexDigit HexDigit
CharacterEscape     ::= [\"\\/abefnrtv]
UnicodeEscape       ::= "u{" HexPair ( HexPair ( HexPair )? )? "}"
Escape              ::= "\\" ( CharacterEscape | UnicodeEscape )
#+END_SRC

[[./ebnf-diagram/HexPair.svg]]

[[./ebnf-diagram/CharacterEscape.svg]]

[[./ebnf-diagram/UnicodeEscape.svg]]

[[./ebnf-diagram/Escape.svg]]

Note also that strings allow literal newlines and do not /require/ they be present in escaped form. This means that a
string literal supports multiline forms.

#+NAME: tbl:string-escape-characters
#+CAPTION: String Escape Characters
| Escape Character | Character Name (Common Name)          | Unicode Equivalent |
|------------------+---------------------------------------+--------------------|
| =\"=               | Quotation Mark                        | =\u{0022}=           |
| =\/=               | Solidus (Forward Slash)               | =\u{002F}=           |
| =\\=               | Reverse Solidus (Backslash)           | =\u{005C}=           |
| =\a=               | Bell                                  | =\u{0007}=           |
| =\b=               | Backspace                             | =\u{0008}=           |
| =\e=               | Escape                                | =\u{001B}=           |
| =\f=               | Form Feed (Page Break)                | =\u{000C}=           |
| =\n=               | Line Feed (New Line)                  | =\u{000A}=           |
| =\r=               | Carriage Return                       | =\u{000D}=           |
| =\t=               | Character Tabulation (Horizontal Tab) | =\u{0009}=           |
| =\v=               | Line Tabulation (Vertical Tab)        | =\u{000B}=           |

A *Language-Tagged String* value in SDML is a String as above but immediately followed by a Commercial At ("@", =U+0040=)
character and an unquoted string of characters that conform to a language identifier. Note that both components of such
a string contribute to equality tests, so that ="abc"@en= is not equal to ="abc"@fr=.

#+NAME: lst:grammar-language-tag
#+BEGIN_SRC ebnf
LanguageTag         ::= 
    "@" LanguageTagPrimary
        LanguageTagExtended?
        LanguageTagScript?
        LanguageTagRegion?
#+END_SRC

[[./ebnf-diagram/LanguageTag.svg]]

The primary language is one of:

- a two letter language code from ISO 639-1,
- a three letter code from ISO 639-2.

#+BEGIN_SRC ebnf
LanguageTagPrimary  ::=
    ASCII_LETTER_LOWER ASCII_LETTER_LOWER ASCII_LETTER_LOWER?
#+END_SRC

[[./ebnf-diagram/LanguageTagPrimary.svg]]

The extended language is zero to three selected three letter ISO 639-2 codes.

#+BEGIN_SRC ebnf
LanguageTagExtended ::=
    "-" ASCII_LETTER_UPPER ASCII_LETTER_UPPER ASCII_LETTER_UPPER
#+END_SRC

[[./ebnf-diagram/LanguageTagExtended.svg]]

The language script is an ISO 15924 four letter code in title case.

#+BEGIN_SRC ebnf
LanguageTagScript   ::=
    "-" ASCII_LETTER_UPPER ASCII_LETTER_LOWER
        ASCII_LETTER_LOWER ASCII_LETTER_LOWER
#+END_SRC

[[./ebnf-diagram/LanguageTagScript.svg]]

The language region is either a two letter ISO 3166-1 code or a three digit UN M.49 code.

#+BEGIN_SRC ebnf
LanguageTagRegion   ::=
    "-" ( ( ASCII_LETTER_UPPER ASCII_LETTER_UPPER )
          | ( ASCII_DIGIT ASCII_DIGIT ASCII_DIGIT ) )
#+END_SRC

[[./ebnf-diagram/LanguageTagRegion.svg]]

An *IRI Reference value* in SDML is a value IRI value, either absolute or relative, between a Less-Than Sign ("<", =U+003C=)
character and a Greater-Than Sign (">", =U+003E=) character. IRI references are more permissive in the SDML grammar than
the Turtle[fn:iri] language.

#+NAME: lst:grammar-iri-reference
#+BEGIN_SRC ebnf
IriReference        ::=
    "<" ( [^<>\"{}|^`\#x00-#x20] | UnicodeEscape )* ">"
#+END_SRC

[[./ebnf-diagram/IriReference.svg]]

See section [[sec:mapping-values]] for a more detailed description of values, literals, and data types.

*** Value Constructors

While the value =101= is defined to be an Integer literal, in the presence of sub-types how do you specify the type of a
literal? To accomplish this a /value constructor/ allows for specifying the precise type, or casting a value to a specific
type.

The syntax appears as a function call with a type reference followed by a valid /simple value/ surrounded by the Left
Parenthesis ("(", =U+0028=) and Right Parenthesis (")", =U+0029=) characters. The literal value MUST be valid for the
referenced type, or one of it's super-types.

#+NAME: lst:grammar-value-constructor
#+BEGIN_SRC ebnf
ValueConstructor    ::= IdentifierReference "(" SimpleValue ")"
#+END_SRC

[[./ebnf-diagram/ValueConstructor.svg]]

Here we assert that the value =1= is an unsigned rather than the default signed integer.

#+NAME: lst:sdml-ex-type-constructor
#+CAPTION: Value Constructor Example
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = xsd:unsigned(1)

end
#+END_SRC

You can ignore the syntax of ~@ex:thing~ which is an annotation, see section [[sec:annotations]], used to ensure the syntax is
complete for all examples.

*** Value Lists

As stated in section [[sec:modules-and-imports]], lists in SDML start with the Left Square Bracket ("[", =U+005B=)
character and end with the Right Square Bracket ("]", =U+005D=) character with no separator character between members of
the list. Value lists are, as one might expect, lists of values and specifically of simple values. Value lists are also
heterogeneous and may contain elements of different types.

#+NAME: lst:grammar-list-of-values
#+BEGIN_SRC js :noeval
ListOfValues        ::=
    "[" ( SimpleValue | ValueConstructor | IdentifierReference )+ "]"
#+END_SRC

[[./ebnf-diagram/ListOfValues.svg]]

#+NAME: lst:sdml-ex-value-lists
#+CAPTION: Value List Example
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  @ex:thing = [ "yes" "no" "maybe" ]

end
#+END_SRC

*** Defining Data Types

A datatype definition introduces a new simple data type by /restriction/ of some existing base type.

#+NAME: lst:grammar-data-type-def
#+BEGIN_SRC ebnf
DataTypeDef         ::=
    "datatype" Identifier "<-" DataTypeBase AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/DataTypeDef.svg]]

#+BEGIN_SRC ebnf
DataTypeBase        ::= IdentifierReference | BuiltinSimpleType
#+END_SRC

[[./ebnf-diagram/DataTypeBase.svg]]

Listing [[lst:sdml-ex-datatype]] shows the /type restriction/ operator, =<-=, defining a new type named ~name~ as a restriction on
the existing XML Schema data type ~xsd:string~.

#+NAME: lst:sdml-ex-datatype
#+CAPTION: New Datatype
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  datatype Name <- string

end
#+END_SRC

While such a type is useful for conveying semantic meaning with types it doesn't provide any actual restriction on the
value space of the type. This is accomplished by using a subset of the /facets/ described in XML Schema part 2 to specify
constraints on the new type. For example, in listing [[lst:sdml-ex-restricted-datatype]] we now see that the Name type
is a string whose length is between 5 and 25 characters only.

#+NAME: lst:sdml-ex-restricted-datatype
#+CAPTION: New Datatype with Restrictions
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import ex

  datatype Name <- string is
    @xsd:minLength = 5
    @xsd:maxLength = 25
  end

end
#+END_SRC

From OWL 2 Web Ontology Language Quick Reference Guide[fn:owlqr]:

#+NAME: tbl:owl-facets
#+CAPTION: OWL Built-in Datatype Facets
| Facet                                                                  | Value                                      | Applicable Datatypes       | Explanation                                                                                |
|------------------------------------------------------------------------+--------------------------------------------+----------------------------+--------------------------------------------------------------------------------------------|
| =xsd:minInclusive=, =xsd:maxInclusive=, =xsd:minExclusive=, =xsd:maxExclusive= | literal in the corresponding datatype      | Numbers, Time Instants     | Restricts the value-space to greater than (equal to) or lesser than (equal to) a value     |
| =xsd:minLength=, =xsd:maxLength=, =xsd:length=                               | Non-negative integer                       | Strings, Binary Data, IRIs | Restricts the value-space based on the lengths of the literals                             |
| =xsd:pattern=                                                            | =xsd:string= literal as a regular expression | Strings, IRIs              | Restricts the value space to literals that match the regular expression                    |
| =rdf:langRange=                                                          | =xsd:string= literal as a regular expression | =rdf:PlainLiteral=           | Restricts the value space to literals with language tags that match the regular expression |

*** The Built-in Simple Types

In the preceding sections we introduced the set of built-in simple types: string, double, decimal, integer, boolean, and
iri. These are keywords in SDML and have specific rules applied when parsing. Each keyword is translated into a
qualified identifier where the module name is the reserved name =sdml=. This set of standard library types have an
underlying RDF/OWL equivalence relationship to a subset of the XML Schema datatypes, all shown in table
[[tbl:builtin-simple-types]].

#+NAME: lst:builtin-simple-types
#+BEGIN_SRC ebnf
BuiltinSimpleType   ::= 
    "string" | "double" | "decimal" | "integer" | "boolean" | "iri"
#+END_SRC

[[./ebnf-diagram/BuiltinSimpleType.svg]]

#+NAME: tbl:builtin-simple-types
#+CAPTION: Built-in Simple Type Mapping
| Type Keyword | Qualified Identifier | Equivalent XML Schema Datatype |
|--------------+----------------------+--------------------------------|
| ~boolean~      | ~sdml:boolean~         | ~xsd:boolean~                    |
| ~decimal~      | ~sdml:decimal~         | ~xsd:decimal~                    |
| ~double~       | ~sdml:double~          | ~xsd:double~                     |
| ~integer~      | ~sdml:integer~         | ~xsd:integer~                    |
| ~iri~          | ~sdml:iri~             | ~xsd:anyURI~                     |
| ~string~       | ~sdml:string~          | ~xsd:string~ or ~rdf:langString~   |

*** <<sec:sequence-types>>Sequence Types

When a structure member has a cardinality other than ~1..1~ it has to be represented by a /sequence type/, or collection
type. SDML bases it's sequence types on /cardinality constraints/ rather than the direct specification of a collection
type. This allows you to specify the semantic intent of a member rather than picking a type and then worrying about the
mapping of that to a programming language types.

The current SDML cardinality constraints are:

- Ordering :: determines whether the sequence maintains the order of it's elements; one of ~ordered~ or ~unordered~ (default).
- Uniqueness :: determines whether the sequence allows duplicate elements or not; one of ~ordered~ or ~nonunique~ (default).

Table [[tbl:builtin-sequence-types]] shows how these constraints are combined to determine the corresponding SDML sequence
type. See also section [[seq:library-sequence-types]] which describes the standard library operations on sequence types.

#+NAME: tbl:builtin-sequence-types
#+CAPTION: Built-in Sequence Types
| Ordering  | Uniqueness | Type          | Example Specification |
|-----------+------------+---------------+-----------------------|
| ~unordered~ | ~nonunique~  | ~Bag~ (default) | ~{0..}~                 |
| ~ordered~   | ~nonunique~  | ~List~          | ~{ordered 0..}~         |
| N/A       | N/A        | ~Maybe~         | ~{0..1}~ [1]             |
| ~ordered~   | ~unique~     | ~OrderedSet~    | ~{ordered unique 0..}~  |
| ~unordered~ | ~unique~     | ~Set~           | ~{unique 0..}~          |

Notes:

1. Any ordering or uniqueness constraint on the cardinality ~0..1~ is effectively ignored.

** <<sec:annotations>>Annotations

Annotations allow for the assertion of facts attached to model elements that go beyond what is possible to describe in
the core syntax. Annotations are available in two forms, annotation properties, and constraints.

#+NAME: lst:grammar-annotation
#+BEGIN_SRC ebnf
Annotation          ::= AnnotationProperty | Constraint
#+END_SRC

[[./ebnf-diagram/Annotation.svg]]

#+NAME: lst:grammar-annotation-only-body
#+BEGIN_SRC ebnf
AnnotationOnlyBody  ::= "is" Annotation+ "end"
#+END_SRC

[[./ebnf-diagram/AnnotationOnlyBody.svg]]

*** Annotation Properties

Annotation Properties are an extension mechanism that interacts directly with the underlying RDF representation of the subject
model element. While these may look like Java /annotations/, Python /decorators/, or Rust /attributes/ it is more powerful in
that it can express arbitrary statements about the model element. An SDML annotation starts with the symbol "@" and then
has an identifier that resolves to an OWL annotation property (see section [[sec:define-rdf]] for the detailed rules), and a
value for the corresponding property range.

#+NAME: lst:grammar-annotation-property
#+BEGIN_SRC ebnf
AnnotationProperty  ::= "@" IdentiferReference "=" Value
#+END_SRC

[[./ebnf-diagram/AnnotationProperty.svg]]

*Example:*

The following example demonstrates a common annotation property attached to a module.

#+NAME: lst:sdml-ex-annotation-property
#+CAPTION: Annotation Property
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import skos

  @skos:note = "This is an example annotation"

end
#+END_SRC

*Example:*

#+NAME: lst:sdml-ex-annotation-property-list
#+CAPTION: Annotation Property List
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import skos

  @skos:prefLabel = [
    "example"@en
    "exemple"@fr
    "例子"@zh-CH
  ]

end
#+END_SRC

*Example:*

#+NAME: lst:sdml-ex-annotated-module
#+CAPTION: Annotated Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ dc skos ]

  @dc:description = "This is an example module, with two annotations"
  @skos:prefLabel = "Example Module"@en

end
#+END_SRC

From [[https://www.w3.org/TR/owl-ref/#AnnotationProperty-def][OWL Web Ontology Language Reference]], Appendix E: Rules of Thumb for OWL DL ontologies:

#+BEGIN_QUOTE
If a property =a= is used where an annotation property is expected then it should either be one of the built in
annotation properties (=owl:versionInfo=, =rdfs:label=, =rdfs:comment=, =rdfs:seeAlso=, and =rdfs:isDefinedBy=) or there
should be a triple:

=a rdf:type owl:AnnotationProperty=
#+END_QUOTE

*** Constraints

This section will only briefly introduce constraints as section [[sec:model-constraints]] provides a detailed description.
The first example, in listing [[lst:sdml-ex-constrained-module]], provides an informal constraint in that it is simply a
string which is useful to readers but cannot be verified.

#+NAME: lst:sdml-ex-constrained-module
#+CAPTION: Informal Constraint on Module
#+BEGIN_SRC sdml :exports code :noeval
module rental is

  assert name_form = "All definition names MUST start with 'Rental'"

end
#+END_SRC

While informal constraints are not validated in any way, given the ambiguities of human language a controlled language
is a useful alternative.

A formal constraint on the other hand may be verified, but takes more work to structure correctly. The example in
listing [[lst:sdml-ex-formal-constrained-module]] example above by methodically checking every definition and any members
therein.

#+NAME: lst:sdml-ex-formal-constrained-module
#+CAPTION: Formal Constraint on Module
#+BEGIN_SRC sdml :exports code :noeval
module rental is

  assert name_form is
    forall d in definitions(self) ( suffix(name(d) "Rental") )
  end

end
#+END_SRC

*** <<sec:define-rdf>> Defining RDF Classes and Properties

In general only properties that have an RDF type of =owl:AnnotationProperty=, or are sub-properties of such a property,
may appear as annotations. This maintains the assertion that they are annotations of their subject and allows the use of
a range of pre-defined annotation properties from RDF, RDF Schema, OWL, and the Dublin Core Metadata Initiative
(DCMI)[fn:dcmi].

For example the annotation property =rdfs:comment= is defined in the following manner allowing it's use on any resource
and with a value that may be any literal.

#+NAME: lst:rdfs-comment
#+CAPTION: The definition of rdfs:comment
#+BEGIN_SRC ttl
rdfs:comment rdf:type rdf:Property, owl:AnnotationProperty ;
	rdfs:isDefinedBy <http://www.w3.org/2000/01/rdf-schema#> ;
	rdfs:label "comment" ;
	rdfs:comment "A description of the subject resource." ;
	rdfs:domain rdfs:Resource ;
	rdfs:range rdfs:Literal .
#+END_SRC

To allow the standard library to define SDML equivalents of such properties it is necessary to provide a mechanism to
use non-annotation properties such as =rdf:type=, =rdfs:domain=, and =rdfs:range= as demonstrated in the example above. To
allow this, if a model element has the property =rdf:type= then the transformation from that element to RDF *does not* use
any of the transformations described here but an explicit mapping from *only* the provided properties.

Rewriting the RDF from listing [[lst:rdfs-comment]] into SDML results in the definition in listing [[lst:rdfs-comment-in-sdml]].

#+NAME: lst:rdfs-comment-in-sdml
#+CAPTION: The SDML definition of rdfs:comment
#+BEGIN_SRC sdml :exports code :noeval
module rdfs is

  ;; a lot of things elided.

  structure comment is
    @rdf:type = [ rdf:Property owl:AnnotationProperty ]
    @isDefinedBy = <http://www.w3.org/2000/01/rdf-schema#>
    @label = "comment"
    @comment = "A description of the subject resource."
    @domain = Resource
    @range = Literal
  end

end
#+END_SRC

The following are commonly used RDF and OWL definition properties.

- =rdf:type= --
- =rdfs:domain= and =rdfs:range= --
- =rdfs:subClassOf= and =rdfs:subPropertyOf= --
- =owl:equivalentClass= and =owl:equivalentProperty= --
- =owl:inverseOf= --
- =owl:disjointWith= --
- =owl:FunctionalProperty=, =owl:InverseFunctionalProperty=, =owl:SymmetricProperty= and =owl:TransitiveProperty= --

** Structured Types

Structured types fall into two primary categories, /Product/ types and /Sum/ types. Product types have named and typed
/Members/ and in SDML these are structures, entities and events. Sum types on the other hand have /Variants/ and in SDML
these are enumerations and disjoint unions. In the surface syntax product type bodies are introduced by the keyword ~is~
whereas sum type bodies are introduced by the keyword ~of~.

*** Members

Product type members fall into the following categories.

- Identity :: A particular kind of member only available on entities, and required by them, to name the identifier for
  that entity type.
- By-Value :: A reference to a value type, i.e. Enumeration, Event, or Structure. Such a member may indicate the
  cardinality of the target.
- By-Reference :: A reference to an Entity type. Such a member may indicate the cardinality of the
  target as well as the name of the inverse member on the target type.

#+NAME: lst:grammar-identity-member
#+BEGIN_SRC ebnf
IdentityMember      ::=
    "identity" Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )
#+END_SRC

[[./ebnf-diagram/IdentityMember.svg]]

#+NAME: lst:grammar-value-member
#+BEGIN_SRC ebnf
MemberByValue       ::=
    Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )
#+END_SRC

[[./ebnf-diagram/MemberByValue.svg]]

#+NAME: lst:grammar-reference-member
#+BEGIN_SRC ebnf
MemberByReference   ::=
    "ref" Identifier
        ( PropertyMember | ( InverseName? TypeExpressionTo AnnotationOnlyBody? ) )
#+END_SRC

[[./ebnf-diagram/MemberByReference.svg]]

#+NAME: lst:grammar-reference-inverse
#+BEGIN_SRC ebnf
InverseName         ::= "(" Identifier ")"
#+END_SRC

[[./ebnf-diagram/InverseName.svg]]

#+NAME: lst:grammar-property-member
#+BEGIN_SRC ebnf
PropertyMember      ::= "as" Identifier
#+END_SRC

[[./ebnf-diagram/PropertyMember.svg]]

*Example*:

#+NAME: lst:sdml-ex-members
#+CAPTION: Members in a Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Account is
    accountId as default
    name -> string
  end

end
#+END_SRC

For identity, by-value, and by-reference members the general syntax uses the /type reference/ operator, /name/ ~->~ /type/, with
additional keywords and cardinality included as follows.

#+NAME: tbl:member-summary
#+CAPTION: Summary of Member Formats
| Kind         | Keyword  | To-Cardinality | Target Types                            |
|--------------+----------+----------------+-----------------------------------------|
| Identity     | ~identity~ | No             | Enumeration, Event, Structure, or Union |
| By-Value     |          | Yes            | Enumeration, Event, Structure, or Union |
| By-Reference | ~ref~      | Yes            | Entity                                  |

Additionally, to allow for the capture of member names before the elaboration of all types the language allows for the
target type to be replaced with the keyword ~unknown~. This marks the member, and by extension it's owning type, as
/incomplete/.

#+NAME: lst:grammar-type-expressions
#+BEGIN_SRC ebnf
TypeExpression      ::= "->" TypeReference
TypeExpressionTo    ::= "->" Cardinality? TypeReference
TypeReference       ::=  UnknownType | IdentifierReference | BuiltinSimpleType
UnknownType         ::= "unknown"
#+END_SRC

[[./ebnf-diagram/TypeExpression.svg]]

[[./ebnf-diagram/TypeExpressionTo.svg]]

[[./ebnf-diagram/TypeReference.svg]]

The *cardinality* of a member is specified as a range operation with a minimum and maximum number of occurrences
specified. Additionally cardinality constraints determine the ordering and uniqueness of the collection of member values
in a sequence type (see section [[sec:sequence-types]]).

- The form ~{1..3}~ specifies a cardinality of 1 to 3 inclusive, or $[1,3]$ in interval notation.
- The form ~{1..}~ specifies a minimum of 1 occurrences an unbounded maximum, or $[1,\infty]$ in interval notation.
- The form ~{1}~ specifies that 1 is both the minimum and maximum value, or $[1,1]$ in interval notation, commonly termed
  a /degenerate/ interval.

#+NAME: lst:grammar-cardinality
#+BEGIN_SRC ebnf
Cardinality         ::=
    "{" SequenceOrdering? SequenceUniqueness? Unsigned CardinalityRange? "}"
CardinalityRange    ::= ".." Unsigned?
#+END_SRC

[[./ebnf-diagram/Cardinality.svg]]

[[./ebnf-diagram/CardinalityRange.svg]]

#+BEGIN_SRC ebnf
SequenceOrdering    ::= ( "ordered" | "unordered" )
SequenceUniqueness  ::= ( "unique" | "nonunique" )
#+END_SRC

[[./ebnf-diagram/SequenceOrdering.svg]]

[[./ebnf-diagram/SequenceUniqueness.svg]]

*** Variants

Sum type variants fall into the following categories.

- Value Variant :: A member within an enumeration that specifies a numeric value for each member rather than a type.
- *Type Variant* :: A type reference that is a unique variant of a disjoint union.

The details of the two variant types are in the sections on /enumerations/ and /disjoint unions/ following.

*** Structures

A structure is a product type that is composed of named and typed members. A structure is therefore akin to a record
type, a table in data modeling, or a class in object modeling.

#+NAME: lst:grammar-structure-def
#+BEGIN_SRC ebnf
StructureDef        ::= "structure" Identifier StructureBody?
#+END_SRC

[[./ebnf-diagram/StructureDef.svg]]

*Example*:

As only the keyword ~structure~ and the identifier are required, the listing [[lst:sdml-ex-empty-structure]] is therefore a
valid model.

#+NAME: lst:sdml-ex-empty-structure
#+CAPTION: Empty Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length

end
#+END_SRC

The structure ~Length~ in listing [[lst:sdml-ex-empty-structure]] is /valid/ but considered incomplete. Adding a body to the
structure, between ~is~ and ~end~, makes it complete even if it has no actual members. In listing
[[lst:sdml-ex-annotated-structure]] the structure Length is now complete.


#+NAME: lst:grammar-structure-body
#+BEGIN_SRC ebnf
StructureBody       ::= "is" Annotation* ( MemberByValue | StructureGroup )* "end"
#+END_SRC

[[./ebnf-diagram/StructureBody.svg]]

*Example*:

#+NAME: lst:sdml-ex-annotated-structure
#+CAPTION: Annotated Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length is
    @skos:prefLabel = "Length"@en
  end

end
#+END_SRC

*Example*:

Listing [[lst:sdml-ex-structure-members]] adds the members ~value~ and ~unit~ and their corresponding types.

#+NAME: lst:sdml-ex-structure-members
#+CAPTION: Structure Members
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Length is
    @skos:prefLabel = "Length"@en

    value -> Decimal
    unit -> DistanceUnit
  end

end
#+END_SRC

In listing [[lst:sdml-ex-structure-groups]] we see a more complex structure with both members and groups.

#+NAME: lst:grammar-structure-group
#+BEGIN_SRC ebnf
StructureGroup      ::= "group" Annotation* MemberByValue+ "end"
#+END_SRC

[[./ebnf-diagram/StructureGroup.svg]]

*Example*:

#+NAME: lst:sdml-ex-structure-groups
#+CAPTION: Structure Members and Groups
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Account is
  
    @skos:prefLabel = "Customer Account"@en

    group
      @skos:prefLabel = "Metadata"
      created -> xsd:dateTime
      lastModified -> xsd:dateTime
    end

    group
      @skos:prefLabel = "Customer Information"
      ref customer -> {1..1} Customer
    end
  
  end

end
#+END_SRC

*** Entities

#+NAME: lst:grammar-entity-def
#+BEGIN_SRC ebnf
EntityDef           ::= "entity" Identifier EntityBody?
#+END_SRC

[[./ebnf-diagram/EntityDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-entity
#+CAPTION: Empty Entity
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person

end
#+END_SRC

The entity ~Person~ in listing [[lst:sdml-ex-empty-entity]] is /valid/ but /incomplete/.

#+BEGIN_SRC ebnf
EntityBody          ::=
    "is" Annotation* IdentityMember ( EntityMember | EntityGroup )* "end"
#+END_SRC

[[./ebnf-diagram/EntityBody.svg]]

#+BEGIN_SRC ebnf
EntityGroup         ::= "group" Annotation* EntityMember+ "end"
#+END_SRC

[[./ebnf-diagram/EntityGroup.svg]]

#+BEGIN_SRC ebnf
EntityMember        ::= MemberByValue | MemberByReference
#+END_SRC

[[./ebnf-diagram/EntityMember.svg]]

*Example*:

#+NAME: lst:sdml-ex-entity-identifying-member
#+CAPTION: Entity with Identifying Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person is
    identity id -> PersonId
  end

end
#+END_SRC

The ~identity~ member is a required part of the entity definition, it not only tells us what type represents the unique
identifier for this entity but is also used in ~ref~ members and event sources (see section [[sec:entity-events]]). In the
case of a ~ref~ member the target entity, in our example =Person= is not included in the entity's structure, it's identifier
type, =PersonId= is instead.

#+NAME: lst:sdml-ex-entity-ref-member
#+CAPTION: Entity with Reference Member
#+BEGIN_SRC sdml :exports code :noeval
module example is

  entity Person is
  
    identity id -> PersonId

    ref emergency_contact (emergency_contact_for) -> {0..2} Person is
      @dc:description = "Emergency contact person"
    end
  
  end
end
#+END_SRC

*** <<sec:entity-events>>Entity Events

Entity Events, or simply Events, model notifications generated by an entity most often representing a state change in the entity.
As such a ~source~ reference denotes the entity which generates this event. Any expansion of the event structure *must* include the
identifiers of the source entity.

#+NAME: lst:grammar-event-def
#+BEGIN_SRC ebnf
EventDef            ::=
    "event" Identifier "source" IdentifierReference StructureBody?
#+END_SRC

[[./ebnf-diagram/EventDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-event
#+CAPTION: Empty Event
#+BEGIN_SRC sdml :exports code :noeval
module example is

  event PersonNameChanged source Person

end
#+END_SRC

With the expansion of the ~source~ entity the event definition above is logically equivalent to the following structure.

#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure PersonNameChanged is
    id -> PersonId is
      @sdml:identifies = Person
    end
  end

end
#+END_SRC

As we have seen before, the event ~PersonNameChanged~ in listing [[lst:sdml-ex-empty-event]] is valid but incomplete.

*Example*:

The following is a valid /and/ complete event definition with two structure members.

#+NAME: lst:sdml-ex-event
#+CAPTION: Event
#+BEGIN_SRC sdml :exports code :noeval
module example is

  event PersonNameChanged source Person is
    fromValue -> Name
    toValue -> Name
  end

end
#+END_SRC

*** Enumerations

An enumeration is a numeric type that expressly names the values it may take. This is a restricted form of the =enum= type
found in most languages as not only *must* all names be unique but all names *must* specify a value *and* all values *must* also
be unique. Note also that the keyword =of= and not =is= starts an enumeration body.

#+NAME: lst:grammar-enum-def
#+BEGIN_SRC ebnf
EnumDef             ::= "enum" Identifier EnumBody?
#+END_SRC

[[./ebnf-diagram/EnumDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-enum
#+CAPTION: Empty Enum
#+BEGIN_SRC sdml :exports code :noeval
module example is

  enum DistanceUnit

end
#+END_SRC

The enumeration ~DistanceUnit~ in [[lst:sdml-ex-empty-enum]] is valid but incomplete. Completion of the enumeration requires
the addition of a body with enumeration variants.

#+BEGIN_SRC ebnf
EnumBody            ::= "of" Annotation* ValueVariant+ "end"
#+END_SRC

[[./ebnf-diagram/EnumBody.svg]]

#+NAME: lst:grammar-enum-variant
#+BEGIN_SRC ebnf
ValueVariant        ::= Identifier "=" Unsigned AnnotationOnlyBody?
#+END_SRC
[[./ebnf-diagram/ValueVariant.svg]]

*Example*:

The following demonstrates a valid /and/ complete enumeration.

#+NAME: lst:sdml-ex-enum
#+CAPTION: Enum With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is

  enum DistanceUnit of
    Meter = 1
    Foot = 2
  end

end
#+END_SRC

*** Disjoint Unions

A disjoint, or discriminated, union is a mechanism to allow for a selection of disjoint types to be treated as a single
type. As such the /variants/ of the union are simply type references, although they do allow annotations. Note also that
the keyword =of= and not =is= starts a union body.

#+NAME: lst:grammar-union-def
#+BEGIN_SRC ebnf
UnionDef            ::= "union" Identifier UnionBody?
#+END_SRC

[[./ebnf-diagram/UnionDef.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-union
#+CAPTION: Empty Union
#+BEGIN_SRC sdml :exports code :noeval
module example is

  union VehicleClass

end
#+END_SRC

The union ~VehicleClass~ in [[lst:sdml-ex-empty-union]] is valid but incomplete. Completion of the union requires the addition
of a body with type variants.

#+BEGIN_SRC ebnf
UnionBody           ::= "of" Annotation* TypeVariant+ "end"
#+END_SRC

[[./ebnf-diagram/UnionBody.svg]]

#+NAME: lst:grammar-type-variant
#+BEGIN_SRC ebnf
TypeVariant         ::= IdentifierReference TypeVariantRename? AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/TypeVariant.svg]]

#+BEGIN_SRC ebnf
TypeVariantRename   ::= "as" Identifier
#+END_SRC

[[./ebnf-diagram/TypeVariantRename.svg]]

*Example*:

The following is a valid /and/ complete example with three type variants and one that is renamed from =Van= to =LittleTruck=.

#+NAME: lst:sdml-ex-union
#+CAPTION: Union With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is

  union VehicleClass of
    Car
    Truck
    Van as LittleTruck
  end

end
#+END_SRC

** Property Definitions

SDML provides for a data dictionary, or element-first, style of model capture where key properties of the domain are
defined and annotated in a stand-alone form. These are often key identifiers and other shared properties 

#+NAME: lst:grammar-property-def
#+BEGIN_SRC ebnf
PropertyDef         ::= "property" Identifier PropertyBody?
#+END_SRC

[[./ebnf-diagram/PropertyDef.svg]]

#+BEGIN_SRC ebnf
PropertyBody        ::= "is" Annotation* PropertyRole+ "end"
#+END_SRC

[[./ebnf-diagram/PropertyBody.svg]]

*Example*:

#+NAME: lst:sdml-ex-empty-property
#+CAPTION: Empty Property
#+BEGIN_SRC sdml :exports code :noeval
module example is

  property account_id

end
#+END_SRC

The property ~account_id~ in [[lst:sdml-ex-empty-property]] is valid but incomplete. Completion of the property requires the
addition of a body with roles defined.

#+NAME: lst:grammar-property-role
#+BEGIN_SRC ebnf
PropertyRole        ::=
    Identifier ( "ref" Cardinality )? TypeExpressionTo AnnotationOnlyBody?
#+END_SRC

[[./ebnf-diagram/PropertyRole.svg]]

*Example*:

The following is a valid /and/ complete example.

#+NAME: lst:sdml-ex-property-role
#+CAPTION: Property with Roles
#+BEGIN_SRC sdml :exports code :noeval
module example is

  property accountId is

    identifier -> {1} account:AccountId is
      @skos:definition = "a"@en
    end

    reference ref {1} -> {1} account:AccountId

  end

end
#+END_SRC

** Common Questions

*** Why are Enumerations and Unions distinct?

*** When to use Property Definitions

#+CAPTION: Union Type Definition
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ skos xsd ]

  datatype AccountId <- xsd:long

  datatype ExternalAccountId <- uri

  structure ChildAccountId is
    parent -> AccountId
    child -> AccountId
  end

  union AllAccountIds of
    AccountId,
    ExternalAccountId,
    ChildAccountId
  end

end
#+END_SRC

#+CAPTION: Union Type As Property
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ skos xsd ]

  property account_id is
  
  internal -> {1} xsd:long is
    @skos:definition = "This is our internal representation."@en
  end
  
  external -> {1} url is
    @skos:definition = "This is our external representation for customers."@en
  end
  
  child -> {2} xsd:long
  end

  entity Account is

    identity account_id as internal

  end

end
#+END_SRC

*** How to model Variability

Discuss role of unions in modeling variability

** <<sec:complete-grammar>>Complete Surface Syntax Grammar

The grammar of the surface syntax is presented in Extended Backus–Naur form (EBNF)[fn:ebnf]. The addition of a character literal
range operation =..= reduces the number of single character alternatives for clarity. There are also a set of pre-defined
terminals such as =ASCII_DIGIT=, =ASCII_HEX_DIGIT=, =UC_LETTER_UPPER=, and =UC_LETTER_LOWER= used to simplify character ranges.
While there are many variations[fn:ebnfs] of EBNF in existence, including multiple standardized forms, the specific form
used here follows the notation described the W3C Extensible Markup Language (XML) 1.0 (Fifth Edition), section 6
[[https://www.w3.org/TR/xml/#sec-notation][Notation]].

#+BEGIN_SRC ebnf
Module              ::= "module" Identifier ModuleBase? ModuleBody

ModuleBase          ::= "base" IriReference

ModuleBody          ::= "is" ImportStatement* Annotation* Definition* "end"

MemberImport        ::= QualifiedIdentifier

ModuleImport        ::= Identifer

Import              ::= MemberImport | ModuleImport

ImportStatement     ::= "import" ( Import | "[" Import+ "]" )

Annotation          ::= AnnotationProperty | Constraint

AnnotationProperty  ::= "@" IdentiferReference "=" Value

Constraint          ::= InformalConstraint | FormalConstraint

Definition          ::=
    DataTypeDef | EntityDef | EnumDef | EventDef | StructureDef | UnionDef | PropertyDef

DataTypeDef         ::=
    "datatype" Identifier "<-" DataTypeBase AnnotationOnlyBody?

DataTypeBase        ::= IdentifierReference | BuiltinSimpleType

AnnotationOnlyBody  ::= "is" Annotation+ "end"

EntityDef           ::= "entity" Identifier EntityBody?

EntityBody          ::=
    "is"
    Annotation* IdentityMember ( EntityMember | EntityGroup )*
    "end"

EntityGroup         ::= "group" Annotation* EntityMember+ "end"

EntityMember        ::= MemberByValue | MemberByReference

EnumDef             ::= "enum" Identifier EnumBody?

EnumBody            ::= "of" Annotation* ValueVariant+ "end"

ValueVariant        ::= Identifier "=" Unsigned AnnotationOnlyBody?

EventDef            ::=
    "event" Identifier "source" IdentifierReference StructureBody?

StructureDef        ::= "structure" Identifier StructureBody?

StructureBody       ::= "is" Annotation* ( MemberByValue | StructureGroup )* "end"

StructureGroup      ::= "group" Annotation* MemberByValue+ "end"

UnionDef            ::= "union" Identifier UnionBody?

UnionBody           ::= "of" Annotation* TypeVariant+ "end"

TypeVariant         ::= IdentifierReference TypeVariantRename? AnnotationOnlyBody?

TypeVariantRename   ::= "as" Identifier

PropertyDef         ::= "property" Identifier PropertyBody?

PropertyBody        ::= "is" Annotation* PropertyRole+ "end"

PropertyRole        ::=
    Identifier ( "ref" Cardinality )? TypeExpressionTo AnnotationOnlyBody?

PropertyMember      ::= "as" Identifier

IdentityMember      ::=
    "identity" Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )

MemberByValue       ::=
    Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )

MemberByReference   ::=
    "ref" Identifier
        ( PropertyMember | ( InverseName? TypeExpressionTo AnnotationOnlyBody? ) )

TypeExpression      ::= "->" TypeReference

TypeExpressionTo    ::= "->" Cardinality? TypeReference

TypeReference       ::=  UnknownType | IdentifierReference | BuiltinSimpleType

UnknownType         ::= "unknown"

Cardinality         ::=
    "{" SequenceOrdering? SequenceUniqueness? Unsigned CardinalityRange? "}"

CardinalityRange    ::= ".." Unsigned?

SequenceOrdering    ::= ( "ordered" | "unordered" )

SequenceUniqueness  ::= ( "unique" | "nonunique" )

InverseName         ::= "(" Identifier ")"

Value               ::=
    SimpleValue | ValueConstructor | IdentifierReference | ListOfValues

BuiltinSimpleType   ::= 
    "string" | "double" | "decimal" | "integer" | "boolean" | "iri"

SimpleValue         ::=
    String | Double | Decimal | Integer | Boolean | IriReference

Boolean             ::= Tautology | Contradiction

Tautology           ::= ( "true" | "⊤" )

Contradiction       ::= ( "false" | "⊥" )

NumericSign         ::= [+-]

Zero                ::= [0]

NonZero             ::= [1-9]

Unsigned            ::= Zero | NonZero ASCII_DIGIT*

Integer             ::= NumericSign? Unsigned

Decimal             ::= Integer "." ASCII_DIGIT+

ExponentChar        ::= [eE]

Double              ::= Decimal ExponentChar NumericSign? Integer

HexPair             ::= ASCII_HEX_DIGIT ASCII_HEX_DIGIT

Escape              ::= "\\" ( CharacterEscape | UnicodeEscape )
CharacterEscape     ::= [\"\\/abefnrtv]

UnicodeEscape       ::= "u{" HexPair ( HexPair ( HexPair )? )? "}"

NotAllowed          ::= [^\"\#x00-#x08#x0B-#x1F#x7F]

QuotedString        ::= "\"" ( Escape | NotAllowed )* "\""

LanguageTag         ::= 
    "@" LanguageTagPrimary
        LanguageTagExtended?
        LanguageTagScript?
        LanguageTagRegion?

LanguageTagPrimary  ::=
    ASCII_LETTER_LOWER ASCII_LETTER_LOWER ASCII_LETTER_LOWER?

LanguageTagExtended ::=
    "-" ASCII_LETTER_UPPER ASCII_LETTER_UPPER ASCII_LETTER_UPPER

LanguageTagScript   ::=
    "-" ASCII_LETTER_UPPER ASCII_LETTER_LOWER
        ASCII_LETTER_LOWER ASCII_LETTER_LOWER

LanguageTagRegion   ::=
    "-" ( ( ASCII_LETTER_UPPER ASCII_LETTER_UPPER )
          | ( ASCII_DIGIT ASCII_DIGIT ASCII_DIGIT ) )

String              ::= QuotedString LanguageTag?

IriReference        ::=
    "<"
    ( [^<>\"{}|^`\#x00-#x20] | UnicodeEscape )*
    ">"

ValueConstructor    ::= IdentifierReference "(" SimpleValue ")"

ListOfValues        ::=
    "[" ( SimpleValue | ValueConstructor | IdentifierReference )+ "]"

IdentifierInitial   ::= UC_LETTER_UPPER | UC_LETTER_LOWER

IdentifierChar      ::= IdentifierInitial | UC_NUMBER_DECIMAL

Identifier          ::= IdentifierInitial IdentifierChar* ( "_" IdentifierChar+ )*

QualifiedIdentifier ::= Identifier ":" Identifier

IdentifierReference ::= QualifiedIdentifier | Identifier

LineComment         ::= ";" [^\r\n]*

Whitespace          ::= 
    [^\f\n\r\t\v#x20#xa0#x1680#x2000#x200a#x2028#x2029#x202f#x205f#x3000#xfeff]
#+END_SRC

*** The Embedded Constraint Language

Given that the /formal/ constraint language component of SDML is likely to be used less frequently *and* the grammar is
fairly long we have made it a separate section.

#+BEGIN_SRC ebnf
InformalConstraint  ::= "=" QuotedString ControlledLanguageTag?

ControlledLanguageTag ::=
    "@" LanguageTagPrimary ControlledLanguageScheme?

ControlledLanguageScheme ::=
    "-" ASCII_LETTER ASCII_LETTER ASCII_LETTER
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?

FormalConstraint    ::= "is" ConstraintEnvironment? ConstraintSentence "end"

ConstraintSentence  ::=
    SimpleSentence | BooleanSentence | QuantifiedSentence |
        "(" ConstraintSentence ")"

SimpleSentence      ::= Atomic | Equation

Atomic              ::= Term "(" Term* ")"

Equation            ::= Term "=" Term

BooleanSentence     ::=
    Negation |
    ConstraintSentence
        (
          Conjunction | Disjunction | ExclusiveDisjunction |
          Implication | Biconditional
        )

Negation            ::= ( "not" | "¬" ) ConstraintSentence

Conjunction         ::= ( "and" | "∧" ) ConstraintSentence

Disjunction         ::= ( "or" | "∨" ) ConstraintSentence

ExclusiveDisjunction ::= ( "xor" | "⊻" ) ConstraintSentence

Implication         ::= ( "implies" | "⇒" ) ConstraintSentence

Biconditional       ::= ( "iff" | "⇔" ) ConstraintSentence

QuantifiedSentence  ::= Universal | Existential

Universal           ::= ( "forall" | "∀" ) QuantifierBinding* QuantifiedBody

Existential         ::= ( "exists" | "∃" ) QuantifierBinding* QuantifiedBody

QuantifierBinding   ::= "self" | ( Identifer BindingTarget )

BindingTarget       ::=
    BindingFromType | BindingFromSequence | "(" BindingTarget ")"

BindingFromType     ::= "->" ( "Self" | IdentifierReference )

BindingFromSequence ::=
    ( "in" | "∈" ) ( NamePath | IdentifierReference | SequenceComprehension )

QuantifiedBody      ::= "(" ConstraintSentence ")"

Term                ::=
    NamePath | IdentifierReference | PredicateValue | FunctionalTerm | SequenceComprehension

NamePath            ::= ( "self" | "Self" | Identifier ) ( "." Identifier )+

PredicateValue      ::=
    SimpleValue | ListOfPredicateValues

ListOfPredicateValues ::= "[" SimpleValue* "]"

FunctionalTerm      ::= Term "(" Term* ")"
#+END_SRC

*** Constraint Environment Definitions

#+BEGIN_SRC ebnf
ConstraintEnvironment ::= EnvironmentDef+ "in"

EnvironmentDef      ::=
    "def" Identifier FunctionSignature?
        ( ":=" | "≔" ) ( PredicateValue | ConstraintSentence )

FunctionSignature   ::= "(" FunctionParameter+ ")" "->" FunctionType

FunctionParameter   ::= ( Identifier "->" )? FunctionType

FunctionType        ::=  AnyType | CollectionType | TypeReference

CollectionType      ::= BuiltinCollectionType "of" ( AnyType | TypeReference )

BuiltinCollectionType ::=
    "Bag" | "List" | "Maybe" | "OrderedSet" | "Sequence" | "Set"

AnyType             ::= "_"
#+END_SRC

*** Sequence Comprehensions

#+BEGIN_SRC ebnf
SequenceComprehension ::= "{" ReturnedValue "|" Expression "}"

ReturnedValue       ::= Identifier | ( "[" Identifier+ "]" )

Expression          ::=
    ConjunctiveExpression | LocalBinding | ConstraintSentence | "(" Expression ")"

ConjunctiveExpression ::=
    Expression ( "and" | "∧" ) Expression

LocalBinding        ::=
    Identifier ( BindingFromType | BindingFromSequence )
#+END_SRC

*** Acknowledgements

The diagrams generated for this document were generated from the BNF source by the /Railroad Diagram Generator/ tool,
written by Gunther Rademacher, and hosted at [[https://www.bottlecaps.de/rr/ui.]]

# ----- Footnotes

[fn:ebnf] [[https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form][Extended Backus-Naur Form (EBNF)]], Wikipedia
[fn:ebnfs] See [[http://www.cs.man.ac.uk/~pjj/bnf/ebnf.html][BNF/EBNF Variants]]
[fn:dcmi] [[https://www.dublincore.org/specifications/dublin-core/dcmi-terms/][DublinCoreDCMI Metadata Terms]], DublinCore
[fn:ucgc] [[https://unicode.org/reports/tr44/#GC_Values_Table][Unicode General Category]], Unicode.org
[fn:iri] RDF 1.1 Turtle – Terse RDF Triple Language, §[[https://www.w3.org/TR/turtle/#sec-iri-references][6.3 IRI References]], W3C
[fn:sparql] [[https://www.w3.org/TR/sparql11-overview/][SPARQL 1.1 Overview]], W3C
[fn:owlqr] [[https://www.w3.org/2007/OWL/wiki/Quick_Reference_Guide][OWL 2 Web Ontology Language Quick Reference Guide
(Second Edition)]], W3C

