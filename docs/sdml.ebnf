Module              ::= "module" Identifier ModuleBase? ModuleBody

ModuleBase          ::= "base" IriReference

ModuleBody          ::= "is" ImportStatement* Annotation* Definition* "end"

MemberImport        ::= QualifiedIdentifier

ModuleImport        ::= Identifer

Import              ::= MemberImport | ModuleImport

ImportStatement     ::= "import" ( Import | "[" Import+ "]" )

Annotation          ::= AnnotationProperty | Constraint

AnnotationProperty  ::= "@" IdentiferReference "=" Value

Constraint          ::=
    "assert" Identifier ( InformalConstraint | FormalConstraint )

Definition          ::=
    DataTypeDef | EntityDef | EnumDef | EventDef | StructureDef | UnionDef | PropertyDef

DataTypeDef         ::=
    "datatype" Identifier "<-" DataTypeBase AnnotationOnlyBody?

DataTypeBase        ::= IdentifierReference | BuiltinSimpleType

AnnotationOnlyBody  ::= "is" Annotation+ "end"

EntityDef           ::= "entity" Identifier EntityBody?

EntityBody          ::=
    "is"
    Annotation* IdentityMember ( EntityMember | EntityGroup )*
    "end"

EntityGroup         ::= "group" Annotation* EntityMember+ "end"

EntityMember        ::= MemberByValue | MemberByReference

EnumDef             ::= "enum" Identifier EnumBody?

EnumBody            ::= "of" Annotation* ValueVariant+ "end"

ValueVariant        ::= Identifier "=" Unsigned AnnotationOnlyBody?

EventDef            ::=
    "event" Identifier "source" IdentifierReference StructureBody?

StructureDef        ::= "structure" Identifier StructureBody?

StructureBody       ::= "is" Annotation* ( MemberByValue | StructureGroup )* "end"

StructureGroup      ::= "group" Annotation* MemberByValue+ "end"

UnionDef            ::= "union" Identifier UnionBody?

UnionBody           ::= "of" Annotation* TypeVariant+ "end"

TypeVariant         ::= IdentifierReference TypeVariantRename? AnnotationOnlyBody?

TypeVariantRename   ::= "as" Identifier

PropertyDef         ::= "property" Identifier PropertyBody?

PropertyBody        ::= "is" Annotation* PropertyRole+ "end"

PropertyRole        ::=
    Identifier ( "ref" Cardinality )? TypeExpressionTo AnnotationOnlyBody?

PropertyMember      ::= "as" Identifier

IdentityMember      ::=
    "identity" Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )

MemberByValue       ::=
    Identifier
        ( PropertyMember | ( TypeExpressionTo AnnotationOnlyBody? ) )

MemberByReference   ::=
    "ref" Identifier
        ( PropertyMember | ( InverseName? TypeExpressionTo AnnotationOnlyBody? ) )

TypeExpression      ::= "->" TypeReference

TypeExpressionTo    ::= "->" Cardinality? TypeReference

TypeReference       ::=  UnknownType | IdentifierReference | BuiltinSimpleType | MappingType

UnknownType         ::= "unknown"

MappingType         ::= "(" TypeReference "->" TypeReference ")"

Cardinality         ::=
    "{" SequenceOrdering? SequenceUniqueness? Unsigned CardinalityRange? "}"

CardinalityRange    ::= ".." Unsigned?

SequenceOrdering    ::= ( "ordered" | "unordered" )

SequenceUniqueness  ::= ( "unique" | "nonunique" )

InverseName         ::= "(" Identifier ")"

Value               ::=
    SimpleValue | ValueConstructor | IdentifierReference | MappingValue | ListOfValues

BuiltinSimpleType   ::=
    "string" | "double" | "decimal" | "integer" | "boolean" | "iri"

SimpleValue         ::=
    String | Double | Decimal | Integer | Boolean | IriReference

Boolean             ::= Tautology | Contradiction

Tautology           ::= ( "true" | "⊤" )

Contradiction       ::= ( "false" | "⊥" )

NumericSign         ::= [+-]

Zero                ::= [0]

NonZero             ::= [1-9]

Unsigned            ::= Zero | NonZero ASCII_DIGIT*

Integer             ::= NumericSign? Unsigned

Decimal             ::= Integer "." ASCII_DIGIT+

ExponentChar        ::= [eE]

Double              ::= Decimal ExponentChar NumericSign? Integer

HexPair             ::= ASCII_HEX_DIGIT ASCII_HEX_DIGIT

Escape              ::= "\\" ( CharacterEscape | UnicodeEscape )

CharacterEscape     ::= [\"\\/abefnrtv]

UnicodeEscape       ::= "u{" HexPair ( HexPair ( HexPair )? )? "}"

NotAllowed          ::= [^\"\#x00-#x08#x0B-#x1F#x7F]

QuotedString        ::= '"' ( Escape | NotAllowed )* '"'

LanguageTag         ::=
    "@" LanguageTagPrimary
        LanguageTagExtended?
        LanguageTagScript?
        LanguageTagRegion?

LanguageTagPrimary  ::=
    ASCII_LETTER_LOWER ASCII_LETTER_LOWER ASCII_LETTER_LOWER?

LanguageTagExtended ::=
    "-" ASCII_LETTER_UPPER ASCII_LETTER_UPPER ASCII_LETTER_UPPER

LanguageTagScript   ::=
    "-" ASCII_LETTER_UPPER ASCII_LETTER_LOWER
        ASCII_LETTER_LOWER ASCII_LETTER_LOWER

LanguageTagRegion   ::=
    "-" ( ( ASCII_LETTER_UPPER ASCII_LETTER_UPPER )
          | ( ASCII_DIGIT ASCII_DIGIT ASCII_DIGIT ) )

String              ::= QuotedString LanguageTag?

IriReference        ::=
    "<"
    ( [^<>\"{}|^`\#x00-#x20] | UnicodeEscape )*
    ">"

ValueConstructor    ::= IdentifierReference "(" SimpleValue ")"

MappingValue        ::= SimpleValue  "->" Value

ListOfValues        ::=
    "[" ( SimpleValue | ValueConstructor | IdentifierReference )+ "]"

IdentifierInitial   ::= UC_LETTER_UPPER | UC_LETTER_LOWER

IdentifierChar      ::= IdentifierInitial | UC_NUMBER_DECIMAL

Identifier          ::= IdentifierInitial IdentifierChar* ( "_" IdentifierChar+ )*

QualifiedIdentifier ::= Identifier ":" Identifier

IdentifierReference ::= QualifiedIdentifier | Identifier

LineComment         ::= ";" [^\r\n]*

Whitespace          ::=
    [^\f\n\r\t\v#x20#xa0#x1680#x2000#x200a#x2028#x2029#x202f#x205f#x3000#xfeff]

InformalConstraint  ::= "=" QuotedString ControlledLanguageTag?

ControlledLanguageTag ::=
    "@" LanguageTagPrimary ControlledLanguageScheme?

ControlledLanguageScheme ::=
    "-" ASCII_LETTER ASCII_LETTER ASCII_LETTER
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?
        ASCII_LETTER? ASCII_LETTER? ASCII_LETTER?

FormalConstraint    ::= "is" ConstraintEnvironment? ConstraintSentence "end"

ConstraintSentence  ::=
    SimpleSentence | BooleanSentence | QuantifiedSentence |
        "(" ConstraintSentence ")"

SimpleSentence      ::= Atomic | Equation

Atomic              ::= Term "(" Term* ")"

Equation            ::= Term "=" Term

BooleanSentence     ::=
    Negation |
    ConstraintSentence
        (
          Conjunction | Disjunction | ExclusiveDisjunction |
          Implication | Biconditional
        )

Negation            ::= ( "not" | "¬" ) ConstraintSentence

Conjunction         ::= ( "and" | "∧" ) ConstraintSentence

Disjunction         ::= ( "or" | "∨" ) ConstraintSentence

ExclusiveDisjunction ::= ( "xor" | "⊻" ) ConstraintSentence

Implication         ::= ( "implies" | "⇒" ) ConstraintSentence

Biconditional       ::= ( "iff" | "⇔" ) ConstraintSentence

QuantifiedSentence  ::= Universal | Existential

Universal           ::= ( "forall" | "∀" ) QuantifierBinding* QuantifiedBody

Existential         ::= ( "exists" | "∃" ) QuantifierBinding* QuantifiedBody

QuantifierBinding   ::= "self" | ( Identifer BindingTarget )

BindingTarget       ::=
    BindingFromType | BindingFromSequence | "(" BindingTarget ")"

BindingFromType     ::= "->" ( "Self" | IdentifierReference )

BindingFromSequence ::=
    ( "in" | "∈" ) ( NamePath | IdentifierReference | SequenceComprehension )

QuantifiedBody      ::= "(" ConstraintSentence ")"

Term                ::=
    NamePath | IdentifierReference | PredicateValue | FunctionalTerm | SequenceComprehension

NamePath            ::= PathSubject ( "." Identifier )+

PathSubject         ::= ( "self" | "Self" | Identifier )

PredicateValue      ::=
    SimpleValue | ListOfPredicateValues

ListOfPredicateValues ::= "∅" | ( "[" SimpleValue* "]" )

FunctionalTerm      ::= Term "(" Term* ")"

ConstraintEnvironment ::= EnvironmentDef+ "in"

EnvironmentDef      ::=
    "def" Identifier FunctionSignature?
        ( ":=" | "≔" ) ( PredicateValue | ConstraintSentence )

FunctionSignature   ::= "(" FunctionParameter+ ")" "->" FunctionType

FunctionParameter   ::= ( Identifier "->" )? FunctionType

FunctionType        ::=  AnyType | CollectionType | TypeReference

CollectionType      ::= BuiltinCollectionType "of" ( AnyType | TypeReference )

BuiltinCollectionType ::=
    "Bag" | "List" | "Maybe" | "OrderedSet" | "Sequence" | "Set"

AnyType             ::= "_"

SequenceComprehension ::= "{" ReturnedValue "|" Expression "}"

ReturnedValue       ::= Identifier | ( "[" Identifier+ "]" )

Expression          ::=
    ConjunctiveExpression | LocalBinding | ConstraintSentence | "(" Expression ")"

ConjunctiveExpression ::=
    Expression ( "and" | "∧" ) Expression

LocalBinding        ::=
    Identifier ( BindingFromType | BindingFromSequence )
