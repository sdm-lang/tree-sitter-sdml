#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* <<sec:model-constraints>>Capturing Model Constraints

In developing any data, domain, or information  model there are certain constraints between model elements that are
either difficult to represent in the model language itself. This is particularly true of visual languages or those with
a visual representation. For example, in UML it is not possible to define cross-attribute constraints (if this attribute
is true, that attribute must be false), or setting cardinality on transitive associations. To address this UML uses
Object Constraint Language[fn:ocl1][fn:ocl2], and similar languages have been proposed for parametric modeling
languages.

SDML allows constraints to be added to any model element where annotations are also allowed. A constraints MAY be named,
and MAY be either /informally/, or /formally/ specified. Informal constraints are free-form strings, these are a common
place to start even if you intend to make a formal version later. An example informal constraint is shown in listing
[[lst:ex-informal-constraint]].

#+NAME: lst:ex-informal-constraint
#+CAPTION: Example Informal Constraint
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "All definitions in this module MUST have an annotation providing a skos:prefLabel value."

end
#+END_SRC

** Informal Constraints

Informal constraints, much like regular string values, have an optional language specifier. However, unlike regular
strings this specifier has a more limited range as it's purpose is to identify the /controlled natural language/ being used.

#+CAPTION: Informal Constraint with Controlled Language
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "..."@en

end
#+END_SRC

For example, Common Logic Controlled English[fn:clce] (or Attempto Controlled English[fn:ace]) are ...

#+CAPTION: Informal Constraint with Controlled Language Dialect
#+BEGIN_SRC sdml :noeval :exports code
module example is

  assert must_have_preferred_label =
    "..."@en-CLCE

end
#+END_SRC

** Formal Constraints

Formal constraints have their own embedded constraint language whose semantics are a subset of ISO Common
Logic[fn:isocl]. ISO Common Logic is most easily understood as an abstract language that allows for the interchange of
logical expressions based in first-order predicate logic between systems using standardized representations (Common
Logic Interchange Format (CLIF), Conceptual Graph Interchange Format (CGIF), and XML notation for Common Logic (XCL)).

#+NAME: lst:grammar-formal-constraint
#+BEGIN_SRC ebnf
FormalConstraint    ::= "is" ConstraintEnvironment? ConstraintSentence "end"
#+END_SRC

[[./ebnf-diagram/FormalConstraint.svg]]

Listing [[lst:ex-tagged-constraint-1]] is another informal constraint.

#+NAME: lst:ex-tagged-constraint-1
#+CAPTION: Example Formal Constraint (1 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  datatype Tag <- string

  structure Target is
    tags -> {0..} Tag
    ;; plus more interesing things...
  end

  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset = "All of target's tags must exist in my tags."
    end
  end
end
#+END_SRC

Listing [[lst:ex-tagged-constraint-2]] is a formal version of listing [[lst:ex-tagged-constraint-1]] which iterates over the set
of tags on the type ~Target~ which is the type of the member ~inner~ which is aliased to ~self~ (~self.tags~) within the constraint body.
For each element in the sequence of tags an existential statement ensures there is an equal tag within the enclosing
structure's tag collection (~self.container.tags~). 

#+NAME: lst:ex-tagged-constraint-2
#+CAPTION: Example Formal Constraint (2 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset is
        ∀ tag ∈ self.tags ( ∃ ptag ∈ self.container.tags ( ptag = tag ) )
      end
  end
end
#+END_SRC

#+NAME: lst:grammar-constraint-sentence
#+BEGIN_SRC ebnf
ConstraintSentence  ::=
    SimpleSentence | BooleanSentence | QuantifiedSentence |
        "(" ConstraintSentence ")"
#+END_SRC

[[./ebnf-diagram/ConstraintSentence.svg]]

*** Simple Sentences

#+NAME: lst:grammar-simple-sentence
#+BEGIN_SRC ebnf
SimpleSentence      ::= Atomic | Equation
Atomic              ::= Term "(" Term* ")"
Equation            ::= Term "=" Term
#+END_SRC

[[./ebnf-diagram/SimpleSentence.svg]]

[[./ebnf-diagram/Atomic.svg]]

[[./ebnf-diagram/Equation.svg]]

*** Boolean Sentences

#+NAME: lst:grammar-boolean-sentence
#+BEGIN_SRC ebnf
BooleanSentence     ::=
    Negation |
    ConstraintSentence
        (
          Conjunction | Disjunction | ExclusiveDisjunction |
          Implication | Biconditional
        )
#+END_SRC

[[./ebnf-diagram/BooleanSentence.svg]]

#+NAME: lst:grammar-boolean-sentence-cons
#+BEGIN_SRC ebnf
Negation            ::= ( "not" | "¬" ) ConstraintSentence
Conjunction         ::= ( "and" | "∧" ) ConstraintSentence
Disjunction         ::= ( "or" | "∨" ) ConstraintSentence
ExclusiveDisjunction ::= ( "xor" | "⊻" ) ConstraintSentence
#+END_SRC

[[./ebnf-diagram/Negation.svg]]

[[./ebnf-diagram/Conjunction.svg]]

[[./ebnf-diagram/Disjunction.svg]]

[[./ebnf-diagram/ExclusiveDisjunction.svg]]

#+NAME: lst:grammar-boolean-sentence-impl
#+BEGIN_SRC ebnf
Implication         ::= ( "implies" | "⇒" ) ConstraintSentence
Biconditional       ::= ( "iff" | "⇔" ) ConstraintSentence
#+END_SRC

[[./ebnf-diagram/Implication.svg]]

[[./ebnf-diagram/Biconditional.svg]]

*** Quantified Sentences

SDML supports, as shown in listing [[lst:ex-tagged-constraint-2]] sentences that range over values using the universal ($\forall$)
or existential ($\exists$) quantifier.

#+NAME: lst:grammar-quantified-sentence
#+BEGIN_SRC ebnf
QuantifiedSentence  ::= Universal | Existential
Universal           ::= ( "forall" | "∀" ) QuantifierBinding* QuantifiedBody
Existential         ::= ( "exists" | "∃" ) QuantifierBinding* QuantifiedBody
#+END_SRC

[[./ebnf-diagram/QuantifiedSentence.svg]]

[[./ebnf-diagram/Universal.svg]]

[[./ebnf-diagram/Existential.svg]]

#+NAME: lst:grammar-quantifier-binding
#+BEGIN_SRC ebnf
QuantifierBinding   ::= "self" | ( Identifer BindingTarget )
BindingTarget       ::=
    BindingFromType | BindingFromSequence | "(" BindingTarget ")"
BindingFromType     ::= "->" ( "Self" | IdentifierReference )
BindingFromSequence ::=
    ( "in" | "∈" ) ( NamePath | IdentifierReference | SequenceComprehension )
#+END_SRC

[[./ebnf-diagram/QuantifierBinding.svg]]

[[./ebnf-diagram/BindingTarget.svg]]

[[./ebnf-diagram/BindingFromType.svg]]

[[./ebnf-diagram/BindingFromSequence.svg]]

#+NAME: lst:grammar-quantified-body
#+BEGIN_SRC ebnf
QuantifiedBody      ::= "(" ConstraintSentence ")"
#+END_SRC

[[./ebnf-diagram/QuantifiedBody.svg]]

More TBD

*** Terms

#+NAME: lst:grammar-constraint-term
#+BEGIN_SRC ebnf
Term                ::=
    NamePath
    | IdentifierReference
    | PredicateValue
    | FunctionalTerm
    | SequenceComprehension
#+END_SRC

[[./ebnf-diagram/Term.svg]]

#+NAME: lst:grammar-name-path
#+BEGIN_SRC ebnf
NamePath            ::= PathSubject ( "." Identifier )+
PathSubject         ::= ( "self" | "Self" | Identifier )
#+END_SRC

[[./ebnf-diagram/NamePath.svg]]

[[./ebnf-diagram/PathSubject.svg]]

This notation is effectively syntactic sugar as it can be systematically transformed into the form above. The
transformation rules are:

1. The reserved words ~self~ and ~Self~ may only appear as the first element.
2. The list of names *after* the first are reversed and applied in turn as functions.
   * ~name.suffix~ becomes ~suffix(name(_))~
3. The first element will become the first argument to the inner-most function.
   * ~name.suffix~ becomes ~suffix(name(def))~
4. If the path ends in an argument list the arguments are added to the corresponding function call.
   *  ~suffix(name(def)) + ("Rental")~ becomes ~suffix(name(def) "Rental")~

Similarly the quantifier collection ~self.definitions~ becomes ~definitions(self)~.

#+NAME: lst:grammar-predicate-values
#+BEGIN_SRC ebnf
PredicateValue      ::=
    SimpleValue | ListOfPredicateValues
ListOfPredicateValues ::= "[" SimpleValue* "]"
#+END_SRC

[[./ebnf-diagram/PredicateValue.svg]]

[[./ebnf-diagram/ListOfPredicateValues.svg]]

#+NAME: lst:grammar-functional-term
#+BEGIN_SRC ebnf
FunctionalTerm      ::= Term "(" Term* ")"
#+END_SRC

[[./ebnf-diagram/FunctionalTerm.svg]]

*** Sequence Comprehensions

#+NAME: lst:grammar-sequence-comprehension
#+BEGIN_SRC ebnf
SequenceComprehension ::= "{" ReturnedValue "|" Expression "}"
#+END_SRC

[[./ebnf-diagram/SequenceComprehension.svg]]

#+NAME: lst:grammar-comprehension-returns
#+BEGIN_SRC ebnf
ReturnedValue       ::= Identifier | ( "[" Identifier+ "]" )
#+END_SRC

[[./ebnf-diagram/ReturnedValue.svg]]

#+NAME: lst:grammar-comprehension-expression
#+BEGIN_SRC ebnf
Expression          ::=
    ConjunctiveExpression | LocalBinding | ConstraintSentence | "(" Expression ")"
ConjunctiveExpression   ::=
    Expression ( "and" | "∧" ) Expression
#+END_SRC

[[./ebnf-diagram/Expression.svg]]

[[./ebnf-diagram/ConjunctiveExpression.svg]]

#+NAME: lst:grammar-comprehension-local-binding
#+BEGIN_SRC ebnf
LocalBinding   ::=
    Identifier ( BindingFromType | BindingFromSequence )
#+END_SRC

[[./ebnf-diagram/LocalBinding.svg]]

*** Library Functions


#+BEGIN_EXAMPLE
def predicate(Type) -> boolean
def predicate(value -> Type) -> boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def relation(Type1, Type2) -> boolean
def relation(value1 -> Type1, value2 -> Type2) -> boolean
#+END_EXAMPLE

#+BEGIN_EXAMPLE
def function(Type, ...) -> RType
def function(value -> Type, ...) -> RType
#+END_EXAMPLE


Alternatively, listing [[lst:ex-tagged-constraint-3]] turns each sequence of tags into a set with the library function
~into_set~ and can then perform a simple subset check with the library function ~is_subset~.

#+NAME: lst:ex-tagged-constraint-3
#+CAPTION: Example Formal Constraint (3 of 3)
#+BEGIN_SRC sdml :noeval :exports code
module tagged is
  structure Thing is
    tags -> {0..} Tag
    inner -> Target is
      assert tag_subset is
        ∀ self ( is_subset( into_set(self.tags) into_set(self.container.tags)) )
      end
  end
end
#+END_SRC

*** Constraint Environment

TBD

#+NAME: lst:grammar-constraint-environment
#+BEGIN_SRC ebnf
ConstraintEnvironment ::= EnvironmentDef+ "in"
#+END_SRC

[[./ebnf-diagram/ConstraintEnvironment.svg]]

#+NAME: lst:grammar-environment-definition
#+BEGIN_SRC ebnf
EnvironmentDef      ::=
    "def" Identifier FunctionSignature?
        ( ":=" | "≔" ) ( PredicateValue | ConstraintSentence )
#+END_SRC

[[./ebnf-diagram/EnvironmentDef.svg]]

#+NAME: lst:grammar-environment-function
#+BEGIN_SRC ebnf
FunctionSignature   ::= "(" FunctionParameter+ ")" "->" FunctionType
FunctionParameter   ::= ( Identifier "->" )? FunctionType
FunctionType        ::=  AnyType | CollectionType | TypeReference
#+END_SRC

[[./ebnf-diagram/FunctionSignature.svg]]

[[./ebnf-diagram/FunctionParameter.svg]]

[[./ebnf-diagram/FunctionType.svg]]

#+NAME: lst:grammar-function-types
#+BEGIN_SRC ebnf
AnyType             ::= "_"
CollectionType      ::= BuiltinCollectionType "of" ( AnyType | TypeReference )
BuiltinCollectionType ::=
    "Bag" | "List" | "Maybe" | "OrderedSet" | "Sequence" | "Set"
#+END_SRC

[[./ebnf-diagram/CollectionType.svg]]

[[./ebnf-diagram/BuiltinCollectionType.svg]]

The example in listing [[lst:ex-formal-constraint]] is an expansion of the informal example in listing
[[lst:ex-informal-constraint]]. Here we check for the presence of the annotation on every top-level definition and then any
members of that definition. Note that this example also demonstrates the ability to create new predicates as in
~has_pref_label~ which simplifies the body of the constraint.

#+NAME: lst:ex-formal-constraint
#+CAPTION: Example Formal Constraint
#+BEGIN_SRC sdml :noeval :exports code
module labelled is

  assert must_have_preferred_label is
    def has_pref_label(anns -> Bag of Annotation) ≔
      ∃ a ∈ anns ( a.name = skos:prefLabel ∧ ¬empty(a.value )
  in
    has_pref_label(self.annotations)
    ∧ ∀ d ∈ self.definitions (
      has_pref_label(d.annotations)
      ∧ Entity(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Enumeration(d) ⇒ ∀ m ∈ d.variants ( has_pref_label(m.annotations) )
      ∧ Event(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Structure(d) ⇒ ∀ m ∈ d.flat_members ( has_pref_label(m.annotations) )
      ∧ Union(d) ⇒ ∀ m ∈ d.variants ( has_pref_label(m.annotations) )
      ∧ Property(d) ⇒ ∀ m ∈ d.roles ( has_pref_label(m.annotations) )
    )
  end

end
#+END_SRC

** Constraint Semantics

The embedded constraint language is purely functional and constraint assertions MUST return a single boolean value
determining correctness. The constraint language follows the naming convention of Common Logic, and so a constraint
corresponds to a Common Logic /sentence/ which may be one of the following forms.

*** Simple Sentences

An /atomic sentence/ takes the form of a predicate with a set of zero or more arguments.

#+BEGIN_EXAMPLE
predicate(a_1, ..., a_n)
#+END_EXAMPLE

An /equation/ sentence asserts the equality of two terms.

#+BEGIN_EXAMPLE
rhs = rhs
#+END_EXAMPLE
  
*** Boolean Sentences

The /conjunction/ of two sentences takes the form of the application of the logical /and/ operation.

#+BEGIN_EXAMPLE
lhs and rhs
lhs  ∧  rhs
#+END_EXAMPLE

The /disjunction/ of two sentences takes the form of the application of the logical /or/ operation.

#+BEGIN_EXAMPLE
lhs or rhs
lhs ∧  rhs
#+END_EXAMPLE

The /exclusive disjunction/ of two sentences takes the form of the application of the logical /xor/ operation.

#+BEGIN_EXAMPLE
lhs xor rhs
lhs  ⊻  rhs
#+END_EXAMPLE

An /implication/ relation between two sentences holds true when the right-hand proposition is a logical
consequence of the left-hand. In effect it says that "if the left-hand side is true, then the right-hand side is also
true"; however, it does not say what one can deduce if the left-hand side is not true, or under what other conditions
the right-hand side may be true.

#+BEGIN_EXAMPLE
lhs implies rhs
lhs   ==>   rhs
lhs    ⇒    rhs
#+END_EXAMPLE

A /biconditional/ relation between two sentences holds true when the both sides are either true or false. In effect, "the
left-hand side implies the right-hand side and the right-hand side implies the left-hand-side".

#+BEGIN_EXAMPLE
lhs iff  rhs
lhs <==> rhs
lhs  ⇔   rhs
#+END_EXAMPLE

$$L \iff R \equiv (L \implies R) \land (R \implies L)$$
    
*** Quantified Sentences

The /universal quantification/ over a type says that "for all values $v$ of type $T$ the sentence $s$ must hold true".

#+BEGIN_EXAMPLE
forall v -> Type (s)
     ∀ v -> Type (s)
#+END_EXAMPLE

The /universal quantification/ over a sequence says that "for all elements $e$ in the sequence $S$ the sentence $s$ must hold
true".

#+BEGIN_EXAMPLE
forall e in Sequence (s)
     ∀ e ∈  Sequence (s)
#+END_EXAMPLE

The /existential quantification/ over a type says that "there exists a value $v$ of type $T$ where the sentence $s$ holds
true".

#+BEGIN_EXAMPLE
exists v -> Type (s)
     ∃ v -> Type (s)
#+END_EXAMPLE

The /existential quantification/ over a sequence says that "there exists an element $e$ in the sequence $S$ where the sentence
$s$ holds true".

#+BEGIN_EXAMPLE
exists e in Sequence (s)
     ∃ e ∈  Sequence (s)
#+END_EXAMPLE
    
*** Sequence Comprehensions

A sequence comprehension uses /set-builder/ notation to allow both specific selection of elements from sequences and
values from types. 

The following description is from Wikipedia.

#+BEGIN_QUOTE
Set-builder notation can be used to describe a set that is defined by a predicate, that is, a logical formula that
evaluates to true for an element of the set, and false otherwise. In this form, set-builder notation has three parts:
a variable, a colon or vertical bar separator, and a predicate. Thus there is a variable on the left of the separator,
and a rule on the right of it. These three parts are contained within braces, as shown below.

$$\{ x_1...x_n | \Phi(x_i)\}$$
#+END_QUOTE

Predicates may also be combined with the usual boolean operations.

- negation :: $\{ x_1...x_n | ¬\Phi(x_i)\}$
- conjunction :: $\{ x_1...x_n | \Phi(x_i)\land\Phi(x_{i+1})\}$
- disjunction :: $\{ x_1...x_n | \Phi(x_i)\lor\Phi(x_{i+1})\}$
- exclusive disjunction :: $\{ x_1...x_n | \Phi(x_i)\veebar\Phi(x_{i+1})\}$

The domain $\mathcal{D}$ for each variable $x$ may either be described as the set of all elements in a sequence value
$\mathcal{S}$, or the set of all values for a type $\mathcal{T}$.

1. $\{ x | x \in \mathcal{S} \land \Phi(x)\}$ returns a sequence of all values $x$ in the collection $\mathcal{S}$ for which the
   predicate $\Phi$ holds (evaluates to ~true~).
   - Example: $\{ m | x \in self.members \land optional(m)\}$
1. $\{ x | x \in \mathcal{T} \land \Phi(x)\}$ returns a sequence of all values $x$ in the type $\mathcal{T}$ for which the
   predicate $\Phi$ holds (evaluates to ~true~).
   - Example: $\{ v | v \in FutureDate \land gt(v, today)\}$.
   - Example: $\{ v | v → FutureDate \land gt(v, today)\}$.

It can be shown that this is a universal quantification, /all/ values from the type $\mathcal{T}$ or sequence
$\mathcal{V}$ will be considered. A variable can be identified as existentially quantified by prefacing it's definition
with either the keyword ~exists~ or the operator ~∃~.

$$\{ x | x \in self.tags \land ∃ y \in self.container.tags \land x = y\}$$

The following definitions are taken from the standard library and act as filters over a sequence of ~Annotation~ union
values to provide sequences which only contain one or other of the types in the union.

#+BEGIN_EXAMPLE
def annotation_properties(anns -> Bag of Annotation) -> Bag of AnnotationProperty
    ≔ {a | a ∈ anns ∧ AnnotationProperty(a)}

def constraints(anns - > Bag of Annotation) -> Bag of Constraint
    ≔ {a | a ∈ anns ∧ Constraint(a)}
#+END_EXAMPLE

*** Quantified Sentences as Comprehensions

The existential qualifier specifically determines that there is /at least one/ element in the type or sequence where the
sentence provided holds true. If you need to ensure a specific cardinality, for example that /exactly three/ elements in
type or sequence are selected, use a sequence comprehension.

#+BEGIN_EXAMPLE
count({ e | e in Sequence ∧ s}) = 3
#+END_EXAMPLE

By this definition we can show that the following are equivalent.

#+BEGIN_EXAMPLE
exists e in Sequence (s)
not is_empty({ e | e in Sequence ∧ s})
#+END_EXAMPLE

More formally, if we treat the sentence $s$ as a predicate, the following equivalence holds true.

$$∃ e \in S (s(e)) ≡ ¬\{e | e \in S ∧ s(e)\}=∅$$

We can also show that the following are equivalent for universal quantification.

#+BEGIN_EXAMPLE
forall e in Sequence (s)
is_empty({ e | e in Sequence ∧ not s}
#+END_EXAMPLE

$$∀ e \in S (s(e)) ≡ \{e | e \in S ∧ ¬s(e)\}=∅$$

In this manner we can treat the quantified sentences as syntactic sugar over specific forms of sequence comprehensions.

# ----- Footnotes

[fn:ocl1] [[https://www.omg.org/spec/OCL/2.4][Object Constraint Language (OCL)]], OMG
[fn:ocl2] [[https://www.iso.org/standard/57306.html][ISO/IEC 19507:2012 Object Management Group Object Constraint Language (OCL)]], ISO/IEC
[fn:isocl] [[https://www.iso.org/standard/66249.html][ISO/IEC 24707:2018 Common Logic (CL) — A framework for a family of logic-based languages]], ISO/IEC
[fn:clce] [[http://www.jfsowa.com/clce/specs.htm][Common Logic Controlled English]], John F. Sowa, 2004.
[fn:ace] [[http://attempto.ifi.uzh.ch/site/][Attempto Controlled English (ACE)]], University of Zurich
